<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.13 set_environment - TinyCC源码分析</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">第一章</li><li class="chapter-item expanded "><a href="../chapter_1/section_1_1.html">1.1 tinycc项目介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_2.html">1.2 autoconf的使用</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_3.html">1.3 config.mak的用法</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_4.html">1.4 config.mak如何使用？</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_5.html">1.5 构建调试环境</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_6.html">1.6 入口代码</a></li><li class="chapter-item expanded "><a href="../chapter_1/LDFLAGS.html">1.7 LDFLAGS属性</a></li><li class="chapter-item expanded affix "><li class="part-title">第二章</li><li class="chapter-item expanded "><a href="../chapter_2/main函数的argc和argv.html">2.1 main 函数的 argc 和 argv</a></li><li class="chapter-item expanded "><a href="../chapter_2/static的用法.html">2.2 static的用法</a></li><li class="chapter-item expanded "><a href="../chapter_2/ppfp变量的作用.html">2.3 ppfp 变量的作用</a></li><li class="chapter-item expanded "><a href="../chapter_2/C语言中的枚举的用法.html">2.4 C 语言中的枚举的用法</a></li><li class="chapter-item expanded "><a href="../chapter_2/输出文件的类型定义.html">2.5 输出文件的类型定义</a></li><li class="chapter-item expanded "><a href="../chapter_2/什么是目标文件.html">2.6 什么是目标文件</a></li><li class="chapter-item expanded "><a href="../chapter_2/exe和dll文件的区别.html">2.7 exe和 dll 文件的区别</a></li><li class="chapter-item expanded "><a href="../chapter_2/c语言中预处理文件.html">2.8 c语言中预处理文件</a></li><li class="chapter-item expanded "><a href="../chapter_2/类型的前置声明.html">2.9 类型的前置声明</a></li><li class="chapter-item expanded "><a href="../chapter_2/TCCState.html">2.10 TCCState</a></li><li class="chapter-item expanded "><a href="../chapter_2/undefgnu_ext是什么意思.html">2.11 #undef gnu_ext 是什么意思</a></li><li class="chapter-item expanded "><a href="../chapter_2/tcc_parse_args命令行参数的解析.html">2.12 tcc_parse_args: 命令行参数的解析</a></li><li class="chapter-item expanded "><a href="../chapter_2/set_environment.html" class="active">2.13 set_environment</a></li><li class="chapter-item expanded affix "><li class="part-title">第三章</li><li class="chapter-item expanded "><a href="../chapter_3/编译的整体流程.html">编译的整体流程</a></li><li class="chapter-item expanded "><a href="../chapter_3/ST_FUNC的用法.html">ST_FUNC的用法</a></li><li class="chapter-item expanded "><a href="../chapter_3/CString.html">CString</a></li><li class="chapter-item expanded "><a href="../chapter_3/tcc_compile.html">tcc_compile</a></li><li class="chapter-item expanded "><a href="../chapter_3/tcc_enter_state.html">tcc_enter_state</a></li><li class="chapter-item expanded "><a href="../chapter_3/preprocess_start.html">preprocess_start</a></li><li class="chapter-item expanded "><a href="../chapter_3/file.html">file</a></li><li class="chapter-item expanded "><a href="../chapter_3/tccgen_init.html">tccgen_init</a></li><li class="chapter-item expanded "><a href="../chapter_3/next.html">next</a></li><li class="chapter-item expanded "><a href="../chapter_3/decl.html">decl</a></li><li class="chapter-item expanded affix "><li class="part-title">第四章</li><li class="chapter-item expanded "><a href="../chapter_4/token-values.html">token values</a></li><li class="chapter-item expanded "><a href="../chapter_4/next_nomacro.html">next_nomacro</a></li><li class="chapter-item expanded "><a href="../chapter_4/define_find.html">define_find</a></li><li class="chapter-item expanded "><a href="../chapter_4/table_ident.html">table_ident</a></li><li class="chapter-item expanded "><a href="../chapter_4/current_value_type.html">current_value_type</a></li><li class="chapter-item expanded "><a href="../chapter_4/scope.html">scope</a></li><li class="chapter-item expanded "><a href="../chapter_4/filespec.html">filespec</a></li><li class="chapter-item expanded "><a href="../chapter_4/include_ifdef_stack.html">include_ifdef_stack</a></li><li class="chapter-item expanded "><a href="../chapter_4/pack_stack_ptr.html">pack_stack_ptr</a></li><li class="chapter-item expanded "><a href="../chapter_4/macro_ptr.html">macro_ptr</a></li><li class="chapter-item expanded "><a href="../chapter_4/TOK_LINEFEED_TOK_EOF.html">TOK_LINEFEED_TOK_EOF</a></li><li class="chapter-item expanded "><a href="../chapter_4/string_slice.html">string_slice</a></li><li class="chapter-item expanded "><a href="../chapter_4/lldb如何指定源码中的函数？.html">lldb如何指定源码中的函数</a></li><li class="chapter-item expanded "><a href="../chapter_4/skip_to_eol.html">skip_to_eol</a></li><li class="chapter-item expanded "><a href="../chapter_4/什么时候切换到另一个文件.html">什么时候切换到另一个文件</a></li><li class="chapter-item expanded "><a href="../chapter_4/one_source和static函数.html">one_source和static函数</a></li><li class="chapter-item expanded "><a href="../chapter_4/type_decl.html">type_decl</a></li><li class="chapter-item expanded affix "><li class="part-title">第五章</li><li class="chapter-item expanded "><a href="../chapter_5/语法分析.html">第五章 语法分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第六章</li><li class="chapter-item expanded "><a href="../chapter_6/语义分析.html">第六章 语义分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第七章</li><li class="chapter-item expanded "><a href="../chapter_7/gen_function.html">gen_function</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TinyCC源码分析</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="set_environment"><a class="header" href="#set_environment">set_environment</a></h1>
<h2 id="函数源码"><a class="header" href="#函数源码">函数源码</a></h2>
<pre><code class="language-c">static void set_environment(TCCState *s)
{
    char * path;

    path = getenv("C_INCLUDE_PATH");
    if(path != NULL) {
        tcc_add_sysinclude_path(s, path);
    }
    path = getenv("CPATH");
    if(path != NULL) {
        tcc_add_include_path(s, path);
    }
    path = getenv("LIBRARY_PATH");
    if(path != NULL) {
        tcc_add_library_path(s, path);
    }
}

</code></pre>
<h2 id="c_include_pathcpath和library_path"><a class="header" href="#c_include_pathcpath和library_path">C_INCLUDE_PATH，CPATH和LIBRARY_PATH</a></h2>
<p>在 C 和 C++ 编译环境中，环境变量用于指定编译器和链接器搜索头文件和库文件的路径。你提到的三个环境变量 <code>C_INCLUDE_PATH</code>、<code>CPATH</code> 和 <code>LIBRARY_PATH</code>，分别用于影响编译器的头文件和库文件搜索路径。它们的用途如下：</p>
<h3 id="1-c_include_path"><a class="header" href="#1-c_include_path">1. <strong><code>C_INCLUDE_PATH</code></strong>：</a></h3>
<ul>
<li><strong>作用</strong>：<code>C_INCLUDE_PATH</code> 是专门为 C 语言设置的环境变量，它告诉编译器在指定路径中查找 C 语言的<strong>头文件</strong>（<code>*.h</code> 文件）。</li>
<li><strong>用法</strong>：当编译器遇到 <code>#include</code> 指令时，会首先在源代码指定的路径（如 <code>#include "header.h"</code> 的路径）查找，如果找不到，就会根据 <code>C_INCLUDE_PATH</code> 中列出的路径进行搜索。</li>
</ul>
<h4 id="示例"><a class="header" href="#示例">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/headers/myheader.h
</code></pre>
<p>你可以设置 <code>C_INCLUDE_PATH</code> 让编译器知道应该查找这个路径：</p>
<pre><code class="language-bash">export C_INCLUDE_PATH=/home/user/headers
</code></pre>
<p>然后在代码中：</p>
<pre><code class="language-c">#include &lt;myheader.h&gt;
</code></pre>
<p>编译器会在 <code>/home/user/headers</code> 中查找 <code>myheader.h</code>。</p>
<h4 id="注意"><a class="header" href="#注意">注意：</a></h4>
<ul>
<li><code>C_INCLUDE_PATH</code> 仅适用于 C 语言。如果你使用 C++ 编译器，它不会查找 <code>C_INCLUDE_PATH</code>，但你可以使用 <code>CPLUS_INCLUDE_PATH</code> 来指定 C++ 的头文件搜索路径。</li>
</ul>
<h3 id="2-cpath"><a class="header" href="#2-cpath">2. <strong><code>CPATH</code></strong>：</a></h3>
<ul>
<li><strong>作用</strong>：<code>CPATH</code> 是一个更通用的环境变量，它适用于 C、C++ 以及其他语言的编译器。编译器会在 <code>CPATH</code> 中指定的路径中查找头文件（包括 <code>*.h</code> 文件和其他头文件）。</li>
<li><strong>优先级</strong>：<code>CPATH</code> 的优先级低于 <code>C_INCLUDE_PATH</code> 和 <code>CPLUS_INCLUDE_PATH</code>。也就是说，如果这两个变量定义了，编译器会首先使用它们指定的路径，而 <code>CPATH</code> 中的路径在它们之后被搜索。</li>
</ul>
<h4 id="示例-1"><a class="header" href="#示例-1">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/headers2/myheader.h
</code></pre>
<p>你可以设置 <code>CPATH</code> 来告诉编译器在哪些路径中查找头文件：</p>
<pre><code class="language-bash">export CPATH=/home/user/headers2
</code></pre>
<p>然后在代码中：</p>
<pre><code class="language-c">#include &lt;myheader.h&gt;
</code></pre>
<p>编译器会在 <code>/home/user/headers2</code> 中查找 <code>myheader.h</code>。</p>
<h4 id="注意-1"><a class="header" href="#注意-1">注意：</a></h4>
<ul>
<li><code>CPATH</code> 适用于所有语言，而不仅仅是 C 或 C++。因此，它的作用范围更广。</li>
</ul>
<h3 id="3-library_path"><a class="header" href="#3-library_path">3. <strong><code>LIBRARY_PATH</code></strong>：</a></h3>
<ul>
<li>
<p><strong>作用</strong>：<code>LIBRARY_PATH</code> 用于指定链接器在链接阶段查找库文件（<code>.a</code>、<code>.so</code>、<code>.lib</code> 文件）的路径。编译器在编译阶段查找头文件，而在链接阶段查找库文件时，会参考 <code>LIBRARY_PATH</code> 中指定的目录。</p>
</li>
<li>
<p><strong>用法</strong>：当你在编译过程中链接动态库或静态库时，如果库文件不在标准库路径下（如 <code>/usr/lib</code>），你可以通过设置 <code>LIBRARY_PATH</code> 来告诉编译器在指定路径中查找库文件。</p>
</li>
</ul>
<h4 id="示例-2"><a class="header" href="#示例-2">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/libs/mylib.a
</code></pre>
<p>你可以设置 <code>LIBRARY_PATH</code> 让链接器在 <code>/home/user/libs</code> 中查找库文件：</p>
<pre><code class="language-bash">export LIBRARY_PATH=/home/user/libs
</code></pre>
<p>然后编译时：</p>
<pre><code class="language-bash">gcc -o myprogram myprogram.c -lmylib
</code></pre>
<p>链接器会在 <code>/home/user/libs</code> 中查找 <code>mylib.a</code> 并链接到程序中。</p>
<h4 id="注意-2"><a class="header" href="#注意-2">注意：</a></h4>
<ul>
<li><code>LIBRARY_PATH</code> 仅在编译器的<strong>链接阶段</strong>使用，与头文件的搜索路径无关。</li>
<li>对于运行时动态链接的库（<code>.so</code> 文件），链接器会使用 <code>LD_LIBRARY_PATH</code> 来查找。</li>
</ul>
<h3 id="三者的作用总结"><a class="header" href="#三者的作用总结">三者的作用总结：</a></h3>
<ol>
<li><strong><code>C_INCLUDE_PATH</code></strong>：专门用于 C 语言，指定编译器在编译 C 代码时查找头文件的路径。</li>
<li><strong><code>CPATH</code></strong>：更通用，适用于 C、C++ 及其他编程语言，指定编译器查找头文件的路径。</li>
<li><strong><code>LIBRARY_PATH</code></strong>：指定链接器在链接阶段查找库文件的路径。</li>
</ol>
<h4 id="环境变量的优先级"><a class="header" href="#环境变量的优先级">环境变量的优先级：</a></h4>
<ul>
<li>编译器会首先搜索默认的系统路径（如 <code>/usr/include</code>、<code>/usr/lib</code>），然后按照如下优先级搜索指定的路径：
<ul>
<li>C 语言头文件：先搜索 <code>C_INCLUDE_PATH</code>，再搜索 <code>CPATH</code>。</li>
<li>C++ 语言头文件：先搜索 <code>CPLUS_INCLUDE_PATH</code>，再搜索 <code>CPATH</code>。</li>
<li>库文件：搜索 <code>LIBRARY_PATH</code>。</li>
</ul>
</li>
</ul>
<h3 id="使用这些环境变量的好处"><a class="header" href="#使用这些环境变量的好处">使用这些环境变量的好处</a></h3>
<ol>
<li>
<p><strong>简化编译命令</strong>：通过预先设置这些环境变量，编译时无需使用 <code>-I</code>、<code>-L</code> 等编译选项来手动指定头文件和库的路径，简化了编译过程。</p>
</li>
<li>
<p><strong>跨项目使用共享的头文件和库</strong>：可以将常用的头文件和库路径放到这些环境变量中，多个项目都可以使用这些共享的资源，而无需在每个项目的构建文件中重复指定路径。</p>
</li>
</ol>
<h3 id="示例实际使用"><a class="header" href="#示例实际使用">示例：实际使用</a></h3>
<p>假设你有一个项目，其头文件和库文件位于以下自定义路径中：</p>
<pre><code>/home/user/project/include/myheader.h
/home/user/project/lib/mylib.a
</code></pre>
<p>为了编译时自动查找这些文件，你可以在终端中设置环境变量：</p>
<pre><code class="language-bash">export C_INCLUDE_PATH=/home/user/project/include
export LIBRARY_PATH=/home/user/project/lib
</code></pre>
<p>然后使用 <code>gcc</code> 编译项目时，不需要手动指定头文件和库文件路径：</p>
<pre><code class="language-bash">gcc -o myprogram main.c -lmylib
</code></pre>
<p>这将会在指定的路径中找到 <code>myheader.h</code> 和 <code>mylib.a</code>，并将它们包含到编译和链接过程中。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<ul>
<li><strong><code>C_INCLUDE_PATH</code></strong>：用于 C 语言头文件的查找路径。</li>
<li><strong><code>CPATH</code></strong>：通用的头文件查找路径，适用于 C、C++ 等语言。</li>
<li><strong><code>LIBRARY_PATH</code></strong>：用于库文件（<code>.a</code>、<code>.so</code> 等）的查找路径，影响链接器的搜索行为。</li>
</ul>
<p>这些环境变量的使用简化了构建过程，特别是在多个项目共享库和头文件的情况下。</p>
<h2 id="getenv-函数"><a class="header" href="#getenv-函数">getenv 函数</a></h2>
<pre><code class="language-c">char *__cdecl getenv(const char *_VarName);
</code></pre>
<h3 id="getenv-函数详解"><a class="header" href="#getenv-函数详解"><code>getenv</code> 函数详解</a></h3>
<p>在 C 语言中，<code>getenv</code> 是一个用于获取<strong>环境变量</strong>值的函数。环境变量是操作系统维护的一些字符串，它们可以影响正在运行的程序的行为。通过 <code>getenv</code> 函数，程序可以访问这些环境变量的值，从而获取一些配置信息或系统信息。</p>
<h3 id="函数原型"><a class="header" href="#函数原型">函数原型</a></h3>
<p><code>getenv</code> 函数的原型在头文件 <code>&lt;stdlib.h&gt;</code> 中定义：</p>
<pre><code class="language-c">char *getenv(const char *name);
</code></pre>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<ul>
<li><strong><code>name</code></strong>：这是一个指向字符串的指针，用于指定要获取的环境变量的名称。该字符串是区分大小写的。</li>
</ul>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<ul>
<li>如果环境变量 <code>name</code> 存在，<code>getenv</code> 函数返回指向环境变量值的指针，该指针指向一个以空字符 <code>\0</code> 结尾的字符串。</li>
<li>如果环境变量 <code>name</code> 不存在，<code>getenv</code> 返回 <code>NULL</code>。</li>
</ul>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p><code>getenv</code> 常用于获取操作系统中设置的环境变量，比如 <code>PATH</code>、<code>HOME</code>、<code>USER</code> 等。程序可以通过这些环境变量来配置自己的行为。</p>
<h3 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // 获取环境变量 HOME 的值
    char *home = getenv("HOME");
    if (home != NULL) {
        printf("HOME environment variable: %s\n", home);
    } else {
        printf("HOME environment variable is not set.\n");
    }

    // 获取环境变量 PATH 的值
    char *path = getenv("PATH");
    if (path != NULL) {
        printf("PATH environment variable: %s\n", path);
    } else {
        printf("PATH environment variable is not set.\n");
    }

    return 0;
}
</code></pre>
<h4 id="示例输出"><a class="header" href="#示例输出">示例输出：</a></h4>
<pre><code class="language-bash">HOME environment variable: /home/user
PATH environment variable: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ol>
<li>
<p><strong>返回的指针指向静态内存</strong>：<code>getenv</code> 返回的指针指向的是一个静态内存区域，这意味着你不应该修改这个指针指向的内容，因为它可能会影响程序的其他部分。同时，该内存区域会在下一次调用 <code>getenv</code> 时被覆盖。</p>
</li>
<li>
<p><strong>线程安全性</strong>：<code>getenv</code> 通常不是线程安全的，多个线程同时调用时可能会出现数据竞态问题。标准库中的 <code>getenv</code> 函数可能会返回同一个全局缓冲区的地址，如果多个线程同时修改或读取环境变量，可能会导致不可预期的行为。为了在多线程中安全使用，某些系统（如 Linux）提供了 <code>secure_getenv</code> 函数，或类似的线程安全解决方案。</p>
</li>
<li>
<p><strong>大小写敏感</strong>：环境变量的名字在大多数操作系统中是区分大小写的。例如，<code>PATH</code> 和 <code>path</code> 是不同的环境变量。</p>
</li>
<li>
<p><strong>空值</strong>：如果指定的环境变量不存在，<code>getenv</code> 返回 <code>NULL</code>。在使用返回值之前，一定要检查它是否为 <code>NULL</code>，以避免程序崩溃。</p>
</li>
<li>
<p><strong>依赖环境</strong>：<code>getenv</code> 依赖于系统的环境变量配置，这些变量可能会因操作系统、启动方式等不同而有所差异。在跨平台开发时，需要注意不同平台上环境变量的命名和内容可能有所不同。</p>
</li>
</ol>
<h3 id="常见环境变量"><a class="header" href="#常见环境变量">常见环境变量</a></h3>
<p>以下是一些常见的环境变量：</p>
<ul>
<li><strong><code>PATH</code></strong>：指定可执行文件的搜索路径。当你在命令行中运行一个命令时，系统会在 <code>PATH</code> 中指定的目录中查找对应的可执行文件。</li>
<li><strong><code>HOME</code></strong>：表示当前用户的主目录路径。</li>
<li><strong><code>USER</code></strong>：当前登录的用户名。</li>
<li><strong><code>PWD</code></strong>：当前工作目录。</li>
<li><strong><code>SHELL</code></strong>：用户使用的默认 shell（如 <code>/bin/bash</code>）。</li>
<li><strong><code>TEMP</code></strong>：指定临时文件存储的路径。</li>
</ul>
<h3 id="使用-getenv-来检查自定义环境变量"><a class="header" href="#使用-getenv-来检查自定义环境变量">使用 <code>getenv</code> 来检查自定义环境变量</a></h3>
<p>有时，程序可能依赖于自定义的环境变量来配置某些行为。你可以使用 <code>getenv</code> 来检查这些变量，并根据变量的值做出相应的操作。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例：</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // 检查 MY_APP_MODE 自定义环境变量
    char *mode = getenv("MY_APP_MODE");
    
    if (mode != NULL &amp;&amp; strcmp(mode, "DEBUG") == 0) {
        printf("Program is running in DEBUG mode.\n");
    } else {
        printf("Program is running in NORMAL mode.\n");
    }

    return 0;
}
</code></pre>
<p>假设我们设置了环境变量 <code>MY_APP_MODE</code>：</p>
<pre><code class="language-bash">export MY_APP_MODE=DEBUG
</code></pre>
<p>执行该程序时，将输出：</p>
<pre><code class="language-bash">Program is running in DEBUG mode.
</code></pre>
<p>如果没有设置 <code>MY_APP_MODE</code>，输出将会是：</p>
<pre><code class="language-bash">Program is running in NORMAL mode.
</code></pre>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<ul>
<li><strong>动态配置</strong>：通过环境变量配置程序的运行模式、数据库连接信息、文件路径等。</li>
<li><strong>跨平台适配</strong>：不同平台上，环境变量可以用来适配不同的系统路径和依赖项。</li>
<li><strong>调试</strong>：环境变量常用于切换程序的调试模式（如 <code>DEBUG</code>），以输出调试信息或加载不同的配置。</li>
</ul>
<h3 id="getenv-的底层工作原理"><a class="header" href="#getenv-的底层工作原理"><code>getenv</code> 的底层工作原理</a></h3>
<p>在大多数操作系统中，环境变量是进程属性的一部分。每个进程都有一个环境块（environment block），存储了当前进程的所有环境变量。<code>getenv</code> 函数实际上是通过查询这个环境块来获取变量值的。</p>
<p>例如，POSIX 系统中，环境变量存储在全局变量 <code>environ</code> 中，它是一个指向字符串数组的指针。每个字符串的形式为 <code>"KEY=VALUE"</code>。</p>
<pre><code class="language-c">extern char **environ;
</code></pre>
<p><code>getenv</code> 的实现通常是遍历这个 <code>environ</code> 数组，查找与指定 <code>name</code> 匹配的键，找到后返回对应的值。</p>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<ul>
<li><strong><code>getenv</code> 函数</strong>：用于获取系统中的环境变量值。通过传递环境变量的名称作为参数，返回该变量的值。</li>
<li><strong>返回值</strong>：成功时返回指向环境变量值的指针，失败时返回 <code>NULL</code>。</li>
<li><strong>常见用途</strong>：获取系统环境配置信息、配置程序行为、调试等。</li>
<li><strong>注意事项</strong>：返回的指针指向静态内存区域，不应修改，且 <code>getenv</code> 在多线程中可能不是线程安全的。</li>
</ul>
<p><code>getenv</code> 是一个非常有用的函数，特别是在需要根据环境动态调整程序行为的场景下，可以帮助开发者编写更加灵活和可配置的程序。</p>
<h2 id="添加-tcc-state-的路径中"><a class="header" href="#添加-tcc-state-的路径中">添加 tcc state 的路径中</a></h2>
<pre><code class="language-c">LIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;include_paths, &amp;s-&gt;nb_include_paths, pathname);
    return 0;
}

LIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;sysinclude_paths, &amp;s-&gt;nb_sysinclude_paths, pathname);
    return 0;
}

LIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;library_paths, &amp;s-&gt;nb_library_paths, pathname);
    return 0;
}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_2/tcc_parse_args命令行参数的解析.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_3/编译的整体流程.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_2/tcc_parse_args命令行参数的解析.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_3/编译的整体流程.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
