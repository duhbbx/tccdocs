<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>type_decl - TinyCC源码分析</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">第一章</li><li class="chapter-item expanded "><a href="../chapter_1/section_1_1.html">1.1 tinycc项目介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_2.html">1.2 autoconf的使用</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_3.html">1.3 config.mak的用法</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_4.html">1.4 config.mak如何使用？</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_5.html">1.5 构建调试环境</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1_6.html">1.6 入口代码</a></li><li class="chapter-item expanded "><a href="../chapter_1/LDFLAGS.html">1.7 LDFLAGS属性</a></li><li class="chapter-item expanded affix "><li class="part-title">第二章</li><li class="chapter-item expanded "><a href="../chapter_2/main函数的argc和argv.html">2.1 main 函数的 argc 和 argv</a></li><li class="chapter-item expanded "><a href="../chapter_2/static的用法.html">2.2 static的用法</a></li><li class="chapter-item expanded "><a href="../chapter_2/ppfp变量的作用.html">2.3 ppfp 变量的作用</a></li><li class="chapter-item expanded "><a href="../chapter_2/C语言中的枚举的用法.html">2.4 C 语言中的枚举的用法</a></li><li class="chapter-item expanded "><a href="../chapter_2/输出文件的类型定义.html">2.5 输出文件的类型定义</a></li><li class="chapter-item expanded "><a href="../chapter_2/什么是目标文件.html">2.6 什么是目标文件</a></li><li class="chapter-item expanded "><a href="../chapter_2/exe和dll文件的区别.html">2.7 exe和 dll 文件的区别</a></li><li class="chapter-item expanded "><a href="../chapter_2/c语言中预处理文件.html">2.8 c语言中预处理文件</a></li><li class="chapter-item expanded "><a href="../chapter_2/类型的前置声明.html">2.9 类型的前置声明</a></li><li class="chapter-item expanded "><a href="../chapter_2/TCCState.html">2.10 TCCState</a></li><li class="chapter-item expanded "><a href="../chapter_2/undefgnu_ext是什么意思.html">2.11 #undef gnu_ext 是什么意思</a></li><li class="chapter-item expanded "><a href="../chapter_2/tcc_parse_args命令行参数的解析.html">2.12 tcc_parse_args: 命令行参数的解析</a></li><li class="chapter-item expanded "><a href="../chapter_2/set_environment.html">2.13 set_environment</a></li><li class="chapter-item expanded affix "><li class="part-title">第三章</li><li class="chapter-item expanded "><a href="../chapter_3/编译的整体流程.html">编译的整体流程</a></li><li class="chapter-item expanded "><a href="../chapter_3/ST_FUNC的用法.html">ST_FUNC的用法</a></li><li class="chapter-item expanded "><a href="../chapter_3/CString.html">CString</a></li><li class="chapter-item expanded "><a href="../chapter_3/tcc_compile.html">tcc_compile</a></li><li class="chapter-item expanded "><a href="../chapter_3/tcc_enter_state.html">tcc_enter_state</a></li><li class="chapter-item expanded "><a href="../chapter_3/preprocess_start.html">preprocess_start</a></li><li class="chapter-item expanded "><a href="../chapter_3/file.html">file</a></li><li class="chapter-item expanded "><a href="../chapter_3/tccgen_init.html">tccgen_init</a></li><li class="chapter-item expanded "><a href="../chapter_3/next.html">next</a></li><li class="chapter-item expanded "><a href="../chapter_3/decl.html">decl</a></li><li class="chapter-item expanded affix "><li class="part-title">第四章</li><li class="chapter-item expanded "><a href="../chapter_4/token-values.html">token values</a></li><li class="chapter-item expanded "><a href="../chapter_4/next_nomacro.html">next_nomacro</a></li><li class="chapter-item expanded "><a href="../chapter_4/define_find.html">define_find</a></li><li class="chapter-item expanded "><a href="../chapter_4/table_ident.html">table_ident</a></li><li class="chapter-item expanded "><a href="../chapter_4/current_value_type.html">current_value_type</a></li><li class="chapter-item expanded "><a href="../chapter_4/scope.html">scope</a></li><li class="chapter-item expanded "><a href="../chapter_4/filespec.html">filespec</a></li><li class="chapter-item expanded "><a href="../chapter_4/include_ifdef_stack.html">include_ifdef_stack</a></li><li class="chapter-item expanded "><a href="../chapter_4/pack_stack_ptr.html">pack_stack_ptr</a></li><li class="chapter-item expanded "><a href="../chapter_4/macro_ptr.html">macro_ptr</a></li><li class="chapter-item expanded "><a href="../chapter_4/TOK_LINEFEED_TOK_EOF.html">TOK_LINEFEED_TOK_EOF</a></li><li class="chapter-item expanded "><a href="../chapter_4/string_slice.html">string_slice</a></li><li class="chapter-item expanded "><a href="../chapter_4/lldb如何指定源码中的函数？.html">lldb如何指定源码中的函数</a></li><li class="chapter-item expanded "><a href="../chapter_4/skip_to_eol.html">skip_to_eol</a></li><li class="chapter-item expanded "><a href="../chapter_4/什么时候切换到另一个文件.html">什么时候切换到另一个文件</a></li><li class="chapter-item expanded "><a href="../chapter_4/one_source和static函数.html">one_source和static函数</a></li><li class="chapter-item expanded "><a href="../chapter_4/type_decl.html" class="active">type_decl</a></li><li class="chapter-item expanded affix "><li class="part-title">第五章</li><li class="chapter-item expanded "><a href="../chapter_5/语法分析.html">第五章 语法分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第六章</li><li class="chapter-item expanded "><a href="../chapter_6/语义分析.html">第六章 语义分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第七章</li><li class="chapter-item expanded "><a href="../chapter_7/gen_function.html">gen_function</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TinyCC源码分析</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type_decl"><a class="header" href="#type_decl">type_decl</a></h1>
<pre><code class="language-c">/* Parse a type declarator (except basic type), and return the type
   in 'type'. 'td' is a bitmask indicating which kind of type decl is
   expected. 'type' should contain the basic type. 'ad' is the
   attribute definition of the basic type. It can be modified by
   type_decl().  If this (possibly abstract) declarator is a pointer chain
   it returns the innermost pointed to type (equals *type, but is a different
   pointer), otherwise returns type itself, that's used for recursive calls.  */
static CType *type_decl(CType *type, AttributeDef *ad, int *v, int td)
{
    CType *post, *ret;
    int qualifiers, storage;

    /* recursive type, remove storage bits first, apply them later again */
    storage = type-&gt;t &amp; VT_STORAGE;
    type-&gt;t &amp;= ~VT_STORAGE;
    post = ret = type;

    while (tok == '*') {
        qualifiers = 0;
    redo:
        next();
        switch(tok) {
        case TOK__Atomic:
            qualifiers |= VT_ATOMIC;
            goto redo;
        case TOK_CONST1:
        case TOK_CONST2:
        case TOK_CONST3:
            qualifiers |= VT_CONSTANT;
            goto redo;
        case TOK_VOLATILE1:
        case TOK_VOLATILE2:
        case TOK_VOLATILE3:
            qualifiers |= VT_VOLATILE;
            goto redo;
        case TOK_RESTRICT1:
        case TOK_RESTRICT2:
        case TOK_RESTRICT3:
            goto redo;
	/* XXX: clarify attribute handling */
	case TOK_ATTRIBUTE1:
	case TOK_ATTRIBUTE2:
	    parse_attribute(ad);
	    break;
        }
        mk_pointer(type);
        type-&gt;t |= qualifiers;
	if (ret == type)
	    /* innermost pointed to type is the one for the first derivation */
	    ret = pointed_type(type);
    }

    if (tok == '(') {
	/* This is possibly a parameter type list for abstract declarators
	   ('int ()'), use post_type for testing this.  */
	if (!post_type(type, ad, 0, td)) {
	    /* It's not, so it's a nested declarator, and the post operations
	       apply to the innermost pointed to type (if any).  */
	    /* XXX: this is not correct to modify 'ad' at this point, but
	       the syntax is not clear */
	    parse_attribute(ad);
	    post = type_decl(type, ad, v, td);
	    skip(')');
	} else
	  goto abstract;
    } else if (tok &gt;= TOK_IDENT &amp;&amp; (td &amp; TYPE_DIRECT)) {
	    /* type identifier */
	    *v = tok;
	    next();
    } else {
abstract:
	    if (!(td &amp; TYPE_ABSTRACT))
	        expect("identifier");
	    *v = 0;
    }
    post_type(post, ad, post != ret ? 0 : storage, td &amp; ~(TYPE_DIRECT|TYPE_ABSTRACT));
    parse_attribute(ad);
    type-&gt;t |= storage;
    return ret;
}
</code></pre>
<p><code>type_decl</code> 是 TinyCC 中用于解析 C 语言类型声明的函数。这段代码处理各种复杂的类型声明（如指针、数组、函数类型），并返回最终的完整类型。它通过递归解析嵌套的声明，如指针链和函数参数列表。</p>
<h3 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h3>
<ul>
<li><strong><code>CType *type</code></strong>：指向基本类型（如 <code>int</code>、<code>char</code>）的指针。函数会基于此基础类型解析完整的类型声明，并返回结果。</li>
<li><strong><code>AttributeDef *ad</code></strong>：用于保存类型的属性（如 <code>const</code>、<code>volatile</code> 或其他自定义属性）。属性可能在函数内部被修改。</li>
<li><strong><code>int *v</code></strong>：用于存储标识符（如变量名或函数名）。</li>
<li><strong><code>int td</code></strong>：一个位掩码，表示期望的类型声明形式（如直接声明或抽象声明）。</li>
</ul>
<h3 id="功能详解"><a class="header" href="#功能详解">功能详解</a></h3>
<h4 id="1-移除存储修饰符"><a class="header" href="#1-移除存储修饰符">1. 移除存储修饰符</a></h4>
<pre><code class="language-c">storage = type-&gt;t &amp; VT_STORAGE;
type-&gt;t &amp;= ~VT_STORAGE;
post = ret = type;
</code></pre>
<ul>
<li><code>storage</code> 保存了类型的存储修饰符（如 <code>static</code> 或 <code>extern</code>），这些修饰符暂时被去掉，稍后会重新应用。</li>
<li><code>post</code> 和 <code>ret</code> 都指向传入的类型，后续会递归修改 <code>type</code>。</li>
</ul>
<h4 id="2-处理指针链"><a class="header" href="#2-处理指针链">2. 处理指针链</a></h4>
<pre><code class="language-c">while (tok == '*') {
    qualifiers = 0;
redo:
    next();
    switch(tok) {
    case TOK__Atomic:
        qualifiers |= VT_ATOMIC;
        goto redo;
    case TOK_CONST1:
    case TOK_CONST2:
    case TOK_CONST3:
        qualifiers |= VT_CONSTANT;
        goto redo;
    case TOK_VOLATILE1:
    case TOK_VOLATILE2:
    case TOK_VOLATILE3:
        qualifiers |= VT_VOLATILE;
        goto redo;
    case TOK_RESTRICT1:
    case TOK_RESTRICT2:
    case TOK_RESTRICT3:
        goto redo;
    case TOK_ATTRIBUTE1:
    case TOK_ATTRIBUTE2:
        parse_attribute(ad);
        break;
    }
    mk_pointer(type);
    type-&gt;t |= qualifiers;
    if (ret == type)
        ret = pointed_type(type);
}
</code></pre>
<ul>
<li>解析以 <code>*</code> 开始的指针类型链。每当遇到 <code>*</code> 时，进入循环，检查是否有修饰符（如 <code>const</code>、<code>volatile</code>、<code>restrict</code>），并累积到 <code>qualifiers</code> 中。</li>
<li>调用 <code>mk_pointer(type)</code> 将类型转为指针类型，并将修饰符应用到类型中。</li>
<li>如果这是最内层的指针类型，则通过 <code>pointed_type(type)</code> 获取指针指向的类型。</li>
</ul>
<h4 id="3-处理括号和嵌套声明"><a class="header" href="#3-处理括号和嵌套声明">3. 处理括号和嵌套声明</a></h4>
<pre><code class="language-c">if (tok == '(') {
    if (!post_type(type, ad, 0, td)) {
        parse_attribute(ad);
        post = type_decl(type, ad, v, td);
        skip(')');
    } else
        goto abstract;
}
</code></pre>
<ul>
<li>当遇到左括号 <code>(</code> 时，可能是函数类型或嵌套的类型声明。<code>post_type</code> 检查是否为函数参数列表。</li>
<li>如果是嵌套声明，递归调用 <code>type_decl</code> 继续解析，并跳过右括号 <code>)</code>。</li>
</ul>
<h4 id="4-处理标识符和抽象声明"><a class="header" href="#4-处理标识符和抽象声明">4. 处理标识符和抽象声明</a></h4>
<pre><code class="language-c">else if (tok &gt;= TOK_IDENT &amp;&amp; (td &amp; TYPE_DIRECT)) {
    *v = tok;
    next();
} else {
abstract:
    if (!(td &amp; TYPE_ABSTRACT))
        expect("identifier");
    *v = 0;
}
</code></pre>
<ul>
<li>如果当前标记是标识符，并且允许直接声明，则存储标识符。</li>
<li>如果是抽象声明且不允许标识符，抛出错误。</li>
</ul>
<h4 id="5-应用后缀和存储修饰符"><a class="header" href="#5-应用后缀和存储修饰符">5. 应用后缀和存储修饰符</a></h4>
<pre><code class="language-c">post_type(post, ad, post != ret ? 0 : storage, td &amp; ~(TYPE_DIRECT|TYPE_ABSTRACT));
parse_attribute(ad);
type-&gt;t |= storage;
return ret;
</code></pre>
<ul>
<li><code>post_type</code> 应用于当前类型，处理函数、数组等后缀操作。</li>
<li>重新应用之前移除的存储修饰符（如 <code>static</code>）。</li>
</ul>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p><code>type_decl</code> 负责解析 C 语言中的复杂类型声明，包括指针、数组、函数参数等。它递归处理嵌套声明，并根据传入的标志和属性构建完整的类型信息。</p>
<h1 id="详细的例子"><a class="header" href="#详细的例子">详细的例子</a></h1>
<p>当然！让我们通过几个示例来说明 <code>type_decl</code> 函数在不同情况下如何解析复杂的 C 语言类型声明。我们会从简单的指针声明到更复杂的函数指针声明逐步进行解释。</p>
<h3 id="1-基本类型声明"><a class="header" href="#1-基本类型声明">1. 基本类型声明</a></h3>
<h4 id="示例"><a class="header" href="#示例">示例：</a></h4>
<pre><code class="language-c">int a;
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，没有指针或修饰符。</li>
<li><strong>解析过程</strong>：由于没有指针、修饰符或函数参数，<code>type_decl</code> 不做任何特殊处理，直接返回 <code>int</code> 类型。</li>
<li><strong>返回类型</strong>：<code>int</code>。</li>
</ul>
<h4 id="解释"><a class="header" href="#解释">解释：</a></h4>
<p>这是最基本的类型声明，<code>int a;</code> 表示声明了一个整型变量 <code>a</code>。<code>type_decl</code> 接收到的 <code>type</code> 只是 <code>int</code>，没有任何修饰符或复杂结构，所以最终返回的类型也是 <code>int</code>。</p>
<hr />
<h3 id="2-指针类型"><a class="header" href="#2-指针类型">2. 指针类型</a></h3>
<h4 id="示例-1"><a class="header" href="#示例-1">示例：</a></h4>
<pre><code class="language-c">int *p;
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，解析遇到 <code>*</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>遇到 <code>*</code>，调用 <code>mk_pointer(type)</code> 将 <code>int</code> 类型转换为指向 <code>int</code> 的指针。</li>
<li><code>post_type</code> 处理后缀操作，但没有其他特殊情况，所以跳过。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int *</code>。</li>
</ul>
<h4 id="解释-1"><a class="header" href="#解释-1">解释：</a></h4>
<p><code>int *p</code> 表示声明了一个指向 <code>int</code> 类型的指针。<code>type_decl</code> 首先接收到基础类型 <code>int</code>，遇到 <code>*</code> 后，它会调用 <code>mk_pointer(type)</code> 将类型转换为 <code>int *</code>（指向 <code>int</code> 的指针）。</p>
<hr />
<h3 id="3-常量修饰的指针"><a class="header" href="#3-常量修饰的指针">3. 常量修饰的指针</a></h3>
<h4 id="示例-2"><a class="header" href="#示例-2">示例：</a></h4>
<pre><code class="language-c">const int *p;
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，解析到 <code>const</code> 和 <code>*</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>首先遇到 <code>const</code>，累积修饰符 <code>VT_CONSTANT</code>。</li>
<li>然后遇到 <code>*</code>，将 <code>int</code> 类型转换为指向 <code>const int</code> 的指针。</li>
<li>修饰符 <code>VT_CONSTANT</code> 应用到类型上。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>const int *</code>。</li>
</ul>
<h4 id="解释-2"><a class="header" href="#解释-2">解释：</a></h4>
<p>在 <code>const int *p</code> 中，指针 <code>p</code> 指向的是 <code>const int</code>，即 <code>p</code> 不能修改它指向的整数值。<code>type_decl</code> 通过遇到 <code>const</code> 累积修饰符，并将其应用到 <code>int</code> 类型后，再解析 <code>*</code>，最终返回类型为 <code>const int *</code>。</p>
<hr />
<h3 id="4-多层指针"><a class="header" href="#4-多层指针">4. 多层指针</a></h3>
<h4 id="示例-3"><a class="header" href="#示例-3">示例：</a></h4>
<pre><code class="language-c">int **pp;
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，解析遇到两次 <code>*</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>第一次遇到 <code>*</code>，将 <code>int</code> 转换为 <code>int *</code>。</li>
<li>第二次遇到 <code>*</code>，将 <code>int *</code> 转换为 <code>int **</code>。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int **</code>。</li>
</ul>
<h4 id="解释-3"><a class="header" href="#解释-3">解释：</a></h4>
<p><code>int **pp</code> 声明了一个指向指针的指针。<code>type_decl</code> 会多次调用 <code>mk_pointer(type)</code>，第一次将 <code>int</code> 转为 <code>int *</code>，第二次将其转为 <code>int **</code>。</p>
<hr />
<h3 id="5-数组类型"><a class="header" href="#5-数组类型">5. 数组类型</a></h3>
<h4 id="示例-4"><a class="header" href="#示例-4">示例：</a></h4>
<pre><code class="language-c">int arr[10];
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，接下来解析数组 <code>[10]</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>检测到数组声明 <code>[10]</code>，<code>post_type</code> 处理数组类型，将 <code>int</code> 转换为 <code>int[10]</code>。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int[10]</code>。</li>
</ul>
<h4 id="解释-4"><a class="header" href="#解释-4">解释：</a></h4>
<p>在 <code>int arr[10];</code> 中，<code>arr</code> 是一个包含 10 个整数的数组。<code>type_decl</code> 首先解析基础类型 <code>int</code>，然后遇到数组声明 <code>[10]</code>，将其转换为 <code>int[10]</code>。</p>
<hr />
<h3 id="6-函数指针"><a class="header" href="#6-函数指针">6. 函数指针</a></h3>
<h4 id="示例-5"><a class="header" href="#示例-5">示例：</a></h4>
<pre><code class="language-c">int (*f)(int, char);
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，解析遇到 <code>*f</code> 和函数参数 <code>(int, char)</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>首先遇到 <code>*</code>，将 <code>int</code> 转换为 <code>int *</code>，表示指针。</li>
<li>然后遇到括号 <code>()</code>，识别为函数声明，进入递归解析。</li>
<li>解析函数参数列表 <code>(int, char)</code>，构建函数类型 <code>int (int, char)</code>。</li>
<li>最后返回的类型是指向该函数类型的指针 <code>int (*)(int, char)</code>。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int (*)(int, char)</code>。</li>
</ul>
<h4 id="解释-5"><a class="header" href="#解释-5">解释：</a></h4>
<p><code>int (*f)(int, char)</code> 表示声明了一个函数指针 <code>f</code>，该函数返回 <code>int</code>，并接收 <code>int</code> 和 <code>char</code> 类型的参数。<code>type_decl</code> 首先解析 <code>*</code>，然后处理函数参数列表 <code>(int, char)</code>，最终构建出完整的函数指针类型 <code>int (*)(int, char)</code>。</p>
<hr />
<h3 id="7-指向数组的指针"><a class="header" href="#7-指向数组的指针">7. 指向数组的指针</a></h3>
<h4 id="示例-6"><a class="header" href="#示例-6">示例：</a></h4>
<pre><code class="language-c">int (*p)[5];
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，解析遇到 <code>*p</code> 和数组 <code>[5]</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>首先遇到 <code>*</code>，将 <code>int</code> 转换为指向 <code>int</code> 的指针。</li>
<li>然后检测到数组 <code>[5]</code>，将类型转为指向数组的指针，即 <code>int (*)[5]</code>。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int (*)[5]</code>。</li>
</ul>
<h4 id="解释-6"><a class="header" href="#解释-6">解释：</a></h4>
<p><code>int (*p)[5]</code> 声明了一个指向数组的指针 <code>p</code>，该数组包含 5 个 <code>int</code> 类型的元素。<code>type_decl</code> 通过解析 <code>*</code> 和数组部分，将其转换为指向数组的指针 <code>int (*)[5]</code>。</p>
<hr />
<h3 id="8-带属性的类型"><a class="header" href="#8-带属性的类型">8. 带属性的类型</a></h3>
<h4 id="示例-7"><a class="header" href="#示例-7">示例：</a></h4>
<pre><code class="language-c">__attribute__((aligned(16))) int a;
</code></pre>
<ul>
<li><strong>输入</strong>：<code>CType *type</code> 表示 <code>int</code>，并解析到属性 <code>__attribute__((aligned(16)))</code>。</li>
<li><strong>解析过程</strong>：
<ul>
<li>检测到属性 <code>__attribute__</code>，调用 <code>parse_attribute(ad)</code> 解析并将其存储到 <code>AttributeDef</code> 中。</li>
<li>最终将这些属性应用到 <code>int</code> 类型上。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<code>int</code>（带对齐属性）。</li>
</ul>
<h4 id="解释-7"><a class="header" href="#解释-7">解释：</a></h4>
<p><code>__attribute__((aligned(16))) int a;</code> 声明了一个具有 16 字节对齐的 <code>int</code> 类型。<code>type_decl</code> 通过 <code>parse_attribute(ad)</code> 处理属性，并将该对齐属性应用到 <code>int</code> 类型。</p>
<hr />
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<ul>
<li><strong>简单声明</strong>：如 <code>int a;</code> 直接返回基本类型。</li>
<li><strong>指针声明</strong>：如 <code>int *p;</code> 或 <code>int **pp;</code> 通过 <code>mk_pointer</code> 递归处理指针链。</li>
<li><strong>数组声明</strong>：如 <code>int arr[10];</code> 通过 <code>post_type</code> 处理数组类型。</li>
<li><strong>函数指针声明</strong>：如 <code>int (*f)(int, char);</code> 通过递归处理嵌套的指针和函数声明。</li>
<li><strong>带属性的声明</strong>：如 <code>__attribute__((aligned(16))) int a;</code> 通过 <code>parse_attribute</code> 处理类型的自定义属性。</li>
</ul>
<p>这些例子展示了 <code>type_decl</code> 如何处理不同的 C 语言类型声明，它可以处理从基本类型、指针、数组到复杂的函数指针声明，确保编译器能够解析各种复杂的 C 语言类型。</p>
<h1 id="感觉好复杂"><a class="header" href="#感觉好复杂">感觉好复杂</a></h1>
<p>是的，C 语言的类型声明解析确实相当复杂，尤其是像指针、数组、函数指针这样的嵌套声明。当我们深入了解这些复杂结构时，可能会感到很难理解，但它们背后的逻辑是很有规律的。为了帮助简化这些复杂的解析，让我为你提供一些思路，并总结几条规律：</p>
<h3 id="1-从右往左阅读复杂的-c-类型声明"><a class="header" href="#1-从右往左阅读复杂的-c-类型声明">1. <strong>从右往左阅读复杂的 C 类型声明</strong></a></h3>
<p>C 语言的类型声明可以通过<strong>从标识符出发，向右、然后向左阅读</strong>来理解。</p>
<ul>
<li><strong>指针</strong> (<code>*</code>) 通常向左指示。例如，<code>int *p</code> 可以理解为：<code>p</code> 是一个指向 <code>int</code> 的指针。</li>
<li><strong>数组</strong> (<code>[size]</code>) 和 <strong>函数</strong> (<code>(params)</code>) 向右解析。例如，<code>int f(int)</code> 表示 <code>f</code> 是一个函数，它返回 <code>int</code>，<code>int a[10]</code> 表示 <code>a</code> 是一个大小为 10 的数组。</li>
</ul>
<h4 id="示例-8"><a class="header" href="#示例-8">示例：</a></h4>
<pre><code class="language-c">int (*p)[10];   // p 是一个指向包含 10 个 int 的数组的指针
int *f(int);    // f 是一个函数，它返回一个指向 int 的指针
</code></pre>
<h3 id="2-指针链"><a class="header" href="#2-指针链">2. <strong>指针链</strong></a></h3>
<p>如果一个变量是多个指针的组合，可以递归解析指针链，<code>type_decl</code> 在解析时也是遵循这一点。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例：</a></h4>
<pre><code class="language-c">int **pp;   // pp 是一个指向指针的指针，最终指向一个 int
</code></pre>
<h3 id="3-嵌套的括号解析"><a class="header" href="#3-嵌套的括号解析">3. <strong>嵌套的括号解析</strong></a></h3>
<p>函数指针、指向数组的指针等复杂结构都依赖于嵌套的括号解析。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例：</a></h4>
<pre><code class="language-c">int (*f)(int, char);  // f 是一个函数指针，指向返回 int，参数为 int 和 char 的函数
int (*p)[5];          // p 是一个指针，指向包含 5 个 int 的数组
</code></pre>
<p>在这些情况下，<code>()</code> 和 <code>*</code> 的优先级让指针和数组、函数结构正确关联在一起。TinyCC 的 <code>type_decl</code> 函数通过递归处理这些嵌套关系。</p>
<h3 id="4-类型修饰符"><a class="header" href="#4-类型修饰符">4. <strong>类型修饰符</strong></a></h3>
<p>修饰符如 <code>const</code>、<code>volatile</code>、<code>restrict</code> 等会修饰基础类型或指针。例如，<code>const int *p</code> 表示 <code>p</code> 是一个指向 <code>const int</code> 的指针，但 <code>p</code> 本身可以被修改，反之 <code>int *const p</code> 表示指针 <code>p</code> 本身不可修改。</p>
<h3 id="5-函数指针与数组指针的优先级"><a class="header" href="#5-函数指针与数组指针的优先级">5. <strong>函数指针与数组指针的优先级</strong></a></h3>
<p>要小心区分函数指针和数组指针的优先级。例如：</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例：</a></h4>
<pre><code class="language-c">int (*p[10])(int);  // p 是一个数组，包含 10 个指向返回 int 的函数的指针
</code></pre>
<p>这种声明看似复杂，但它可以被分解为：</p>
<ul>
<li><code>p[10]</code> 是一个数组，大小为 10。</li>
<li><code>(*p[10])</code> 表示数组中的每个元素是一个指针。</li>
<li><code>(*p[10])(int)</code> 表示这个指针指向一个函数，该函数接收一个 <code>int</code> 参数，并返回 <code>int</code>。</li>
</ul>
<h3 id="6-总结一些常见复杂声明的模板"><a class="header" href="#6-总结一些常见复杂声明的模板">6. <strong>总结一些常见复杂声明的模板</strong></a></h3>
<ul>
<li><strong>简单指针</strong>：<code>int *p;</code> —— <code>p</code> 是指向 <code>int</code> 的指针。</li>
<li><strong>指向数组的指针</strong>：<code>int (*p)[10];</code> —— <code>p</code> 是指向大小为 10 的 <code>int</code> 数组的指针。</li>
<li><strong>函数指针</strong>：<code>int (*f)(int);</code> —— <code>f</code> 是一个指向函数的指针，该函数接收 <code>int</code>，返回 <code>int</code>。</li>
<li><strong>数组的函数指针</strong>：<code>int (*p[10])(int);</code> —— <code>p</code> 是一个数组，包含 10 个函数指针，每个函数接收 <code>int</code>，返回 <code>int</code>。</li>
</ul>
<h3 id="7-简化思路"><a class="header" href="#7-简化思路">7. <strong>简化思路</strong></a></h3>
<p>面对复杂的类型声明，你可以按照以下步骤来解析：</p>
<ol>
<li><strong>找到标识符</strong>（变量名、函数名等）。</li>
<li><strong>向右看</strong>，找到数组、函数等后缀。</li>
<li><strong>向左看</strong>，找到指针、修饰符等。</li>
<li>将修饰符逐层解析到基础类型。</li>
</ol>
<hr />
<p>尽管 <code>type_decl</code> 的实现细节复杂，但它的设计就是为了自动处理这些复杂的 C 语言类型声明。理解这些类型解析的规则，特别是从右向左阅读的习惯，会让你更容易掌握 C 语言的类型声明。希望这些例子和思路能够帮助你简化对 <code>type_decl</code> 解析的理解。</p>
<h1 id="有一个问题是汇编如何识别这些复杂的类型呢"><a class="header" href="#有一个问题是汇编如何识别这些复杂的类型呢">有一个问题是汇编如何识别这些复杂的类型呢？</a></h1>
<p>这是一个非常好的问题。在 C 编译过程中，复杂的类型声明（如指针、数组、函数指针等）会在高级语言级别被处理，而汇编语言实际上并不直接“识别”这些复杂类型。汇编层面关注的是<strong>内存地址、数据存储和函数调用的低级实现</strong>，它依赖编译器在代码生成阶段将这些复杂的类型映射为相应的内存操作和 CPU 指令。</p>
<h3 id="1-编译器的角色"><a class="header" href="#1-编译器的角色">1. <strong>编译器的角色</strong></a></h3>
<p>编译器（如 TinyCC 或 GCC）负责将高级语言（如 C 语言）的复杂类型转换为汇编指令。在这个过程中，复杂类型会被“打平”成基础的内存操作和指令。编译器根据 C 语言的类型系统和作用域规则生成合适的汇编代码。</p>
<ul>
<li>
<p><strong>指针</strong>：在汇编层面，指针只是一个存储内存地址的变量。编译器会将指针的使用（如访问或修改它指向的值）翻译为相应的内存地址计算和加载/存储指令。</p>
</li>
<li>
<p><strong>数组</strong>：数组在汇编中通常只是一个连续的内存块。编译器会根据数组的类型和维度确定每个元素的内存布局，然后通过指针偏移访问数组元素。</p>
</li>
<li>
<p><strong>函数指针</strong>：在汇编中，函数指针只是一个保存函数入口地址的变量。调用函数指针时，编译器会生成一个“间接调用”指令，使用该指针存储的地址跳转到函数的实际位置。</p>
</li>
</ul>
<h3 id="2-汇编如何处理常见类型"><a class="header" href="#2-汇编如何处理常见类型">2. <strong>汇编如何处理常见类型</strong></a></h3>
<h4 id="指针"><a class="header" href="#指针">指针</a></h4>
<p>对于指针类型，如 <code>int *p;</code>，汇编并不会有专门的“指针类型”，而是将其视为一个普通的内存地址。</p>
<p>例如：</p>
<pre><code class="language-c">int *p;
*p = 10;
</code></pre>
<p>编译器会将 <code>*p = 10</code> 翻译成以下指令：</p>
<ul>
<li>取出 <code>p</code> 存储的地址。</li>
<li>将值 <code>10</code> 存储到 <code>p</code> 指向的地址。</li>
</ul>
<p>在 x86 汇编中，可能会类似于：</p>
<pre><code class="language-asm">mov eax, [p]      ; 将 p 指向的地址加载到寄存器 eax
mov [eax], 10     ; 将 10 存储到 eax 指向的内存地址中
</code></pre>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<p>数组在汇编中是连续分配的内存块。编译器会将数组的索引操作转换为指针加偏移。</p>
<p>例如：</p>
<pre><code class="language-c">int arr[10];
arr[2] = 5;
</code></pre>
<p>编译器会计算 <code>arr[2]</code> 在内存中的偏移（基于数组元素大小），然后生成访问内存的指令：</p>
<pre><code class="language-asm">mov eax, [arr]        ; 将 arr 的起始地址加载到 eax 中
mov [eax + 8], 5      ; 将 5 存储到 arr[2] 对应的地址 (2 * sizeof(int))
</code></pre>
<h4 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h4>
<p>函数指针在汇编中就是保存函数地址的变量。调用函数指针时，汇编会生成“间接调用”指令。</p>
<p>例如：</p>
<pre><code class="language-c">void (*f)(int);
f(3);
</code></pre>
<p>编译器会将这个函数调用转换为：</p>
<pre><code class="language-asm">mov eax, [f]      ; 将函数指针 f 的值（即函数地址）加载到寄存器 eax
mov edi, 3        ; 将参数 3 放入寄存器
call eax          ; 调用 eax 中的函数地址
</code></pre>
<h4 id="带修饰符的类型"><a class="header" href="#带修饰符的类型">带修饰符的类型</a></h4>
<p>例如 <code>const</code> 和 <code>volatile</code> 这样的修饰符，它们影响的是编译器如何生成代码，而不是汇编的语法。<code>const</code> 表示变量不能被修改，编译器会在生成代码时确保这一点；<code>volatile</code> 告诉编译器不应优化对该变量的访问，因为它可能随时被硬件或其他线程修改。</p>
<p>这些修饰符并不会直接映射到汇编语言中。</p>
<h3 id="3-编译器将复杂类型映射到汇编"><a class="header" href="#3-编译器将复杂类型映射到汇编">3. <strong>编译器将复杂类型映射到汇编</strong></a></h3>
<h4 id="复杂类型的降级"><a class="header" href="#复杂类型的降级">复杂类型的降级</a></h4>
<p>在编译过程中，编译器将复杂类型逐步转换为低级操作：</p>
<ul>
<li><strong>类型检查与符号解析</strong>：编译器首先在高层次做类型检查，确保类型正确、函数原型匹配等。</li>
<li><strong>内存分配</strong>：复杂的类型（如数组、结构体、指针）最终都被映射为内存布局。编译器计算每个变量的大小和对齐要求，将它们映射到特定的内存地址。</li>
<li><strong>汇编生成</strong>：编译器将类型降级为具体的指令。函数调用、内存访问、偏移计算等都会被编译为相应的汇编指令。</li>
</ul>
<p>例如：</p>
<pre><code class="language-c">int (*p)[10];
(*p)[2] = 5;
</code></pre>
<p>这个复杂的类型声明中，<code>p</code> 是一个指向包含 10 个 <code>int</code> 元素的数组的指针，<code>(*p)[2] = 5;</code> 最终只是对一个内存地址的偏移访问。</p>
<p>汇编中可能会变为：</p>
<pre><code class="language-asm">mov eax, [p]         ; 加载 p 指向的数组的起始地址
mov [eax + 8], 5     ; 将 5 存储到数组中偏移 8 字节的位置 (2 * sizeof(int))
</code></pre>
<h4 id="函数调用约定"><a class="header" href="#函数调用约定">函数调用约定</a></h4>
<p>复杂类型的函数指针最终也是通过标准的函数调用约定来处理的。对于不同的体系结构，函数调用的参数传递方式（如通过寄存器或栈传递）有所不同。编译器生成的汇编代码会遵循相应的函数调用约定。</p>
<h3 id="4-总结汇编只关注地址与指令"><a class="header" href="#4-总结汇编只关注地址与指令">4. <strong>总结：汇编只关注地址与指令</strong></a></h3>
<p>汇编语言不需要理解高级语言的复杂类型，它只需要按照编译器提供的内存布局和操作指令执行相应的动作。编译器则负责将这些复杂类型解析为汇编能够理解的<strong>地址计算和指令</strong>：</p>
<ul>
<li>指针被编译为地址操作。</li>
<li>数组被编译为指针加偏移的内存访问。</li>
<li>函数指针被编译为间接调用指令。</li>
</ul>
<p>复杂类型的本质是在内存和指令级别表现为一系列低级的操作，编译器通过类型系统进行高层次的管理和优化，而最终生成的汇编代码关注的是如何在特定的内存位置进行数据操作和跳转。</p>
<h1 id="关于类型的高级知识"><a class="header" href="#关于类型的高级知识">关于类型的高级知识？</a></h1>
<p>当然！类型系统不仅是编程语言的核心，而且在不同的编程语言、编译器和计算机体系结构中具有深远的影响。为了帮助你了解更多关于类型的高级知识，我们可以从以下几个方面进行拓展：</p>
<h3 id="1-类型系统的分类"><a class="header" href="#1-类型系统的分类">1. <strong>类型系统的分类</strong></a></h3>
<p>类型系统在编程语言中扮演着至关重要的角色，它定义了如何组织和操作数据。类型系统可以根据多种标准进行分类：</p>
<h4 id="静态类型-vs-动态类型"><a class="header" href="#静态类型-vs-动态类型">静态类型 vs 动态类型</a></h4>
<ul>
<li>
<p><strong>静态类型（Static Typing）</strong>：在编译时确定每个变量的类型。例如，C、C++、Java 等语言都是静态类型语言。在这种类型系统中，编译器可以提前检测类型错误。</p>
<ul>
<li><strong>优点</strong>：提高代码的安全性，允许编译器进行更多的优化，代码执行速度快。</li>
<li><strong>缺点</strong>：灵活性较差，通常需要显式声明类型。</li>
</ul>
</li>
<li>
<p><strong>动态类型（Dynamic Typing）</strong>：在运行时确定变量的类型，例如 Python、JavaScript 等语言。变量的类型可以根据运行时的值动态变化。</p>
<ul>
<li><strong>优点</strong>：编写代码时更灵活，不需要显式声明类型。</li>
<li><strong>缺点</strong>：类型错误只在运行时暴露，影响性能和安全性。</li>
</ul>
</li>
</ul>
<h4 id="强类型-vs-弱类型"><a class="header" href="#强类型-vs-弱类型">强类型 vs 弱类型</a></h4>
<ul>
<li>
<p><strong>强类型（Strong Typing）</strong>：不允许隐式的类型转换。例如，Java 和 Python 是强类型语言，不允许将一个字符串自动转换为整数。</p>
<ul>
<li><strong>优点</strong>：避免了意外的类型转换错误。</li>
<li><strong>缺点</strong>：在某些情况下需要显式地进行类型转换，增加代码复杂性。</li>
</ul>
</li>
<li>
<p><strong>弱类型（Weak Typing）</strong>：允许隐式类型转换。C 是一种弱类型语言，可以隐式地将 <code>int</code> 类型转换为 <code>float</code> 或将指针转换为其他类型。</p>
<ul>
<li><strong>优点</strong>：灵活，编写代码更方便。</li>
<li><strong>缺点</strong>：容易导致错误，特别是在隐式类型转换时。</li>
</ul>
</li>
</ul>
<h4 id="显式类型-vs-类型推断"><a class="header" href="#显式类型-vs-类型推断">显式类型 vs 类型推断</a></h4>
<ul>
<li>
<p><strong>显式类型（Explicit Typing）</strong>：要求程序员在声明变量时显式指定类型。C 和 Java 是显式类型语言。</p>
</li>
<li>
<p><strong>类型推断（Type Inference）</strong>：编译器会根据上下文自动推断变量的类型。现代语言如 Rust、TypeScript 和 OCaml 都支持类型推断，这减少了显式声明类型的负担。</p>
<ul>
<li><strong>优点</strong>：提高代码的简洁性，减少冗余。</li>
<li><strong>缺点</strong>：类型推断机制可能会增加编译器的复杂性。</li>
</ul>
</li>
</ul>
<h3 id="2-高级类型概念"><a class="header" href="#2-高级类型概念">2. <strong>高级类型概念</strong></a></h3>
<h4 id="泛型generics"><a class="header" href="#泛型generics">泛型（Generics）</a></h4>
<p>泛型是一种强大的类型系统功能，允许在不指定具体类型的情况下定义函数、结构体和类。例如，C++ 的模板、Java 和 Rust 的泛型机制允许我们编写可重用的代码，同时保持类型安全。</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
</code></pre>
<ul>
<li><strong>优点</strong>：提高代码的可重用性和类型安全性。</li>
<li><strong>缺点</strong>：可能会增加编译器复杂性，泛型代码的错误调试更加困难。</li>
</ul>
<h4 id="类型多态性"><a class="header" href="#类型多态性">类型多态性</a></h4>
<ul>
<li><strong>参数多态性</strong>：允许编写可操作任意类型的函数或数据结构，而不必依赖于具体的类型。例如，C++ 的模板和 Java 的泛型都是参数多态性。</li>
<li><strong>子类型多态性</strong>：允许将派生类的对象传递到基类的引用或指针中。Java 和 C++ 都支持子类型多态性，即“面向对象编程”中的多态性。</li>
</ul>
<h4 id="代数数据类型algebraic-data-types-adts"><a class="header" href="#代数数据类型algebraic-data-types-adts">代数数据类型（Algebraic Data Types, ADTs）</a></h4>
<p>代数数据类型是函数式编程语言中的重要概念，尤其在 Haskell、Scala、Rust 等语言中非常常见。代数数据类型包括<strong>和类型</strong>（sum type）和<strong>积类型</strong>（product type）。</p>
<ul>
<li>
<p><strong>和类型</strong>：一个类型可以是多个类型之一，例如 Haskell 中的 <code>Either</code> 类型，或者 Rust 中的 <code>enum</code>。它表示一个值可以是多种类型中的一种。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>积类型</strong>：类似于 C 语言中的结构体，它组合了多个类型。一个值同时包含多个不同类型的值。</p>
</li>
</ul>
<h4 id="依赖类型dependent-types"><a class="header" href="#依赖类型dependent-types">依赖类型（Dependent Types）</a></h4>
<p>依赖类型是更高级的类型系统概念，其中类型可以依赖于值。这使得编译器可以进行更精细的类型检查。例如，一个数组的类型可以包含其长度，这样在编译时就可以检测数组访问越界。</p>
<ul>
<li>
<p><strong>应用</strong>：依赖类型在 Idris、Agda 等高级编程语言中有很好的应用。它们允许将类型检查推进到极限，以确保程序的正确性。</p>
</li>
<li>
<p><strong>优点</strong>：提高程序的安全性和正确性，能够捕捉许多运行时错误。</p>
</li>
<li>
<p><strong>缺点</strong>：编译器和程序员都需要处理更复杂的类型推理。</p>
</li>
</ul>
<h3 id="3-内存布局与类型系统"><a class="header" href="#3-内存布局与类型系统">3. <strong>内存布局与类型系统</strong></a></h3>
<p>尽管汇编语言本身并不直接“理解”高级语言中的类型系统，但类型系统的设计直接影响内存布局和内存管理。编译器将复杂的类型信息转化为合适的内存布局和指令序列。</p>
<h4 id="指针与内存管理"><a class="header" href="#指针与内存管理">指针与内存管理</a></h4>
<ul>
<li>
<p><strong>指针</strong> 是类型系统的重要部分，它们在汇编语言中只是内存地址的引用。编译器在生成汇编时，会将指针的操作翻译为内存访问指令。指针的类型决定了如何解释这些内存地址中的数据。</p>
</li>
<li>
<p><strong>内存对齐</strong>：编译器根据类型的大小和对齐要求来管理内存布局。例如，数组的每个元素在内存中是如何排列的，取决于编译器如何根据类型信息对内存进行对齐。</p>
</li>
</ul>
<h4 id="类型转换与强制类型转换"><a class="header" href="#类型转换与强制类型转换">类型转换与强制类型转换</a></h4>
<p>类型系统通过显式和隐式的类型转换确保内存数据的正确解释。编译器负责在必要时插入适当的转换指令。强制类型转换可能会带来潜在的错误，例如将一个较大的数据类型转换为较小的数据类型时，可能会丢失信息。</p>
<h3 id="4-类型系统对编译器优化的影响"><a class="header" href="#4-类型系统对编译器优化的影响">4. <strong>类型系统对编译器优化的影响</strong></a></h3>
<p>类型系统不仅仅用于捕捉编译期错误，还为编译器提供了许多优化机会。</p>
<h4 id="常量传播与折叠"><a class="header" href="#常量传播与折叠">常量传播与折叠</a></h4>
<p>如果编译器能够确定某些变量的类型及其值，它就可以在编译时直接替换这些值。这被称为<strong>常量传播</strong>。</p>
<pre><code class="language-c">int square(int x) {
    return x * x;
}

int result = square(4);  // 编译器可以将此转换为 result = 16;
</code></pre>
<h4 id="内联扩展与去除虚函数调用"><a class="header" href="#内联扩展与去除虚函数调用">内联扩展与去除虚函数调用</a></h4>
<p>在静态类型语言中，编译器可以根据类型信息内联函数调用，减少运行时开销。在子类型多态性中，如果类型是已知的，编译器可以优化掉虚函数表的查找过程。</p>
<h4 id="数据布局与缓存优化"><a class="header" href="#数据布局与缓存优化">数据布局与缓存优化</a></h4>
<p>编译器可以根据类型的大小和访问模式对内存布局进行优化。例如，将结构体的字段重新排列以减少缓存未命中或减少内存占用。</p>
<h3 id="5-未来方向类型系统与形式验证"><a class="header" href="#5-未来方向类型系统与形式验证">5. <strong>未来方向：类型系统与形式验证</strong></a></h3>
<p>随着类型系统的不断发展，一些现代编程语言已经将<strong>形式验证</strong>引入类型系统中。例如，Rust 的类型系统通过“借用检查器”来确保内存安全，避免数据竞争和悬空指针。</p>
<ul>
<li>
<p><strong>Rust 的所有权系统</strong>：Rust 的所有权和生命周期系统是其类型系统的重要组成部分，能够在编译时确保内存安全，无需垃圾回收机制。</p>
</li>
<li>
<p><strong>形式验证工具</strong>：一些语言（如 Idris 和 Agda）利用依赖类型将形式验证和编程语言类型系统结合，使得程序员可以通过类型系统证明程序的某些性质。</p>
</li>
</ul>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<p>类型系统是编程语言的基础，它定义了如何组织和操作数据。在编译时，类型系统通过限制变量的使用和内存布局，提高代码的安全性和性能。同时，复杂类型在编译器中被“打平”成底层的内存地址和指令操作。</p>
<p>随着编程语言的发展，类型系统越来越强大，类型推断、泛型、依赖类型等特性使得编写高性能、类型安全的代码变得更加容易。在未来，类型系统有望进一步与形式验证、内存管理和编译器优化深度结合，为程序员提供更高效、更安全的编程工具。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_4/one_source和static函数.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_5/语法分析.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_4/one_source和static函数.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_5/语法分析.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
