<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TinyCC源码分析</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">第一章</li><li class="chapter-item expanded "><a href="chapter_1/section_1_1.html">1.1 tinycc项目介绍</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1_2.html">1.2 autoconf的使用</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1_3.html">1.3 config.mak的用法</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1_4.html">1.4 config.mak如何使用？</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1_5.html">1.5 构建调试环境</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1_6.html">1.6 入口代码</a></li><li class="chapter-item expanded affix "><li class="part-title">第二章</li><li class="chapter-item expanded "><a href="chapter_2/main函数的argc和argv.html">2.1 main 函数的 argc 和 argv</a></li><li class="chapter-item expanded "><a href="chapter_2/static的用法.html">2.2 static的用法</a></li><li class="chapter-item expanded "><a href="chapter_2/ppfp变量的作用.html">2.3 ppfp 变量的作用</a></li><li class="chapter-item expanded "><a href="chapter_2/C语言中的枚举的用法.html">2.4 C 语言中的枚举的用法</a></li><li class="chapter-item expanded "><a href="chapter_2/输出文件的类型定义.html">2.5 输出文件的类型定义</a></li><li class="chapter-item expanded "><a href="chapter_2/什么是目标文件.html">2.6 什么是目标文件</a></li><li class="chapter-item expanded "><a href="chapter_2/exe和dll文件的区别.html">2.7 exe和 dll 文件的区别</a></li><li class="chapter-item expanded "><a href="chapter_2/c语言中预处理文件.html">2.8 c语言中预处理文件</a></li><li class="chapter-item expanded "><a href="chapter_2/类型的前置声明.html">2.9 类型的前置声明</a></li><li class="chapter-item expanded "><a href="chapter_2/TCCState.html">2.10 TCCState</a></li><li class="chapter-item expanded "><a href="chapter_2/undefgnu_ext是什么意思.html">2.11 #undef gnu_ext 是什么意思</a></li><li class="chapter-item expanded "><a href="chapter_2/tcc_parse_args命令行参数的解析.html">2.12 tcc_parse_args: 命令行参数的解析</a></li><li class="chapter-item expanded "><a href="chapter_2/set_environment.html">2.13 set_environment</a></li><li class="chapter-item expanded affix "><li class="part-title">第三章</li><li class="chapter-item expanded "><a href="chapter_3/编译的整体流程.html">编译的整体流程</a></li><li class="chapter-item expanded "><a href="chapter_3/ST_FUNC的用法.html">ST_FUNC的用法</a></li><li class="chapter-item expanded "><a href="chapter_3/CString.html">CString</a></li><li class="chapter-item expanded "><a href="chapter_3/tcc_compile.html">tcc_compile</a></li><li class="chapter-item expanded "><a href="chapter_3/tcc_enter_state.html">tcc_enter_state</a></li><li class="chapter-item expanded "><a href="chapter_3/preprocess_start.html">preprocess_start</a></li><li class="chapter-item expanded "><a href="chapter_3/file.html">file</a></li><li class="chapter-item expanded "><a href="chapter_3/tccgen_init.html">tccgen_init</a></li><li class="chapter-item expanded "><a href="chapter_3/next.html">next</a></li><li class="chapter-item expanded "><a href="chapter_3/decl.html">decl</a></li><li class="chapter-item expanded affix "><li class="part-title">第四章</li><li class="chapter-item expanded "><a href="chapter_4/token-values.html">token values</a></li><li class="chapter-item expanded "><a href="chapter_4/next_nomacro.html">next_nomacro</a></li><li class="chapter-item expanded "><a href="chapter_4/define_find.html">define_find</a></li><li class="chapter-item expanded "><a href="chapter_4/table_ident.html">table_ident</a></li><li class="chapter-item expanded "><a href="chapter_4/current_value_type.html">current_value_type</a></li><li class="chapter-item expanded "><a href="chapter_4/scope.html">scope</a></li><li class="chapter-item expanded "><a href="chapter_4/filespec.html">filespec</a></li><li class="chapter-item expanded "><a href="chapter_4/include_ifdef_stack.html">include_ifdef_stack</a></li><li class="chapter-item expanded affix "><li class="part-title">第五章</li><li class="chapter-item expanded "><a href="chapter_5/语法分析.html">第五章 语法分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第六章</li><li class="chapter-item expanded "><a href="chapter_6/语义分析.html">第六章 语义分析</a></li><li class="chapter-item expanded affix "><li class="part-title">第七章</li><li class="chapter-item expanded "><a href="chapter_7/gen_function.html">gen_function</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TinyCC源码分析</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<h2 id="作者信息"><a class="header" href="#作者信息">作者信息</a></h2>
<ul>
<li><strong>作者</strong>: 乐乐宝宝</li>
<li><strong>电子邮件</strong>: duhbbx@gmail.com</li>
</ul>
<p>不知道引言写啥....</p>
<p>传说计算机有三大浪漫: 操作系统, 编译原理和图形学. 我是对编译原理比较感兴趣,因为工作的原因会涉及到很多编译原理知识的运用.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-tinycc-项目介绍"><a class="header" href="#11-tinycc-项目介绍">1.1 TinyCC 项目介绍</a></h1>
<h2 id="tinycc-项目介绍"><a class="header" href="#tinycc-项目介绍">TinyCC 项目介绍</a></h2>
<p><strong>TinyCC（TCC，全称为 Tiny C Compiler）</strong> 是一个小巧且高效的 C 语言编译器，目标是提供非常快速的编译速度，同时占用极少的系统资源。由 Fabrice Bellard 开发，TinyCC 旨在为 C 语言提供一个高度便携且功能完善的编译器。</p>
<h3 id="项目特点"><a class="header" href="#项目特点">项目特点</a></h3>
<ol>
<li>
<p><strong>极快的编译速度</strong>：
TinyCC 的最大特点之一是其超快的编译速度，通常比传统的编译器如 GCC 和 Clang 快 9 倍到 10 倍。这使得它非常适合在开发、测试或嵌入式系统中使用。</p>
</li>
<li>
<p><strong>极小的二进制文件</strong>：
TinyCC 是一个极小的编译器，整个编译器的代码量非常小，并且编译生成的可执行文件非常小巧，适合资源受限的系统或嵌入式设备。</p>
</li>
<li>
<p><strong>C99 标准兼容性</strong>：
TinyCC 支持大多数 C99 标准的特性，允许开发者使用现代 C 标准进行编程。</p>
</li>
<li>
<p><strong>即时编译（JIT）功能</strong>：
TinyCC 支持即时编译（Just-In-Time Compilation），可以在运行时动态编译和执行 C 代码。这使得它适用于需要动态生成和执行代码的场景。</p>
</li>
<li>
<p><strong>内存安全检查</strong>：
TinyCC 提供可选的内存安全检查模式，可以检测一些常见的运行时错误，如数组越界访问和非法指针操作。</p>
</li>
<li>
<p><strong>多平台支持</strong>：
TinyCC 支持多种操作系统和硬件架构，包括：</p>
<ul>
<li>Linux、Windows 和 macOS</li>
<li>x86、x86_64、ARM、ARM64、RISC-V 等架构</li>
</ul>
</li>
<li>
<p><strong>静态和动态库支持</strong>：
TinyCC 支持生成静态库（<code>.a</code>）和动态库（<code>.so</code> 或 <code>.dll</code>），可以方便地集成到其他项目中。</p>
</li>
</ol>
<h3 id="核心功能"><a class="header" href="#核心功能">核心功能</a></h3>
<ol>
<li>
<p><strong>完整的 C 编译器</strong>：
虽然 TinyCC 的代码量很小，但它是一个功能完善的 C 编译器，支持常见的 C 语言特性，如预处理器、数据类型、控制结构、函数等。</p>
</li>
<li>
<p><strong>编译优化</strong>：
尽管 TinyCC 的目标是快速编译，但它也提供了基础的优化功能，以生成高效的代码。</p>
</li>
<li>
<p><strong>内嵌汇编</strong>：
TinyCC 支持内嵌汇编代码，允许开发者在 C 代码中直接使用汇编指令。</p>
</li>
<li>
<p><strong>动态链接库支持</strong>：
TinyCC 可以生成和链接动态库，适用于需要模块化设计的程序。</p>
</li>
<li>
<p><strong>轻量级</strong>：
TinyCC 的二进制文件非常小，编译出来的可执行文件也极其紧凑，非常适合嵌入式开发和低资源环境。</p>
</li>
</ol>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<ol>
<li>
<p><strong>嵌入式开发</strong>：
TinyCC 的小内存占用和生成小巧的二进制文件，使其特别适合资源受限的嵌入式设备。</p>
</li>
<li>
<p><strong>教学与学习</strong>：
TinyCC 的设计简单易懂，适合学习 C 编译器的内部工作原理，或者作为教学工具来教授编译原理和 C 语言。</p>
</li>
<li>
<p><strong>快速开发与原型设计</strong>：
TinyCC 的即时编译功能和快速的编译速度非常适合进行快速的原型设计，开发者可以快速编译和测试 C 代码。</p>
</li>
<li>
<p><strong>动态代码生成</strong>：
TinyCC 提供了 JIT 编译功能，适用于需要动态生成和执行代码的场景，如脚本引擎或游戏引擎。</p>
</li>
</ol>
<h3 id="安装与使用"><a class="header" href="#安装与使用">安装与使用</a></h3>
<p>TinyCC 支持在 Linux、Windows 和 macOS 等平台上运行，安装步骤如下：</p>
<ol>
<li>
<p><strong>获取源码</strong>：
可以从 TinyCC 的官方 GitHub 仓库获取源码：</p>
<pre><code class="language-bash">git clone https://github.com/TinyCC/tinycc.git
</code></pre>
</li>
<li>
<p><strong>编译并安装</strong>：</p>
<pre><code class="language-bash">cd tinycc
./configure
make
sudo make install
</code></pre>
</li>
<li>
<p><strong>使用 TinyCC 编译 C 程序</strong>：</p>
<p>编译和运行一个简单的 C 程序：</p>
<pre><code class="language-bash">tcc -o hello hello.c
./hello
</code></pre>
</li>
</ol>
<h3 id="项目历史"><a class="header" href="#项目历史">项目历史</a></h3>
<p>TinyCC 由 Fabrice Bellard 于 2001 年首次发布，目的是为了提供一个极小且快速的 C 编译器。它以其独特的即时编译功能和内存安全性检查功能著称，并且其开源的代码使得它成为学习编译器设计的绝佳案例。</p>
<h3 id="项目优势和不足"><a class="header" href="#项目优势和不足">项目优势和不足</a></h3>
<ul>
<li>
<p><strong>优势</strong>：</p>
<ul>
<li>极快的编译速度</li>
<li>小巧的二进制文件</li>
<li>支持 C99 标准</li>
<li>JIT 支持</li>
<li>多平台兼容</li>
</ul>
</li>
<li>
<p><strong>不足</strong>：</p>
<ul>
<li>优化能力不如 GCC 或 Clang 等主流编译器</li>
<li>一些高级 C 语言特性支持有限</li>
<li>不适合大规模项目的生产环境</li>
</ul>
</li>
</ul>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<p>TinyCC 是一个非常适合嵌入式开发、学习编译器工作原理、快速原型设计的轻量级 C 编译器。尽管它的优化能力和高级功能不如主流编译器，但凭借其极快的编译速度和小巧的体积，TinyCC 在某些特定场景下仍然非常有用。</p>
<h3 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h3>
<ul>
<li><strong>项目主页</strong>: <a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a></li>
<li><strong>GitHub 仓库</strong>: <a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a></li>
<li><strong>文档</strong>: <a href="https://bellard.org/tcc/tcc-doc.html">https://bellard.org/tcc/tcc-doc.html</a></li>
</ul>
<p>TinyCC 是一款轻量但功能强大的 C 编译器，适合在资源有限或需要快速编译的场景中使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-autoconf的使用"><a class="header" href="#12-autoconf的使用">1.2 autoconf的使用</a></h1>
<p><code>autoconf</code> 是一个自动化工具，用于生成能够自动配置源代码的 <code>configure</code> 脚本。它是 GNU 构建系统的一部分，通常与 <code>automake</code> 和 <code>autoconf</code> 一起使用，用于自动生成配置脚本，使源代码能够在不同平台和系统中编译和安装。</p>
<h2 id="autoconf-的基本使用步骤"><a class="header" href="#autoconf-的基本使用步骤"><code>autoconf</code> 的基本使用步骤</a></h2>
<p><code>autoconf</code> 的主要目的是自动检测系统的环境和依赖，以便生成适用于当前系统的 <code>Makefile</code>。通常用于大型项目，帮助开发者简化跨平台编译过程。</p>
<h2 id="常见的-autoconf-使用步骤"><a class="header" href="#常见的-autoconf-使用步骤">常见的 <code>autoconf</code> 使用步骤</a></h2>
<h3 id="1-创建-configureac-文件"><a class="header" href="#1-创建-configureac-文件">1. 创建 <code>configure.ac</code> 文件</a></h3>
<p><code>configure.ac</code> 文件是 <code>autoconf</code> 使用的输入文件，包含配置脚本生成所需的各种检查和宏。你需要在项目根目录下创建一个 <code>configure.ac</code> 文件来描述项目。</p>
<p>以下是一个简单的 <code>configure.ac</code> 文件示例：</p>
<pre><code class="language-bash"># 初始化并设置项目名称、版本号和目标主机
AC_INIT([my_program], [1.0], [me@example.com])

# 检查 C 编译器是否存在
AC_PROG_CC

# 设置输出的 Makefile
AC_CONFIG_FILES([Makefile])

# 结束配置文件
AC_OUTPUT
</code></pre>
<h3 id="2-创建-makefileam"><a class="header" href="#2-创建-makefileam">2. 创建 <code>Makefile.am</code></a></h3>
<p><code>Makefile.am</code> 是 <code>automake</code> 使用的文件，描述了需要编译和链接的源文件。你可以在项目根目录下创建一个简单的 <code>Makefile.am</code> 文件：</p>
<pre><code class="language-bash">bin_PROGRAMS = my_program      # 要编译的可执行文件
my_program_SOURCES = main.c    # 源文件列表
</code></pre>
<h3 id="3-生成-configure-脚本"><a class="header" href="#3-生成-configure-脚本">3. 生成 <code>configure</code> 脚本</a></h3>
<p>在创建完 <code>configure.ac</code> 和 <code>Makefile.am</code> 之后，运行以下命令来生成 <code>configure</code> 脚本和其他需要的构建文件：</p>
<pre><code class="language-bash">autoreconf --install
</code></pre>
<p>这会生成一个 <code>configure</code> 脚本，该脚本可以在不同的系统中运行，自动配置和生成 <code>Makefile</code>。</p>
<h3 id="4-运行-configure"><a class="header" href="#4-运行-configure">4. 运行 <code>configure</code></a></h3>
<p>生成 <code>configure</code> 脚本后，你可以运行它来检查系统环境并生成 <code>Makefile</code>：</p>
<pre><code class="language-bash">./configure
</code></pre>
<p>运行 <code>configure</code> 后，它会检测系统的编译器、库、头文件等依赖，并根据这些信息生成适用于当前系统的 <code>Makefile</code>。</p>
<h3 id="5-编译项目"><a class="header" href="#5-编译项目">5. 编译项目</a></h3>
<p>当 <code>Makefile</code> 生成之后，你可以像通常使用 <code>make</code> 一样编译项目：</p>
<pre><code class="language-bash">make
</code></pre>
<h3 id="6-安装项目"><a class="header" href="#6-安装项目">6. 安装项目</a></h3>
<p>编译完成后，可以使用以下命令将生成的可执行文件或库安装到系统指定目录（例如 <code>/usr/local/bin</code>）：</p>
<pre><code class="language-bash">sudo make install
</code></pre>
<h3 id="7-清理构建文件"><a class="header" href="#7-清理构建文件">7. 清理构建文件</a></h3>
<p>如果需要清理构建过程中生成的中间文件，可以使用以下命令：</p>
<pre><code class="language-bash">make clean
</code></pre>
<h2 id="示例一个完整的-autoconf-项目"><a class="header" href="#示例一个完整的-autoconf-项目">示例：一个完整的 <code>autoconf</code> 项目</a></h2>
<p>以下是一个使用 <code>autoconf</code> 的简单 C 项目结构示例。</p>
<h3 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h3>
<pre><code class="language-plaintext">my_project/
├── configure.ac
├── Makefile.am
├── src/
│   ├── Makefile.am
│   └── main.c
</code></pre>
<h3 id="configureac-内容"><a class="header" href="#configureac-内容"><code>configure.ac</code> 内容</a></h3>
<pre><code class="language-bash">AC_INIT([my_program], [1.0], [me@example.com])
AC_CONFIG_SRCDIR([src/main.c])
AC_CONFIG_HEADERS([config.h])
AM_INIT_AUTOMAKE
AC_PROG_CC
AC_CONFIG_FILES([Makefile src/Makefile])
AC_OUTPUT
</code></pre>
<h3 id="makefileam-内容项目根目录"><a class="header" href="#makefileam-内容项目根目录"><code>Makefile.am</code> 内容（项目根目录）</a></h3>
<pre><code class="language-bash">SUBDIRS = src
</code></pre>
<h3 id="makefileam-内容src-目录"><a class="header" href="#makefileam-内容src-目录"><code>Makefile.am</code> 内容（<code>src/</code> 目录）</a></h3>
<pre><code class="language-bash">bin_PROGRAMS = my_program
my_program_SOURCES = main.c
</code></pre>
<h3 id="mainc-内容"><a class="header" href="#mainc-内容"><code>main.c</code> 内容</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, Autoconf!\n");
    return 0;
}
</code></pre>
<h3 id="使用流程"><a class="header" href="#使用流程">使用流程</a></h3>
<ol>
<li>
<p><strong>生成 <code>configure</code> 脚本</strong>：
在项目根目录下运行：</p>
<pre><code class="language-bash">autoreconf --install
</code></pre>
</li>
<li>
<p><strong>配置项目</strong>：
运行生成的 <code>configure</code> 脚本：</p>
<pre><code class="language-bash">./configure
</code></pre>
</li>
<li>
<p><strong>编译项目</strong>：
配置完成后，运行 <code>make</code> 编译：</p>
<pre><code class="language-bash">make
</code></pre>
</li>
<li>
<p><strong>运行程序</strong>：
你可以在 <code>src/</code> 目录下找到生成的可执行文件 <code>my_program</code>，并运行它：</p>
<pre><code class="language-bash">./src/my_program
</code></pre>
</li>
<li>
<p><strong>安装程序</strong>：
将编译好的程序安装到系统目录：</p>
<pre><code class="language-bash">sudo make install
</code></pre>
</li>
</ol>
<h2 id="其他常用的宏"><a class="header" href="#其他常用的宏">其他常用的宏</a></h2>
<ul>
<li><strong>AC_PROG_CC</strong>：检测 C 编译器。</li>
<li><strong>AC_CHECK_LIB([library], [function])</strong>：检测某个库是否存在。</li>
<li><strong>AC_CHECK_HEADERS([header1 header2])</strong>：检测是否存在头文件。</li>
<li><strong>AC_CONFIG_FILES([file1 file2])</strong>：指定要生成的 <code>Makefile</code> 列表。</li>
</ul>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><code>autoconf</code> 是一个强大的工具，用于自动生成可移植的配置脚本，使源代码可以在不同平台上编译。典型的流程是通过编写 <code>configure.ac</code> 文件定义项目的配置要求，然后生成 <code>configure</code> 脚本，用户可以运行该脚本生成适合目标系统的 <code>Makefile</code>，并进行编译和安装。</p>
<p>通过 <code>autoconf</code>，开发者可以简化跨平台构建的过程，确保项目在各种环境中都能正确编译。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-configmak的用法"><a class="header" href="#13-configmak的用法">1.3 config.mak的用法</a></h1>
<p><code>config.mak</code> 是许多使用 <code>make</code> 的项目中常见的配置文件，特别是在那些采用自定义构建系统或者使用 GNU Autotools 工具链（如 <code>autoconf</code>、<code>automake</code>）的项目中。<code>config.mak</code> 文件通常用于覆盖 <code>Makefile</code> 中的默认设置，提供项目构建的灵活性。它允许开发人员根据系统的具体情况或个人需求调整编译选项、库路径等。</p>
<h2 id="configmak-的用途"><a class="header" href="#configmak-的用途"><code>config.mak</code> 的用途</a></h2>
<ul>
<li><strong>编译器选项</strong>：指定编译器、编译选项（如 <code>CFLAGS</code>、<code>LDFLAGS</code> 等）。</li>
<li><strong>库路径</strong>：设置库文件的路径和库的链接选项（如 <code>LIBS</code>）。</li>
<li><strong>启用或禁用功能</strong>：定义条件编译的宏，控制项目的功能模块是否开启。</li>
<li><strong>自定义变量</strong>：覆盖 <code>Makefile</code> 中定义的变量，便于灵活配置。</li>
</ul>
<h2 id="configmak-如何使用"><a class="header" href="#configmak-如何使用"><code>config.mak</code> 如何使用？</a></h2>
<p>在项目构建中，<code>config.mak</code> 文件通常由 <code>Makefile</code> 引用。<code>Makefile</code> 会包含或检查是否存在 <code>config.mak</code>，然后使用其中的设置。例如：</p>
<pre><code class="language-makefile"># Makefile
# 加载 config.mak，如果存在
-include config.mak

# 编译器和编译标志
CC = gcc
CFLAGS = -Wall -O2

# 如果在 config.mak 中有定义，会覆盖 Makefile 中的这些变量
</code></pre>
<h2 id="configmak-的常见配置项"><a class="header" href="#configmak-的常见配置项"><code>config.mak</code> 的常见配置项</a></h2>
<p><code>config.mak</code> 文件的格式与 <code>Makefile</code> 相同，使用简单的变量赋值语法来定义编译器、链接器的选项，以及库路径等。以下是一些常见的配置选项：</p>
<ol>
<li>
<p><strong>编译器选项</strong>：</p>
<ul>
<li><strong>CC</strong>：指定 C 编译器。</li>
<li><strong>CXX</strong>：指定 C++ 编译器。</li>
<li><strong>CFLAGS</strong>：C 编译器的标志，用于指定优化级别、调试信息等。</li>
<li><strong>CXXFLAGS</strong>：C++ 编译器的标志，类似于 <code>CFLAGS</code>。</li>
<li><strong>LDFLAGS</strong>：链接器标志，指定库的路径、链接时使用的标志等。</li>
<li><strong>CPPFLAGS</strong>：C 预处理器的标志，用于添加头文件路径或定义预处理器宏。</li>
</ul>
<p>示例：</p>
<pre><code class="language-makefile">CC = clang
CFLAGS = -Wall -O3 -g
CXXFLAGS = -std=c++11
LDFLAGS = -L/usr/local/lib
CPPFLAGS = -I/usr/local/include
</code></pre>
</li>
<li>
<p><strong>库链接选项</strong>：</p>
<ul>
<li><strong>LIBS</strong>：要链接的库，通常用于指定额外的库文件（如 <code>-lm</code> 链接数学库）。</li>
<li><strong>LDLIBS</strong>：类似于 <code>LIBS</code>，可以链接动态库或静态库。</li>
</ul>
<p>示例：</p>
<pre><code class="language-makefile">LIBS = -lm -lpthread
</code></pre>
</li>
<li>
<p><strong>目标平台和架构</strong>：</p>
<ul>
<li><strong>ARCH</strong>：目标平台的架构类型，如 <code>x86_64</code>、<code>arm</code>、<code>i386</code> 等。</li>
<li><strong>HOST</strong>：目标主机系统类型，常用于交叉编译。</li>
</ul>
<p>示例：</p>
<pre><code class="language-makefile">ARCH = x86_64
HOST = arm-linux-gnueabihf
</code></pre>
</li>
<li>
<p><strong>调试和优化</strong>：</p>
<ul>
<li><strong>DEBUG</strong>：启用或禁用调试信息，通常通过 <code>-g</code> 标志来生成调试符号。</li>
<li><strong>OPTIMIZE</strong>：控制优化级别，如 <code>-O2</code>、<code>-O3</code>。</li>
</ul>
<p>示例：</p>
<pre><code class="language-makefile">DEBUG = -g
OPTIMIZE = -O2
</code></pre>
</li>
<li>
<p><strong>启用或禁用特定功能</strong>：</p>
<ul>
<li><strong>ENABLE_FEATURE_X</strong>：通过定义宏，控制代码中某些模块的启用或禁用，通常配合条件编译。</li>
<li><strong>DISABLE_SOMETHING</strong>：禁用某些功能。</li>
</ul>
<p>示例：</p>
<pre><code class="language-makefile">ENABLE_FEATURE_X = 1
DISABLE_SOMETHING = 0
</code></pre>
</li>
</ol>
<h2 id="configmak-的实际用法示例"><a class="header" href="#configmak-的实际用法示例"><code>config.mak</code> 的实际用法示例</a></h2>
<p>假设你正在构建一个项目，项目需要根据不同平台或需求进行配置，而不想每次都手动修改 <code>Makefile</code>。你可以使用 <code>config.mak</code> 来实现不同的配置。</p>
<h3 id="示例-1基本的-configmak-配置"><a class="header" href="#示例-1基本的-configmak-配置">示例 1：基本的 <code>config.mak</code> 配置</a></h3>
<pre><code class="language-makefile"># config.mak
CC = gcc
CFLAGS = -Wall -O2 -g
LDFLAGS = -L/usr/local/lib
LIBS = -lm -lpthread
</code></pre>
<h3 id="示例-2条件编译"><a class="header" href="#示例-2条件编译">示例 2：条件编译</a></h3>
<p>通过 <code>config.mak</code> 文件控制特定功能是否启用：</p>
<pre><code class="language-makefile"># config.mak
ENABLE_DEBUG = 1
ENABLE_FEATURE_X = 0
</code></pre>
<p>在 <code>Makefile</code> 中使用这些变量：</p>
<pre><code class="language-makefile"># Makefile
-include config.mak

CFLAGS = -Wall -O2

# 如果启用了调试模式
ifeq ($(ENABLE_DEBUG), 1)
CFLAGS += -g
endif

# 如果启用了某个特性
ifeq ($(ENABLE_FEATURE_X), 1)
CFLAGS += -DENABLE_FEATURE_X
endif
</code></pre>
<h3 id="示例-3交叉编译配置"><a class="header" href="#示例-3交叉编译配置">示例 3：交叉编译配置</a></h3>
<p>你可以通过 <code>config.mak</code> 来指定不同平台的编译工具链和路径，这对于交叉编译非常有用。</p>
<pre><code class="language-makefile"># config.mak
CC = arm-linux-gnueabi-gcc
CFLAGS = -Wall -O2
LDFLAGS = -L/opt/arm/lib
</code></pre>
<h2 id="如何生成-configmak-文件"><a class="header" href="#如何生成-configmak-文件">如何生成 <code>config.mak</code> 文件？</a></h2>
<p>通常，<code>config.mak</code> 文件可以是手动编写的，或者由项目的 <code>configure</code> 脚本自动生成。开发者可以根据项目需求，提前提供一个模板或者样例文件，用户可以复制并根据自己的系统情况修改。</p>
<p>例如，某些项目可能提供一个 <code>config.mak.sample</code> 文件，用户可以将其复制并命名为 <code>config.mak</code>，然后根据需要进行修改。</p>
<pre><code class="language-bash">cp config.mak.sample config.mak
</code></pre>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<ul>
<li><code>config.mak</code> 文件用于覆盖项目 <code>Makefile</code> 中的默认设置，提供了编译器、库路径、功能启用和禁用等选项的灵活配置。</li>
<li>典型的 <code>config.mak</code> 用法包括定义编译选项（如 <code>CFLAGS</code>、<code>LDFLAGS</code>）、库路径、目标平台、调试选项以及条件编译的宏。</li>
<li><code>Makefile</code> 通常会通过 <code>-include config.mak</code> 加载 <code>config.mak</code> 文件，允许用户根据自己的需求修改编译选项，而无需直接修改 <code>Makefile</code>。</li>
<li><code>config.mak</code> 是项目灵活构建的关键部分，特别适合跨平台、不同环境的配置管理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-configmak如何使用"><a class="header" href="#14-configmak如何使用">1.4 config.mak如何使用？</a></h1>
<p>这段代码使用了 <code>make</code> 的条件判断和字符串查找功能，来决定是否包含外部的 <code>config.mak</code> 文件。让我们一步步分析每个部分的作用：</p>
<pre><code class="language-makefile">ifeq ($(findstring $(MAKECMDGOALS),clean distclean),)
    include $(TOP)/config.mak
endif
</code></pre>
<h2 id="代码详细分析"><a class="header" href="#代码详细分析">代码详细分析</a></h2>
<h3 id="1-makecmdgoals"><a class="header" href="#1-makecmdgoals">1. <code>$(MAKECMDGOALS)</code></a></h3>
<ul>
<li>
<p><code>$(MAKECMDGOALS)</code> 是一个 <code>make</code> 的特殊变量，包含了用户在命令行上指定的目标。例如，如果用户执行了 <code>make clean</code>，则 <code>$(MAKECMDGOALS)</code> 的值为 <code>clean</code>。</p>
</li>
<li>
<p>这个变量可以包含多个目标，例如执行 <code>make clean all</code>，那么 <code>$(MAKECMDGOALS)</code> 的值为 <code>clean all</code>。</p>
</li>
</ul>
<h3 id="2-findstring-makecmdgoalsclean-distclean"><a class="header" href="#2-findstring-makecmdgoalsclean-distclean">2. <code>$(findstring $(MAKECMDGOALS),clean distclean)</code></a></h3>
<ul>
<li>
<p><code>$(findstring)</code> 是 <code>make</code> 内置的字符串查找函数。它的格式为：</p>
<pre><code class="language-makefile">$(findstring &lt;string1&gt;, &lt;string2&gt;)
</code></pre>
<p>它在 <code>&lt;string2&gt;</code> 中查找 <code>&lt;string1&gt;</code>，如果找到了就返回 <code>&lt;string1&gt;</code>，否则返回空字符串。</p>
</li>
<li>
<p>在这一行中，它的含义是：在 <code>$(MAKECMDGOALS)</code> 中查找是否有 <code>clean</code> 或 <code>distclean</code>。<code>clean distclean</code> 是第二个参数，它是用空格分隔的两个目标。</p>
</li>
<li>
<p>也就是说，<code>$(findstring $(MAKECMDGOALS),clean distclean)</code> 会检查当前的目标列表中是否包含 <code>clean</code> 或 <code>distclean</code> 这两个目标。如果包含，则返回找到的目标；如果不包含，则返回空字符串。</p>
</li>
</ul>
<h3 id="3-ifeq-findstring-makecmdgoalsclean-distclean"><a class="header" href="#3-ifeq-findstring-makecmdgoalsclean-distclean">3. <code>ifeq ($(findstring $(MAKECMDGOALS),clean distclean),)</code></a></h3>
<ul>
<li>
<p><code>ifeq</code> 是 <code>make</code> 的条件语句，用来判断两个值是否相等。</p>
</li>
<li>
<p>在这一行中，判断的是 <code>$(findstring $(MAKECMDGOALS),clean distclean)</code> 的返回值是否为空字符串。换句话说，如果 <code>$(MAKECMDGOALS)</code> 不包含 <code>clean</code> 或 <code>distclean</code>，这个条件将为 <code>true</code>。</p>
</li>
</ul>
<h3 id="4-include-topconfigmak"><a class="header" href="#4-include-topconfigmak">4. <code>include $(TOP)/config.mak</code></a></h3>
<ul>
<li>
<p><code>include</code> 用于包含其他文件的内容。在这里，如果条件为真（即目标不是 <code>clean</code> 或 <code>distclean</code>），则会包含 <code>$(TOP)/config.mak</code> 文件。</p>
</li>
<li>
<p><code>$(TOP)</code> 变量通常是在 <code>Makefile</code> 中定义的根目录路径变量，用于定位 <code>config.mak</code> 文件。假设 <code>$(TOP)</code> 的值是项目的根目录，那么这行代码就会包含项目根目录下的 <code>config.mak</code> 文件。</p>
</li>
</ul>
<h3 id="5-endif"><a class="header" href="#5-endif">5. <code>endif</code></a></h3>
<ul>
<li><code>endif</code> 用来结束 <code>ifeq</code> 条件块。</li>
</ul>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>这段代码的主要作用是：</p>
<ul>
<li>
<p><strong>在用户没有执行 <code>clean</code> 或 <code>distclean</code> 目标时</strong>，包含 <code>config.mak</code> 文件。</p>
</li>
<li>
<p>反之，<strong>如果用户执行了 <code>make clean</code> 或 <code>make distclean</code>，则不会包含 <code>config.mak</code></strong> 文件。</p>
</li>
</ul>
<h2 id="目的"><a class="header" href="#目的">目的</a></h2>
<ul>
<li>
<p><code>clean</code> 和 <code>distclean</code> 目标通常用于删除构建过程中生成的文件。这时，可能不需要 <code>config.mak</code> 文件中的配置项（例如编译器选项、库路径等），因为这些目标只需要删除文件，而不需要实际编译代码。</p>
</li>
<li>
<p>通过这种方式，可以避免在执行 <code>clean</code> 或 <code>distclean</code> 时加载不必要的配置文件，简化构建过程，并提高执行效率。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-构建调试环境"><a class="header" href="#15-构建调试环境">1.5 构建调试环境</a></h1>
<p>在 .vscode 下建两个 json 配置文件</p>
<h2 id="launchjson"><a class="header" href="#launchjson">launch.json</a></h2>
<pre><code class="language-json">{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(lldb) Launch",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceFolder}/tcc", // 替换为你的可执行文件路径
            "args": ["a.c", "-o", "a.out"],
            "cwd": "${workspaceFolder}",
            "preLaunchTask": "build with tcc",  // 用于编译任务
        }
    ]
}
</code></pre>
<h2 id="tasksjson"><a class="header" href="#tasksjson">tasks.json</a></h2>
<pre><code class="language-json">{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "build with tcc",
            "command": "/usr/bin/make",
            "args": [],
            "options": {
                "cwd": "${workspaceFolder}"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}

</code></pre>
<h2 id="调整-configmak-的配置"><a class="header" href="#调整-configmak-的配置">调整 config.mak 的配置</a></h2>
<pre><code>CFLAGS=-Wall -O0 -g -Wdeclaration-after-statement -fno-strict-aliasing -fheinous-gnu-extensions -Wno-pointer-sign -Wno-sign-compare -Wno-unused-result -Wno-string-plus-int -Wno-deprecated-declarations
</code></pre>
<h2 id="构建-tinycc"><a class="header" href="#构建-tinycc">构建 tinycc</a></h2>
<pre><code class="language-bash">./configure
make
make test
make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-入口代码"><a class="header" href="#16-入口代码">1.6 入口代码</a></h1>
<p>代码的入口就是项目根目录下的 tcc.c 文件中。整个 <code>main</code> 函数比较短，比较清晰。</p>
<pre><code class="language-c">int main(int argc0, char **argv0)
{
    /* TCCState 是啥? */
    TCCState *s, *s1;
    int ret, opt, n = 0, t = 0, done;
    unsigned start_time = 0, end_time = 0;
    const char *first_file;
    int argc; char **argv;
    FILE *ppfp = stdout;  printf("ppfp 是啥,为什么取这个名字: ppfp 是指向 stdcout 的文件指针\n");

redo: /* 使用了 label, why */
    argc = argc0, argv = argv0;
    s = s1 = tcc_new();  printf("#### tcc state 的状态使用 tcc_new() &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \n");
#ifdef CONFIG_TCC_SWITCHES /* predefined options */
    tcc_set_options(s, CONFIG_TCC_SWITCHES);   printf("#### tcc_set_options, 这个 options 是什么呢?\n");
#endif
    opt = tcc_parse_args(s, &amp;argc, &amp;argv, 1);  printf("#### 解析 tcc 的参数 tcc_parse_args \n");
    if (opt &lt; 0)
        return 1;

    if (n == 0) {
        if (opt == OPT_HELP) {
            fputs(help, stdout);
            if (!s-&gt;verbose)
                return 0;
            ++opt;
        }
        if (opt == OPT_HELP2) {
            fputs(help2, stdout);
            return 0;
        }
        if (opt == OPT_M32 || opt == OPT_M64)
            return tcc_tool_cross(s, argv, opt);
        if (s-&gt;verbose)
            printf("%s", version);
        if (opt == OPT_AR)
            return tcc_tool_ar(s, argc, argv);
#ifdef TCC_TARGET_PE
        if (opt == OPT_IMPDEF)
            return tcc_tool_impdef(s, argc, argv);
#endif
        if (opt == OPT_V)
            return 0;
        if (opt == OPT_PRINT_DIRS) {
            /* initialize search dirs */
            set_environment(s);
            tcc_set_output_type(s, TCC_OUTPUT_MEMORY);
            print_search_dirs(s);
            return 0;
        }
        printf("##### 一共有多少个输入文件呢? %d 个\n", s-&gt;nb_files);
        if (s-&gt;nb_files == 0) {
            tcc_error_noabort("no input files");
        } else if (s-&gt;output_type == TCC_OUTPUT_PREPROCESS) { printf("tcc.c 只是进行预处理..................\n");
            if (s-&gt;outfile &amp;&amp; 0!=strcmp("-",s-&gt;outfile)) {
                ppfp = fopen(s-&gt;outfile, "wb");
                if (!ppfp)
                    tcc_error_noabort("could not write '%s'", s-&gt;outfile);
            }
        } else if (s-&gt;output_type == TCC_OUTPUT_OBJ &amp;&amp; !s-&gt;option_r) { printf("生成的是目标文件................\n");
            if (s-&gt;nb_libraries)
                tcc_error_noabort("cannot specify libraries with -c");
            else if (s-&gt;nb_files &gt; 1 &amp;&amp; s-&gt;outfile) {
                // #define tcc_error_noabort   TCC_SET_STATE(_tcc_error_noabort)
                tcc_error_noabort("cannot specify output file with -c many files");
            }
        }
        if (s-&gt;nb_errors)
            return 1;
        if (s-&gt;do_bench) { printf("有 bench 标识, 准备记录起始时间了");
            start_time = getclock_ms(); }
    }

    set_environment(s);
    if (s-&gt;output_type == 0)
        s-&gt;output_type = TCC_OUTPUT_EXE;
    tcc_set_output_type(s, s-&gt;output_type);
    s-&gt;ppfp = ppfp;

    if ((s-&gt;output_type == TCC_OUTPUT_MEMORY
      || s-&gt;output_type == TCC_OUTPUT_PREPROCESS)
        &amp;&amp; (s-&gt;dflag &amp; 16)) { /* -dt option */
        if (t)
            s-&gt;dflag |= 32;
        s-&gt;run_test = ++t;
        if (n)
            --n;
    }

    /* compile or add each files or library */
    first_file = NULL;
    do {
        struct filespec *f = s-&gt;files[n];
        s-&gt;filetype = f-&gt;type;
        printf("#### 编译单个文件 -&gt; %s\n", f-&gt;name);
        if (f-&gt;type &amp; AFF_TYPE_LIB) { printf("AFF_TYPE_LIB类型......... 使用枚举来判断\n");
            ret = tcc_add_library_err(s, f-&gt;name);
        } else {
            if (1 == s-&gt;verbose)
                printf("-&gt; %s\n", f-&gt;name);
            if (!first_file)        // 为什么要有 first_file 呢?
                first_file = f-&gt;name;
            ret = tcc_add_file(s, f-&gt;name);  printf("tcc_add_file 是干啥的...........\n");
        }
        done = ret || ++n &gt;= s-&gt;nb_files;  printf("判断是否 done了..................\n");
    } while (!done &amp;&amp; (s-&gt;output_type != TCC_OUTPUT_OBJ || s-&gt;option_r));

    if (s-&gt;do_bench) { printf("判断是否是 bench, 如果是的话计算时间");
        end_time = getclock_ms();
    }
        

    if (s-&gt;run_test) {
        t = 0;
    } else if (s-&gt;output_type == TCC_OUTPUT_PREPROCESS) {
        ;
    } else if (0 == ret) {
        if (s-&gt;output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
            ret = tcc_run(s, argc, argv);
#endif
        } else {
            if (!s-&gt;outfile)
                s-&gt;outfile = default_outputfile(s, first_file);
            if (!s-&gt;just_deps &amp;&amp; tcc_output_file(s, s-&gt;outfile))
                ;
            else if (s-&gt;gen_deps)
                gen_makedeps(s, s-&gt;outfile, s-&gt;deps_outfile);
        }
    }

    done = 1;
    if (t)
        done = 0; /* run more tests with -dt -run */
    else if (s-&gt;nb_errors)
        ret = 1;
    else if (n &lt; s-&gt;nb_files)
        done = 0; /* compile more files with -c */
    else if (s-&gt;do_bench)
        tcc_print_stats(s, end_time - start_time);
    tcc_delete(s);
    if (!done) {  printf("#### 没有完成,跳转到 redo 继续.........\n");
        goto redo;}
    if (ppfp &amp;&amp; ppfp != stdout)
        fclose(ppfp);
    printf("编译结束了....... 返回的结果是 %d, 是否成功: %s\n", ret, ret ? "失败" : "成功");
    return ret;
}
</code></pre>
<h2 id="这段-main-函数详细分析"><a class="header" href="#这段-main-函数详细分析">这段 <code>main</code> 函数详细分析</a></h2>
<p>这个 <code>main</code> 函数属于 <code>TinyCC</code>（TCC），一个小型 C 编译器的项目。该函数处理编译器的启动、命令行参数解析、文件编译和输出操作。让我们逐步分析每个部分的作用。</p>
<h3 id="函数签名"><a class="header" href="#函数签名">函数签名</a></h3>
<pre><code class="language-c">int main(int argc0, char **argv0)
</code></pre>
<ul>
<li><strong><code>argc0</code></strong> 和 <strong><code>argv0</code></strong>：传递给程序的命令行参数。</li>
<li><strong><code>argc0</code></strong>：参数个数。</li>
<li><strong><code>argv0</code></strong>：包含所有命令行参数的字符串数组。</li>
</ul>
<h3 id="1-变量声明"><a class="header" href="#1-变量声明">1. 变量声明</a></h3>
<pre><code class="language-c">TCCState *s, *s1;
int ret, opt, n = 0, t = 0, done;
unsigned start_time = 0, end_time = 0;
const char *first_file;
int argc;
char **argv;
FILE *ppfp = stdout;
</code></pre>
<ul>
<li><strong><code>TCCState *s, *s1</code></strong>：<code>TCCState</code> 是 TCC 中用来表示编译器状态的结构体指针，<code>s</code> 和 <code>s1</code> 用于存储编译器的状态信息。</li>
<li><strong><code>ret</code>、<code>opt</code>、<code>n</code>、<code>t</code>、<code>done</code></strong>：这些变量控制编译过程中的状态，如返回值、选项、处理文件的索引等。</li>
<li><strong><code>start_time</code> 和 <code>end_time</code></strong>：记录编译的起止时间，用于性能基准测试。</li>
<li><strong><code>first_file</code></strong>：存储第一个编译文件的名字。</li>
<li><strong><code>argc</code> 和 <code>argv</code></strong>：本地变量，用来保存命令行参数。</li>
<li><strong><code>ppfp</code></strong>：文件指针，初始指向 <code>stdout</code>，用于预处理输出。</li>
</ul>
<h3 id="2-redo-标签和初始化"><a class="header" href="#2-redo-标签和初始化">2. <code>redo</code> 标签和初始化</a></h3>
<pre><code class="language-c">redo:
argc = argc0, argv = argv0;
s = s1 = tcc_new();
</code></pre>
<ul>
<li><strong><code>redo</code></strong>：这是一个标签，用于控制流程跳转。<code>goto redo;</code> 用于在某些条件下重复执行。</li>
<li><strong><code>tcc_new()</code></strong>：初始化编译器状态，创建一个新的 <code>TCCState</code> 对象。</li>
</ul>
<h3 id="3-命令行参数解析和预定义选项"><a class="header" href="#3-命令行参数解析和预定义选项">3. 命令行参数解析和预定义选项</a></h3>
<pre><code class="language-c">#ifdef CONFIG_TCC_SWITCHES
tcc_set_options(s, CONFIG_TCC_SWITCHES);
#endif
opt = tcc_parse_args(s, &amp;argc, &amp;argv, 1);
if (opt &lt; 0)
    return 1;
</code></pre>
<ul>
<li><strong><code>tcc_set_options</code></strong>：设置编译器的预定义选项，<code>CONFIG_TCC_SWITCHES</code> 是编译器预定义的配置。</li>
<li><strong><code>tcc_parse_args</code></strong>：解析命令行参数，将结果存储在 <code>opt</code> 中，如果解析失败，返回 <code>1</code> 退出程序。</li>
</ul>
<h3 id="4-处理特定的命令行选项"><a class="header" href="#4-处理特定的命令行选项">4. 处理特定的命令行选项</a></h3>
<pre><code class="language-c">if (n == 0) {
    if (opt == OPT_HELP) {
        fputs(help, stdout);
        return 0;
    }
    if (opt == OPT_M32 || opt == OPT_M64)
        return tcc_tool_cross(s, argv, opt);
    ...
}
</code></pre>
<ul>
<li>处理用户请求的特殊命令行选项，如 <code>OPT_HELP</code>、<code>OPT_M32</code> 等：
<ul>
<li><strong><code>OPT_HELP</code></strong>：输出帮助信息。</li>
<li><strong><code>OPT_M32</code> / <code>OPT_M64</code></strong>：设置目标架构（32位或64位），通过 <code>tcc_tool_cross</code> 函数处理交叉编译的需求。</li>
<li>其他选项如 <code>OPT_AR</code> 用于不同的编译器工具。</li>
</ul>
</li>
</ul>
<h3 id="5-处理文件"><a class="header" href="#5-处理文件">5. 处理文件</a></h3>
<pre><code class="language-c">if (s-&gt;nb_files == 0) {
    tcc_error_noabort("no input files");
}
else if (s-&gt;output_type == TCC_OUTPUT_PREPROCESS) {
    if (s-&gt;outfile &amp;&amp; strcmp("-", s-&gt;outfile) != 0) {
        ppfp = fopen(s-&gt;outfile, "wb");
        if (!ppfp)
            tcc_error_noabort("could not write '%s'", s-&gt;outfile);
    }
}
</code></pre>
<ul>
<li>如果没有输入文件，返回错误。</li>
<li>对于预处理输出 (<code>TCC_OUTPUT_PREPROCESS</code>)，将输出重定向到指定的文件。</li>
</ul>
<h3 id="6-编译文件"><a class="header" href="#6-编译文件">6. 编译文件</a></h3>
<pre><code class="language-c">do {
    struct filespec *f = s-&gt;files[n];
    s-&gt;filetype = f-&gt;type;
    if (f-&gt;type &amp; AFF_TYPE_LIB) {
        ret = tcc_add_library_err(s, f-&gt;name);
    } else {
        if (!first_file)
            first_file = f-&gt;name;
        ret = tcc_add_file(s, f-&gt;name);
    }
    done = ret || ++n &gt;= s-&gt;nb_files;
} while (!done &amp;&amp; (s-&gt;output_type != TCC_OUTPUT_OBJ || s-&gt;option_r));
</code></pre>
<ul>
<li>使用 <code>do-while</code> 循环逐个处理文件：
<ul>
<li><strong><code>AFF_TYPE_LIB</code></strong>：检查文件类型是否为库文件，如果是，则通过 <code>tcc_add_library_err</code> 添加库文件。</li>
<li><strong><code>tcc_add_file</code></strong>：编译文件。</li>
<li>使用 <code>done</code> 标志确定是否处理完所有文件。</li>
</ul>
</li>
</ul>
<h3 id="7-处理编译输出"><a class="header" href="#7-处理编译输出">7. 处理编译输出</a></h3>
<pre><code class="language-c">if (s-&gt;output_type == TCC_OUTPUT_MEMORY) {
    ret = tcc_run(s, argc, argv);
} else {
    if (!s-&gt;outfile)
        s-&gt;outfile = default_outputfile(s, first_file);
    if (!s-&gt;just_deps &amp;&amp; tcc_output_file(s, s-&gt;outfile)) {
        ;
    } else if (s-&gt;gen_deps)
        gen_makedeps(s, s-&gt;outfile, s-&gt;deps_outfile);
}
</code></pre>
<ul>
<li>根据输出类型处理：
<ul>
<li><strong><code>TCC_OUTPUT_MEMORY</code></strong>：立即运行内存中的程序。</li>
<li><strong>其他输出类型</strong>：如果有输出文件，生成目标文件或依赖文件。</li>
</ul>
</li>
</ul>
<h3 id="8-基准测试和错误处理"><a class="header" href="#8-基准测试和错误处理">8. 基准测试和错误处理</a></h3>
<pre><code class="language-c">if (s-&gt;do_bench) {
    end_time = getclock_ms();
}
if (s-&gt;nb_errors)
    ret = 1;
</code></pre>
<ul>
<li>如果启用了基准测试 (<code>do_bench</code>)，记录结束时间并计算编译时间。</li>
<li>如果编译过程中有错误，设置返回值 <code>ret = 1</code>。</li>
</ul>
<h3 id="9-重复处理或结束"><a class="header" href="#9-重复处理或结束">9. 重复处理或结束</a></h3>
<pre><code class="language-c">tcc_delete(s);
if (!done) {
    goto redo;
}
</code></pre>
<ul>
<li><strong><code>tcc_delete(s)</code></strong>：清理编译器状态。</li>
<li>如果没有完成所有任务，通过 <code>goto redo</code> 重新开始。</li>
</ul>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>这个 <code>main</code> 函数实现了 TCC 编译器的核心逻辑：</p>
<ol>
<li>初始化编译器状态。</li>
<li>解析命令行参数并处理特定选项。</li>
<li>根据命令行输入处理文件（编译、链接、生成输出）。</li>
<li>基于不同的输出类型执行不同的操作，如生成目标文件或直接运行内存中的代码。</li>
<li>处理错误和基准测试。</li>
<li>支持通过 <code>goto</code> 标签重复处理多个编译任务。</li>
</ol>
<p>该函数通过标签和条件控制不同的流程，从而支持灵活的编译和文件处理。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-main-函数的-argc-和-argv"><a class="header" href="#21-main-函数的-argc-和-argv">2.1 main 函数的 argc 和 argv</a></h1>
<p>在 C 语言的 <code>main</code> 函数中，<code>argc</code> 和 <code>argv</code> 是用于获取命令行参数的两个重要参数，它们通常由操作系统提供，当程序启动时，它们会携带用户在命令行中输入的参数。</p>
<h2 id="argc-和-argv-的来源"><a class="header" href="#argc-和-argv-的来源"><code>argc</code> 和 <code>argv</code> 的来源</a></h2>
<ol>
<li>
<p><strong>操作系统传递</strong>：当用户在命令行中执行一个程序时，操作系统会将用户输入的命令和参数解析，然后传递给程序的 <code>main</code> 函数。具体来说，<code>argc</code> 和 <code>argv</code> 是由操作系统传递给程序的启动函数，并由它们传递给 <code>main</code> 函数。</p>
<ul>
<li><strong><code>argc</code></strong>：表示传递给程序的命令行参数的个数。</li>
<li><strong><code>argv</code></strong>：是一个字符串数组，其中每个元素是一个用户在命令行中输入的参数。</li>
</ul>
</li>
<li>
<p><strong>命令行</strong>：用户在命令行中执行程序时提供了这些参数。比如：</p>
<pre><code class="language-bash">./my_program arg1 arg2
</code></pre>
<ul>
<li><code>argv[0]</code>：<code>"./my_program"</code>，是程序的名称或路径。</li>
<li><code>argv[1]</code>：<code>"arg1"</code>，是用户输入的第一个参数。</li>
<li><code>argv[2]</code>：<code>"arg2"</code>，是用户输入的第二个参数。</li>
<li><strong><code>argc</code></strong>：此时的值为 3，因为命令行总共提供了 3 个字符串：程序名称、<code>arg1</code> 和 <code>arg2</code>。</li>
</ul>
</li>
</ol>
<h2 id="argc-和-argv-的含义"><a class="header" href="#argc-和-argv-的含义"><code>argc</code> 和 <code>argv</code> 的含义</a></h2>
<ol>
<li>
<p><strong><code>argc</code></strong>：</p>
<ul>
<li>全称是 <strong>Argument Count</strong>，表示传递给程序的参数个数，包括程序本身。</li>
<li>例如，对于命令 <code>./my_program arg1 arg2</code>，<code>argc</code> 的值是 3。</li>
<li>如果没有提供参数，只执行程序本身，<code>argc</code> 的值是 1（因为只包含程序名称本身）。</li>
</ul>
</li>
<li>
<p><strong><code>argv</code></strong>：</p>
<ul>
<li>全称是 <strong>Argument Vector</strong>，是一个字符串数组，每个元素代表一个命令行参数。</li>
<li><code>argv[0]</code> 通常是程序的名称或路径，<code>argv[1]</code>、<code>argv[2]</code> 等是用户提供的参数。</li>
</ul>
</li>
</ol>
<h2 id="argc-和-argv-的用法"><a class="header" href="#argc-和-argv-的用法"><code>argc</code> 和 <code>argv</code> 的用法</a></h2>
<p>在 C 语言的 <code>main</code> 函数中，<code>argc</code> 和 <code>argv</code> 常用于处理用户在命令行中传递的参数，特别是编译器、命令行工具等程序。程序可以根据这些参数调整执行流程，比如编译、运行不同的任务或打开特定的文件。</p>
<h3 id="示例argc-和-argv-的使用"><a class="header" href="#示例argc-和-argv-的使用">示例：<code>argc</code> 和 <code>argv</code> 的使用</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    printf("argc = %d\n", argc);

    for (int i = 0; i &lt; argc; i++) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }

    return 0;
}
</code></pre>
<h3 id="运行结果"><a class="header" href="#运行结果">运行结果：</a></h3>
<p>当你在命令行中运行程序 <code>./my_program arg1 arg2</code> 时，输出结果将是：</p>
<pre><code class="language-bash">argc = 3
argv[0] = ./my_program
argv[1] = arg1
argv[2] = arg2
</code></pre>
<ul>
<li><strong><code>argc</code></strong>：告诉程序有 3 个参数。</li>
<li><strong><code>argv</code></strong>：存储了程序名称和传递的两个参数。</li>
</ul>
<h2 id="进一步分析main-函数中的-argc-和-argv-在你的代码中的使用"><a class="header" href="#进一步分析main-函数中的-argc-和-argv-在你的代码中的使用">进一步分析：<code>main</code> 函数中的 <code>argc</code> 和 <code>argv</code> 在你的代码中的使用</a></h2>
<p>在你的代码中，<code>main</code> 函数的签名如下：</p>
<pre><code class="language-c">int main(int argc0, char **argv0)
</code></pre>
<ul>
<li>这里 <code>argc0</code> 和 <code>argv0</code> 是从操作系统传递给 <code>main</code> 函数的原始命令行参数。</li>
<li>这些参数是用户在命令行中调用 <code>TCC</code> 编译器时传递的，比如用户输入 <code>./tcc -o output hello.c</code>，<code>argc0</code> 是参数的数量（4），<code>argv0</code> 是包含这些字符串的数组。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<pre><code class="language-c">argc = argc0;
argv = argv0;
</code></pre>
<ul>
<li>这将 <code>argc0</code> 和 <code>argv0</code> 赋值给本地变量 <code>argc</code> 和 <code>argv</code>，以便在函数的后续部分使用这些参数。这样做通常是为了简化使用，并且在需要时可以通过改变 <code>argc</code> 和 <code>argv</code> 的值，达到不同的效果。</li>
</ul>
<h2 id="你代码中的-argc-和-argv-的实际用途"><a class="header" href="#你代码中的-argc-和-argv-的实际用途">你代码中的 <code>argc</code> 和 <code>argv</code> 的实际用途</a></h2>
<ol>
<li>
<p><strong>传递给 <code>tcc_parse_args()</code></strong>：</p>
<pre><code class="language-c">opt = tcc_parse_args(s, &amp;argc, &amp;argv, 1);
</code></pre>
<p><code>tcc_parse_args</code> 是 <code>TinyCC</code> 中一个用于解析命令行参数的函数。它接收 <code>argc</code> 和 <code>argv</code>，并返回解析后的选项。这是命令行工具的核心功能，决定了程序根据用户输入的命令行参数执行什么操作。</p>
</li>
<li>
<p><strong>执行编译和其他工具任务</strong>：</p>
<p>根据用户输入的参数，<code>TCC</code> 会执行不同的任务，比如编译、链接、生成预处理文件等：</p>
<pre><code class="language-c">if (opt == OPT_HELP) {
    fputs(help, stdout);
    return 0;
}
</code></pre>
<p>如果用户输入了 <code>tcc --help</code>，程序会检测到 <code>OPT_HELP</code>，然后输出帮助信息。</p>
</li>
<li>
<p><strong>在编译过程中传递</strong>：</p>
<p>一些命令行参数，比如源文件路径或输出文件路径，会通过 <code>argc</code> 和 <code>argv</code> 被传递给编译器的其他部分，执行相应的文件操作或编译任务。</p>
</li>
</ol>
<h2 id="谁给的参数"><a class="header" href="#谁给的参数">谁给的参数？</a></h2>
<ul>
<li><strong>操作系统</strong>：当用户在命令行中运行程序时，操作系统会将用户输入的命令行参数解析，并传递给程序的 <code>main</code> 函数。
<ul>
<li>在 Linux、macOS 和 Windows 等操作系统中，当用户在终端或命令提示符下运行命令时，操作系统会捕获用户输入，并通过 <code>argc</code> 和 <code>argv</code> 传递给程序。</li>
<li>比如，在 Linux 上运行 <code>./tcc -o output hello.c</code>，操作系统会将 <code>argc = 4</code> 和 <code>argv = {"./tcc", "-o", "output", "hello.c"}</code> 传递给 <code>main</code> 函数。</li>
</ul>
</li>
</ul>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<ul>
<li><strong><code>argc</code></strong> 是命令行参数的数量。</li>
<li><strong><code>argv</code></strong> 是一个包含命令行参数的数组，每个参数都是一个字符串。</li>
<li>这些参数由操作系统传递，当用户通过命令行运行程序时，操作系统捕获用户的输入并将其传递给 <code>main</code> 函数。</li>
<li>在你的代码中，<code>argc0</code> 和 <code>argv0</code> 是系统传递的参数，它们被赋值给局部变量 <code>argc</code> 和 <code>argv</code>，并在编译器的初始化、参数解析、文件处理等过程中使用。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-static的用法"><a class="header" href="#22-static的用法">2.2 static的用法</a></h1>
<p>在 C 语言中，<code>static</code> 是一个关键字，它有多种不同的用法，具体取决于它在函数、变量或文件中的位置。<code>static</code> 主要用于控制变量和函数的<strong>作用域</strong>和<strong>生命周期</strong>。我们将详细讨论 <code>static</code> 在局部变量、全局变量和函数中的用法，并给出注意事项。</p>
<h2 id="1-static-局部变量"><a class="header" href="#1-static-局部变量">1. <code>static</code> 局部变量</a></h2>
<h3 id="11-用法"><a class="header" href="#11-用法">1.1 用法</a></h3>
<p>当 <code>static</code> 修饰局部变量时，该变量的生命周期扩展为整个程序运行期间，即它是<strong>静态存储的</strong>，但它的作用域仍然是定义它的函数内。</p>
<p>普通的局部变量在每次函数调用时都会重新创建和销毁，而 <code>static</code> 局部变量只在第一次调用时初始化，后续调用会保留其值。</p>
<h3 id="12-示例"><a class="header" href="#12-示例">1.2 示例</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void counter() {
    static int count = 0;  // 静态局部变量，初始化一次
    count++;
    printf("count = %d\n", count);
}

int main() {
    counter();  // 输出: count = 1
    counter();  // 输出: count = 2
    counter();  // 输出: count = 3
    return 0;
}
</code></pre>
<h3 id="13-注意事项"><a class="header" href="#13-注意事项">1.3 注意事项</a></h3>
<ul>
<li><strong>静态局部变量只初始化一次</strong>：即使多次调用函数，也不会再次初始化静态局部变量。</li>
<li><strong>生命周期是整个程序运行期间</strong>，但其作用域仅限于定义它的函数内部。</li>
</ul>
<h2 id="2-static-全局变量"><a class="header" href="#2-static-全局变量">2. <code>static</code> 全局变量</a></h2>
<h3 id="21-用法"><a class="header" href="#21-用法">2.1 用法</a></h3>
<p><code>static</code> 可以用来修饰全局变量，将全局变量的<strong>作用域限制在定义它的文件内部</strong>。通常，全局变量可以在整个程序中被其他文件访问，但使用 <code>static</code> 限制后，它只能在声明它的文件中访问，避免命名冲突。</p>
<h3 id="22-示例"><a class="header" href="#22-示例">2.2 示例</a></h3>
<pre><code class="language-c">// file1.c
static int count = 10;  // 静态全局变量，只在 file1.c 内可见

void increment() {
    count++;
}

int get_count() {
    return count;
}

// file2.c
#include &lt;stdio.h&gt;

extern int get_count();
extern void increment();

int main() {
    increment();  // file1.c 中的静态全局变量 count 被增加
    printf("count = %d\n", get_count());  // 输出: count = 11
    return 0;
}
</code></pre>
<h3 id="23-注意事项"><a class="header" href="#23-注意事项">2.3 注意事项</a></h3>
<ul>
<li><strong>作用域仅限于定义它的文件</strong>：即使其他文件使用 <code>extern</code> 关键字，也无法访问 <code>static</code> 修饰的全局变量。</li>
<li><strong>命名冲突避免</strong>：使用 <code>static</code> 可以确保全局变量在不同文件中使用相同的名字时不会冲突。</li>
</ul>
<h2 id="3-static-函数"><a class="header" href="#3-static-函数">3. <code>static</code> 函数</a></h2>
<h3 id="31-用法"><a class="header" href="#31-用法">3.1 用法</a></h3>
<p><code>static</code> 函数的作用域也仅限于定义它的文件内。它与 <code>static</code> 全局变量类似，修饰函数后，该函数只能在定义它的文件内调用。</p>
<h3 id="32-示例"><a class="header" href="#32-示例">3.2 示例</a></h3>
<pre><code class="language-c">// file1.c
static void helper() {
    printf("This is a static function.\n");
}

void call_helper() {
    helper();  // 可以在 file1.c 中调用
}

// file2.c
#include &lt;stdio.h&gt;

extern void call_helper();

int main() {
    call_helper();  // file1.c 中的函数被调用
    // helper();  // 错误！无法在 file2.c 中调用 static 函数
    return 0;
}
</code></pre>
<h3 id="33-注意事项"><a class="header" href="#33-注意事项">3.3 注意事项</a></h3>
<ul>
<li><strong>作用域仅限于文件内</strong>：<code>static</code> 函数不能被其他文件直接调用，即使使用 <code>extern</code> 也无效。</li>
<li><strong>函数命名冲突避免</strong>：如果在多个文件中定义了相同名字的 <code>static</code> 函数，它们彼此之间不会冲突，因为它们的作用域都仅限于各自的文件。</li>
</ul>
<h2 id="4-static-在类结构体中的使用c-对比"><a class="header" href="#4-static-在类结构体中的使用c-对比">4. <code>static</code> 在类/结构体中的使用（C++ 对比）</a></h2>
<p>在 C 语言中，<code>static</code> 不能直接修饰结构体成员。但在 C++ 中，<code>static</code> 可以用于类的静态成员变量和静态成员函数。静态成员属于类而不属于类的实例，它们在所有实例之间共享。</p>
<h3 id="41-示例c"><a class="header" href="#41-示例c">4.1 示例（C++）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class MyClass {
public:
    static int count;  // 静态成员变量
    MyClass() {
        count++;
    }
};

int MyClass::count = 0;  // 静态成员变量的初始化

int main() {
    MyClass obj1;
    MyClass obj2;
    std::cout &lt;&lt; "Count: " &lt;&lt; MyClass::count &lt;&lt; std::endl;  // 输出: Count: 2
    return 0;
}
</code></pre>
<h2 id="5-static-与多线程"><a class="header" href="#5-static-与多线程">5. <code>static</code> 与多线程</a></h2>
<p>在多线程程序中，使用 <code>static</code> 局部变量时需要格外小心，因为静态局部变量是跨函数调用共享的。如果多个线程同时访问该变量而没有同步机制，可能会导致竞争条件（race condition）。</p>
<h3 id="51-示例"><a class="header" href="#51-示例">5.1 示例</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

void* thread_func(void* arg) {
    static int shared_data = 0;  // 静态局部变量，多个线程共享
    shared_data++;
    printf("Thread %ld: shared_data = %d\n", (long)arg, shared_data);
    return NULL;
}

int main() {
    pthread_t threads[5];

    for (long i = 0; i &lt; 5; i++) {
        pthread_create(&amp;threads[i], NULL, thread_func, (void*)i);
    }

    for (int i = 0; i &lt; 5; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
</code></pre>
<h3 id="52-竞争条件问题"><a class="header" href="#52-竞争条件问题">5.2 竞争条件问题</a></h3>
<ul>
<li><strong>问题</strong>：多个线程共享同一个 <code>static</code> 变量 <code>shared_data</code>，可能导致线程之间的竞争条件。多个线程同时访问或修改该变量时，可能会导致意外结果。</li>
<li><strong>解决办法</strong>：通过使用互斥锁（mutex）等同步机制保护共享的 <code>static</code> 变量。</li>
</ul>
<h2 id="6-其他注意事项"><a class="header" href="#6-其他注意事项">6. 其他注意事项</a></h2>
<ol>
<li>
<p><strong>静态变量初始化</strong>：</p>
<ul>
<li><code>static</code> 变量在程序开始时被初始化一次，未显式初始化的静态变量会被自动初始化为<strong>零</strong>。</li>
<li>静态变量的初始化只发生一次，且是在程序启动时，而不是每次进入作用域时。</li>
</ul>
</li>
<li>
<p><strong>局部和全局的区别</strong>：</p>
<ul>
<li>局部静态变量的作用域是函数内部，而全局静态变量的作用域是文件内部。</li>
<li>局部静态变量的生命周期与程序相同，而普通局部变量的生命周期只限于函数调用期间。</li>
</ul>
</li>
<li>
<p><strong>避免名称冲突</strong>：</p>
<ul>
<li>静态全局变量和静态函数可以有效避免不同文件中同名的全局变量或函数引发的冲突。</li>
</ul>
</li>
<li>
<p><strong>性能优化</strong>：</p>
<ul>
<li>静态变量的使用可能在某些场景中提供性能上的优化，因为它们在整个程序运行期间仅初始化一次。</li>
</ul>
</li>
</ol>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<ul>
<li><strong>局部变量</strong>：<code>static</code> 局部变量在函数内部作用域中可见，但生命周期贯穿整个程序运行。</li>
<li><strong>全局变量</strong>：<code>static</code> 全局变量只能在声明它的文件中可见，作用域限制在文件内，避免全局命名冲突。</li>
<li><strong>函数</strong>：<code>static</code> 函数只能在声明它的文件中可见，不能被其他文件调用。</li>
<li><strong>多线程问题</strong>：在多线程程序中使用 <code>static</code> 变量需要特别注意同步问题。</li>
</ul>
<p>通过正确使用 <code>static</code>，可以控制变量的可见性、生命周期，以及有效避免全局变量和函数命名冲突，同时确保静态局部变量的值在多次函数调用之间保持一致。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-ppfp-变量的作用"><a class="header" href="#23-ppfp-变量的作用">2.3 ppfp 变量的作用</a></h1>
<h2 id="ppfp-出现的位置"><a class="header" href="#ppfp-出现的位置">ppfp 出现的位置</a></h2>
<p>为啥叫 <code>ppfp</code> 呢？</p>
<p><code>fp</code> 指的应该是 <code>FILE POINTER</code>，是一个文件指针。</p>
<p>变量 <code>ppfp</code> 在 tcc.c 代码中出现的先后顺序如下。</p>
<pre><code class="language-c">FILE *ppfp = stdout;  
printf("ppfp 是啥,为什么取这个名字: ppfp 是指向 stdcout 的文件指针\n");

// 当输出文件的类型是预处理的时候
} else if (s-&gt;output_type == TCC_OUTPUT_PREPROCESS) {
    printf("tcc.c 只是进行预处理..................\n");
    if (s-&gt;outfile &amp;&amp; 0!=strcmp("-",s-&gt;outfile)) {
        ppfp = fopen(s-&gt;outfile, "wb");
        if (!ppfp)
            tcc_error_noabort("could not write '%s'", s-&gt;outfile);
    }
} else if (s-&gt;output_type == TCC_OUTPUT_OBJ &amp;&amp; !s-&gt;option_r) { printf("生成的是目标文件................\n");


// 将 ppfp 赋值给 state 的 ppfp
s-&gt;ppfp = ppfp;

// 最后文件快结束的时候关闭文件指针
if (ppfp &amp;&amp; ppfp != stdout)
    fclose(ppfp);
</code></pre>
<h2 id="tccstate-结构体中的-ppfp"><a class="header" href="#tccstate-结构体中的-ppfp">TCCState 结构体中的 ppfp</a></h2>
<pre><code class="language-c">/* output file for preprocessing (-E) */
FILE *ppfp;
</code></pre>
<p>所以 <code>ppfp</code> 就是一个指向预处理文件的文件指针，<code>pp</code> 指的就是 <code>pre processing</code>。</p>
<p>在 <code>LIBTCCAPI TCCState *tcc_new(void)</code> 这个函数中给 <code>s-&gt;ppfp = stdout;</code> 赋值了 stdout。</p>
<pre><code class="language-c">#endif
    s-&gt;ppfp = stdout;
    /* might be used in error() before preprocess_start() */
    s-&gt;include_stack_ptr = s-&gt;include_stack;

    tcc_set_lib_path(s, CONFIG_TCCDIR);
    return s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-c-语言中的枚举的用法"><a class="header" href="#24-c-语言中的枚举的用法">2.4 C 语言中的枚举的用法</a></h1>
<h2 id="c-语言中的枚举enum"><a class="header" href="#c-语言中的枚举enum">C 语言中的枚举（<code>enum</code>）</a></h2>
<p>在 C 语言中，<strong>枚举（<code>enum</code>）</strong> 是一种用户自定义的数据类型，它用于为一组整数值分配易于理解的名称。枚举类型可以使代码更加可读和易于维护，特别是在需要表示离散值时，比如一周的星期几、月份、状态标识等。</p>
<h2 id="枚举的定义"><a class="header" href="#枚举的定义">枚举的定义</a></h2>
<p>枚举使用 <code>enum</code> 关键字来定义。其语法为：</p>
<pre><code class="language-c">enum 枚举名称 {
    枚举成员1,
    枚举成员2,
    枚举成员3,
    // ...
};
</code></pre>
<p>每个枚举成员默认从 <code>0</code> 开始依次递增，可以手动为枚举成员指定值。如果没有手动指定，后续成员的值会自动加 1。</p>
<h2 id="枚举的基本用法"><a class="header" href="#枚举的基本用法">枚举的基本用法</a></h2>
<h3 id="1-定义枚举类型"><a class="header" href="#1-定义枚举类型">1. 定义枚举类型</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 定义一个表示星期几的枚举
enum Weekday {
    Sunday,   // 默认值为 0
    Monday,   // 默认值为 1
    Tuesday,  // 默认值为 2
    Wednesday,// 默认值为 3
    Thursday, // 默认值为 4
    Friday,   // 默认值为 5
    Saturday  // 默认值为 6
};

int main() {
    enum Weekday today = Friday;
    printf("Today is day number %d of the week.\n", today);  // 输出: Today is day number 5 of the week.
    return 0;
}
</code></pre>
<h3 id="2-手动指定枚举成员的值"><a class="header" href="#2-手动指定枚举成员的值">2. 手动指定枚举成员的值</a></h3>
<p>可以为枚举成员指定特定的值，后续的枚举成员会在此基础上递增。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 定义枚举，指定枚举值
enum Weekday {
    Sunday = 0,   // 默认值 0
    Monday = 1,   // 手动指定值 1
    Tuesday = 10, // 手动指定值 10
    Wednesday,    // 将会自动递增为 11
    Thursday = 20,// 手动指定值 20
    Friday,       // 自动递增为 21
    Saturday      // 自动递增为 22
};

int main() {
    printf("Tuesday is day %d.\n", Tuesday);    // 输出: Tuesday is day 10.
    printf("Wednesday is day %d.\n", Wednesday);// 输出: Wednesday is day 11.
    printf("Saturday is day %d.\n", Saturday);  // 输出: Saturday is day 22.
    return 0;
}
</code></pre>
<h3 id="3-枚举的实际值"><a class="header" href="#3-枚举的实际值">3. 枚举的实际值</a></h3>
<p>枚举类型在底层实际上是整数类型（默认是 <code>int</code>），可以将枚举成员赋值给整数变量，或者将整数变量赋值给枚举类型。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 定义枚举
enum Weekday {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
};

int main() {
    enum Weekday today = Monday;
    int day_number = today;  // 将枚举类型赋值给整数变量
    printf("Today is %d.\n", day_number);  // 输出: Today is 1.
    
    today = 3;  // 也可以将整数赋值给枚举变量
    printf("Today is day %d of the week.\n", today);  // 输出: Today is day 3 of the week.
    return 0;
}
</code></pre>
<h2 id="枚举的常见用法"><a class="header" href="#枚举的常见用法">枚举的常见用法</a></h2>
<h3 id="1-状态表示"><a class="header" href="#1-状态表示">1. 状态表示</a></h3>
<p>枚举常用于表示一组相关的状态，比如网络状态、文件状态、处理器状态等。它可以提高代码的可读性和可维护性。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 定义文件状态的枚举
enum FileStatus {
    FILE_OK = 0,     // 文件正常
    FILE_NOT_FOUND,  // 文件未找到
    FILE_CORRUPT,    // 文件损坏
    FILE_READ_ONLY   // 文件只读
};

int main() {
    enum FileStatus status = FILE_NOT_FOUND;
    
    if (status == FILE_NOT_FOUND) {
        printf("Error: File not found.\n");  // 输出: Error: File not found.
    }
    return 0;
}
</code></pre>
<h3 id="2-用于标记标志位"><a class="header" href="#2-用于标记标志位">2. 用于标记标志位</a></h3>
<p>可以使用枚举为标志位提供有意义的名字，以便更好地操作二进制位。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 定义枚举，用于表示权限标志
enum Permission {
    Read    = 1,  // 1 &lt;&lt; 0, 读权限
    Write   = 2,  // 1 &lt;&lt; 1, 写权限
    Execute = 4   // 1 &lt;&lt; 2, 执行权限
};

int main() {
    int user_permissions = Read | Write;  // 用户同时具有读和写权限
    
    if (user_permissions &amp; Read) {
        printf("User has read permission.\n");  // 输出: User has read permission.
    }
    if (user_permissions &amp; Write) {
        printf("User has write permission.\n");  // 输出: User has write permission.
    }
    if (!(user_permissions &amp; Execute)) {
        printf("User does not have execute permission.\n");  // 输出: User does not have execute permission.
    }
    
    return 0;
}
</code></pre>
<h2 id="枚举的注意事项"><a class="header" href="#枚举的注意事项">枚举的注意事项</a></h2>
<ol>
<li>
<p><strong>枚举的底层是整数</strong>：虽然使用的是枚举类型，但在底层，枚举值实际上是整数。默认情况下，<code>enum</code> 的底层类型是 <code>int</code>，并且枚举成员从 0 开始递增。如果指定了第一个枚举值，则后续值依次递增。</p>
</li>
<li>
<p><strong>枚举变量和整数的相互转换</strong>：枚举变量可以直接赋值给整数变量，或者从整数变量赋值给枚举变量。</p>
</li>
<li>
<p><strong>类型检查</strong>：在 C 语言中，枚举类型实际上没有严格的类型检查，枚举变量可以赋值为任意整数。这一点与 C++ 不同，C++ 中枚举是有严格类型检查的。</p>
</li>
<li>
<p><strong>避免使用未定义的枚举值</strong>：虽然枚举类型在底层是整数，但是最好避免赋值一个枚举未定义的值给枚举变量，这可能会导致代码逻辑上的问题。</p>
</li>
<li>
<p><strong>范围内自动递增</strong>：枚举成员值默认从 0 开始，如果没有手动指定，它们会自动递增，直到到达最后一个枚举成员。</p>
</li>
<li>
<p><strong>与<code>switch-case</code>结合使用</strong>：枚举常与 <code>switch-case</code> 语句结合使用，来处理不同的枚举值。</p>
</li>
</ol>
<h2 id="枚举与-switch-case-的结合使用"><a class="header" href="#枚举与-switch-case-的结合使用">枚举与 <code>switch-case</code> 的结合使用</a></h2>
<p>枚举和 <code>switch-case</code> 的结合非常常见，用来处理枚举的不同值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

enum Color {
    RED,
    GREEN,
    BLUE
};

void print_color(enum Color color) {
    switch (color) {
        case RED:
            printf("The color is red.\n");
            break;
        case GREEN:
            printf("The color is green.\n");
            break;
        case BLUE:
            printf("The color is blue.\n");
            break;
        default:
            printf("Unknown color.\n");
    }
}

int main() {
    enum Color my_color = GREEN;
    print_color(my_color);  // 输出: The color is green.
    
    return 0;
}
</code></pre>
<h2 id="枚举的优缺点"><a class="header" href="#枚举的优缺点">枚举的优缺点</a></h2>
<h3 id="优点"><a class="header" href="#优点">优点：</a></h3>
<ol>
<li><strong>提高代码可读性</strong>：枚举为常量提供了有意义的名称，便于理解和维护。</li>
<li><strong>减少硬编码</strong>：避免了直接使用魔法数字（magic numbers）带来的潜在错误。</li>
<li><strong>易于调试</strong>：枚举常量名称可以在调试时直观地展示其意义。</li>
<li><strong>值的约束</strong>：虽然底层是整数，但枚举变量一般只能取定义的枚举值，减少了非法赋值的风险。</li>
</ol>
<h3 id="缺点"><a class="header" href="#缺点">缺点：</a></h3>
<ol>
<li><strong>没有严格的类型检查</strong>：在 C 语言中，枚举类型没有严格的类型检查，枚举变量可以赋值为任何整数值，这可能会引发逻辑错误。</li>
<li><strong>整数类型限制</strong>：默认情况下，枚举成员的值是整数类型，不能使用浮点数等其他类型。</li>
</ol>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<ul>
<li><strong>枚举类型</strong>提供了一种为整数值定义有意义名字的机制，使代码更加易于阅读和维护。</li>
<li><strong>自动递增的整数值</strong>：如果没有显式赋值，枚举成员的值会自动递增。</li>
<li><strong>常用于状态和标志</strong>：枚举在定义状态机、标志位以及离散值表示时非常有用。</li>
<li><strong>底层是整数类型</strong>，并且与整数有相互转换的灵活性，但也因此缺乏严格的类型检查。</li>
<li><strong>注意事项</strong>：应当避免为枚举变量赋值未定义的整数值，以保持代码逻辑的清晰和正确。</li>
</ul>
<p>通过正确使用枚举类型，可以大大提高代码的可读性和安全性，特别是在涉及多种状态和标志的情况下。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输出文件的类型定义"><a class="header" href="#输出文件的类型定义">输出文件的类型定义</a></h1>
<h2 id="类型定义"><a class="header" href="#类型定义">类型定义</a></h2>
<p>在 libtcc.h 这个文件中定义了输出文件的类型。</p>
<pre><code class="language-c">/* set output type. MUST BE CALLED before any compilation */
LIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type);

// 输出的内容会在内存中运行
#define TCC_OUTPUT_MEMORY   1 /* output will be run in memory */
// 输出的是可执行文件
#define TCC_OUTPUT_EXE      2 /* executable file */
// 输出的是动态链接库
#define TCC_OUTPUT_DLL      4 /* dynamic library */
// 输出的是目标文件
#define TCC_OUTPUT_OBJ      3 /* object file */
// 输出的是预处理文件
#define TCC_OUTPUT_PREPROCESS 5 /* only preprocess */

</code></pre>
<h2 id="默认的输出类型"><a class="header" href="#默认的输出类型">默认的输出类型</a></h2>
<p>如果不指定输出类型的话，似乎在这里会指定为 exe：</p>
<pre><code class="language-c">    if (s-&gt;output_type == 0)
        s-&gt;output_type = TCC_OUTPUT_EXE;
    tcc_set_output_type(s, s-&gt;output_type);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是目标文件"><a class="header" href="#什么是目标文件">什么是目标文件</a></h1>
<h2 id="什么是目标文件-1"><a class="header" href="#什么是目标文件-1">什么是目标文件？</a></h2>
<p><strong>目标文件</strong>（Object File）是由编译器将源代码（如 C、C++ 等语言）编译后生成的中间文件，通常是二进制格式。目标文件是构建可执行程序或库的一个中间步骤。它包含了机器指令、数据和必要的元数据，供链接器（Linker）使用，将多个目标文件链接成最终的可执行文件或库。</p>
<p>目标文件一般以 <code>.o</code>、<code>.obj</code> 或者 <code>.out</code> 为扩展名，具体取决于使用的编译器和操作系统。例如，在 Linux 系统中常用 <code>.o</code>，而在 Windows 系统中，目标文件通常使用 <code>.obj</code>。</p>
<h2 id="目标文件的生成过程"><a class="header" href="#目标文件的生成过程">目标文件的生成过程</a></h2>
<p>编译器将源代码翻译成汇编语言或机器语言指令时，会生成目标文件。这个过程称为<strong>编译</strong>（Compile），它是以下过程中的一部分：</p>
<ol>
<li><strong>预处理</strong>：预处理器处理头文件的包含、宏定义和条件编译等操作，生成纯粹的 C/C++ 源代码文件。</li>
<li><strong>编译</strong>：编译器将源代码翻译成汇编语言。</li>
<li><strong>汇编</strong>：汇编器将汇编语言翻译成机器语言，生成目标文件。</li>
<li><strong>链接</strong>：链接器将多个目标文件和库文件链接在一起，生成最终的可执行文件。</li>
</ol>
<p>例如，编译一个 C 文件 <code>main.c</code> 生成目标文件的命令是：</p>
<pre><code class="language-bash">gcc -c main.c -o main.o
</code></pre>
<ul>
<li><code>-c</code> 表示只进行编译和汇编，不进行链接。</li>
<li><code>main.o</code> 是生成的目标文件。</li>
</ul>
<h2 id="目标文件的结构"><a class="header" href="#目标文件的结构">目标文件的结构</a></h2>
<p>目标文件通常由以下几部分组成：</p>
<ol>
<li><strong>代码段（Text Segment）</strong>：存储编译生成的机器指令，即程序的执行代码。</li>
<li><strong>数据段（Data Segment）</strong>：
<ul>
<li><strong>初始化数据段</strong>：包含已初始化的全局变量和静态变量。</li>
<li><strong>未初始化数据段（BSS 段）</strong>：包含未初始化的全局变量和静态变量。编译器通常将这些变量标记为占用空间，但没有赋值。</li>
</ul>
</li>
<li><strong>符号表（Symbol Table）</strong>：记录程序中的函数和变量符号信息，用于链接过程中的符号解析。</li>
<li><strong>重定位信息（Relocation Information）</strong>：记录目标文件中的一些位置（如函数调用、全局变量）需要在链接时修正的地方，帮助链接器将不同目标文件中的符号正确地结合起来。</li>
<li><strong>调试信息（Debug Information）</strong>：如果编译时启用了调试选项（如 <code>-g</code>），目标文件还会包含调试信息，以便调试器追踪程序运行状态。</li>
</ol>
<h2 id="目标文件的类型"><a class="header" href="#目标文件的类型">目标文件的类型</a></h2>
<p>根据目标文件的用途和生成方式，它可以分为以下几种类型：</p>
<ol>
<li>
<p><strong>可重定位目标文件</strong>（Relocatable Object File）：</p>
<ul>
<li>通常由编译器生成，可以链接成最终的可执行文件。</li>
<li>包含了所有的代码和数据，但没有绑定到特定的内存地址，链接器负责将其与其他目标文件和库结合，并重定位其中的符号。</li>
</ul>
</li>
<li>
<p><strong>可执行文件</strong>（Executable Object File）：</p>
<ul>
<li>链接后的最终产物，可以直接执行。</li>
<li>所有的地址和符号已经在链接过程中确定下来，程序可以加载到内存并运行。</li>
</ul>
</li>
<li>
<p><strong>动态链接库文件</strong>（Shared Object File 或 Dynamic Library）：</p>
<ul>
<li>动态库是一种目标文件，它可以在运行时与可执行程序动态链接，节省内存和存储空间。</li>
<li>例如，在 Linux 系统中，动态链接库文件的扩展名通常是 <code>.so</code>，而在 Windows 中则是 <code>.dll</code>。</li>
</ul>
</li>
</ol>
<h2 id="目标文件的作用"><a class="header" href="#目标文件的作用">目标文件的作用</a></h2>
<p>目标文件在软件开发过程中扮演了重要的角色：</p>
<ol>
<li><strong>模块化编程</strong>：通过将每个源文件编译为单独的目标文件，开发者可以分阶段编译和调试程序，方便代码的维护和管理。</li>
<li><strong>增量编译</strong>：当程序中的某些源文件被修改时，只需重新编译受影响的文件，而无需重新编译整个项目。这极大提高了编译效率。</li>
<li><strong>链接库和程序</strong>：目标文件是构建静态库和动态库的基础，它们可以和其他目标文件链接，生成可执行文件或动态库。</li>
</ol>
<h2 id="目标文件和可执行文件的区别"><a class="header" href="#目标文件和可执行文件的区别">目标文件和可执行文件的区别</a></h2>
<ul>
<li><strong>目标文件</strong>是编译过程的中间产物，它包含了程序的机器代码和元数据，但通常还不能直接执行。</li>
<li><strong>可执行文件</strong>是链接器将多个目标文件、库文件合并，并将所有符号绑定到具体的内存地址后生成的文件，它是可以直接在操作系统上运行的程序。</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<pre><code class="language-bash"># 编译 source1.c 和 source2.c 生成目标文件
gcc -c source1.c -o source1.o
gcc -c source2.c -o source2.o

# 链接生成可执行文件
gcc source1.o source2.o -o my_program
</code></pre>
<p>在这个例子中，<code>source1.o</code> 和 <code>source2.o</code> 是目标文件，<code>my_program</code> 是最终生成的可执行文件。</p>
<h2 id="使用工具查看目标文件"><a class="header" href="#使用工具查看目标文件">使用工具查看目标文件</a></h2>
<p>可以使用一些工具来查看目标文件的内部结构和信息：</p>
<ol>
<li>
<p><strong><code>nm</code></strong>：用于查看目标文件中的符号表，显示函数和变量的符号名及其类型。</p>
<pre><code class="language-bash">nm main.o
</code></pre>
</li>
<li>
<p><strong><code>objdump</code></strong>：可以查看目标文件的详细内容，包括汇编代码、符号表、重定位信息等。</p>
<pre><code class="language-bash">objdump -d main.o  # 反汇编目标文件
</code></pre>
</li>
<li>
<p><strong><code>readelf</code></strong>：可以查看目标文件的 ELF 格式的详细信息（ELF 是一种常见的目标文件格式）。</p>
<pre><code class="language-bash">readelf -h main.o  # 查看 ELF 文件头
</code></pre>
</li>
</ol>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<ul>
<li><strong>目标文件</strong>是源代码编译后的二进制文件，它包含了机器指令、数据和符号信息，是生成可执行文件或库的中间步骤。</li>
<li><strong>类型</strong>：目标文件可以是可重定位目标文件、可执行文件或者动态库文件。</li>
<li><strong>结构</strong>：目标文件由代码段、数据段、符号表和重定位信息组成。</li>
<li><strong>作用</strong>：目标文件支持模块化编程和增量编译，并在最终链接时用于生成可执行文件。</li>
</ul>
<p>目标文件是程序从源代码到最终可执行文件或库的必经步骤，通过了解它的结构和作用，可以更好地理解编译、链接以及程序执行的整个过程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exe-和-dll-的区别"><a class="header" href="#exe-和-dll-的区别">exe 和 dll 的区别</a></h1>
<h2 id="exe-和-dll-的区别-1"><a class="header" href="#exe-和-dll-的区别-1">EXE 和 DLL 的区别</a></h2>
<p>在 Windows 操作系统中，<strong>EXE</strong> 和 <strong>DLL</strong> 是两种常见的文件格式，它们分别代表<strong>可执行文件</strong>和<strong>动态链接库</strong>。它们之间的区别主要体现在用途、文件结构、加载方式和内存管理等方面。以下是 EXE 和 DLL 的详细对比与说明：</p>
<h2 id="1-什么是-exe-和-dll"><a class="header" href="#1-什么是-exe-和-dll">1. 什么是 EXE 和 DLL？</a></h2>
<ul>
<li>
<p><strong>EXE</strong>（Executable File）：</p>
<ul>
<li><strong>用途</strong>：EXE 文件是独立的可执行文件，它包含了应用程序的入口点（如 <code>main()</code> 或 <code>WinMain()</code>），操作系统可以直接运行 EXE 文件。</li>
<li><strong>加载方式</strong>：当用户双击 EXE 文件时，操作系统会启动一个新的进程，加载 EXE 文件到内存，并开始执行其中的代码。</li>
</ul>
</li>
<li>
<p><strong>DLL</strong>（Dynamic Link Library）：</p>
<ul>
<li><strong>用途</strong>：DLL 文件是一个库文件，通常包含共享代码、数据或资源，供其他应用程序或动态库调用。DLL 文件本身不能直接运行，而是作为一个模块，必须由 EXE 文件或其他 DLL 加载。</li>
<li><strong>加载方式</strong>：DLL 是在运行时由主程序（如 EXE）或其他 DLL 文件加载到内存中的。DLL 中没有入口函数（如 <code>main()</code>），而是提供一组函数、类或资源，供调用方使用。</li>
</ul>
</li>
</ul>
<h2 id="2-主要区别"><a class="header" href="#2-主要区别">2. 主要区别</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>EXE</th><th>DLL</th></tr></thead><tbody>
<tr><td><strong>文件类型</strong></td><td>可执行文件</td><td>动态链接库</td></tr>
<tr><td><strong>用途</strong></td><td>独立运行的应用程序</td><td>提供给其他程序调用的函数和资源</td></tr>
<tr><td><strong>入口点</strong></td><td>有入口点（<code>main()</code> 或 <code>WinMain()</code>）</td><td>没有固定的入口点，函数由外部调用</td></tr>
<tr><td><strong>运行方式</strong></td><td>操作系统直接运行 EXE 文件</td><td>必须被其他 EXE 或 DLL 加载和调用</td></tr>
<tr><td><strong>内存分配</strong></td><td>独立分配内存</td><td>依赖主程序或其他 DLL 的内存管理</td></tr>
<tr><td><strong>多进程支持</strong></td><td>每个 EXE 启动一个新进程</td><td>DLL 被加载到调用程序的进程中，共享内存</td></tr>
<tr><td><strong>依赖性</strong></td><td>EXE 文件通常不依赖其他 EXE 文件</td><td>DLL 文件通常被多个 EXE 或 DLL 共享</td></tr>
<tr><td><strong>使用方式</strong></td><td>用户直接执行</td><td>通过显式或隐式链接由其他文件调用</td></tr>
</tbody></table>
</div>
<h2 id="3-文件内容与结构"><a class="header" href="#3-文件内容与结构">3. 文件内容与结构</a></h2>
<h3 id="exe-文件的结构"><a class="header" href="#exe-文件的结构">EXE 文件的结构：</a></h3>
<ul>
<li><strong>程序入口点</strong>：EXE 文件中有一个明确的入口点（如 <code>main()</code> 或 <code>WinMain()</code>），当用户启动 EXE 文件时，操作系统从该入口点开始执行程序。</li>
<li><strong>代码段、数据段、资源段</strong>：EXE 文件包含程序的代码段（指令）、数据段（变量）、资源段（如图标、菜单等），这些内容在加载时一起进入内存。</li>
<li><strong>独立执行</strong>：EXE 文件可以独立执行，并启动一个新的进程运行程序。</li>
</ul>
<h3 id="dll-文件的结构"><a class="header" href="#dll-文件的结构">DLL 文件的结构：</a></h3>
<ul>
<li><strong>没有主程序入口点</strong>：DLL 文件没有像 EXE 那样的主入口点，通常包含多个导出的函数、变量或资源，这些内容只能通过调用进行使用。</li>
<li><strong>导出表</strong>：DLL 文件包含一个导出表，列出了该 DLL 中可以供其他程序使用的函数或变量名称。这些函数和变量可以通过名称或序号进行调用。</li>
<li><strong>依赖调用方的进程</strong>：DLL 文件被加载到调用它的进程空间内，与调用者共享内存空间。</li>
</ul>
<h2 id="4-加载方式"><a class="header" href="#4-加载方式">4. 加载方式</a></h2>
<h3 id="exe-文件的加载"><a class="header" href="#exe-文件的加载">EXE 文件的加载：</a></h3>
<p>当用户双击一个 EXE 文件，操作系统会：</p>
<ul>
<li>启动一个新的进程；</li>
<li>将 EXE 文件的代码和数据加载到该进程的虚拟内存空间中；</li>
<li>从程序的入口点（<code>main()</code> 或 <code>WinMain()</code>）开始执行程序。</li>
</ul>
<h3 id="dll-文件的加载"><a class="header" href="#dll-文件的加载">DLL 文件的加载：</a></h3>
<p>DLL 文件不能直接运行，而是需要通过以下两种方式之一进行加载：</p>
<ol>
<li>
<p><strong>隐式加载</strong>：</p>
<ul>
<li>在编译时，通过 <code>import library</code> （导入库）的方式链接 DLL，程序运行时操作系统自动加载该 DLL 文件。</li>
<li>在 Windows 中，DLL 文件的符号链接会在程序启动时由链接器自动解析。</li>
</ul>
</li>
<li>
<p><strong>显式加载</strong>：</p>
<ul>
<li>使用 Windows API（如 <code>LoadLibrary()</code> 和 <code>GetProcAddress()</code>）在运行时显式地加载 DLL，并获取其中的函数地址，以便调用。</li>
</ul>
</li>
</ol>
<h2 id="5-实例"><a class="header" href="#5-实例">5. 实例</a></h2>
<h3 id="exe-的实例"><a class="header" href="#exe-的实例">EXE 的实例：</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, EXE!\n");
    return 0;
}
</code></pre>
<p>编译这个程序会生成一个 EXE 文件，用户可以双击运行它，它会在控制台输出 <code>"Hello, EXE!"</code>。</p>
<h3 id="dll-的实例"><a class="header" href="#dll-的实例">DLL 的实例：</a></h3>
<pre><code class="language-c">// example.c - 实现一个简单的 DLL
#include &lt;stdio.h&gt;

__declspec(dllexport) void hello_dll() {
    printf("Hello, DLL!\n");
}
</code></pre>
<p>编译生成一个 DLL 文件，可以通过以下方式在另一个程序中调用它：</p>
<pre><code class="language-c">// main.c - 使用显式加载 DLL
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

typedef void (*HelloDLLFunc)();

int main() {
    HMODULE hLib = LoadLibrary("example.dll");
    if (hLib) {
        HelloDLLFunc hello = (HelloDLLFunc)GetProcAddress(hLib, "hello_dll");
        if (hello) {
            hello();  // 调用 DLL 中的函数
        }
        FreeLibrary(hLib);  // 卸载 DLL
    } else {
        printf("Failed to load DLL.\n");
    }
    return 0;
}
</code></pre>
<p>在这个例子中，<code>LoadLibrary</code> 和 <code>GetProcAddress</code> 被用来显式加载 DLL，并调用其中的函数 <code>hello_dll()</code>。</p>
<h2 id="6-共享与重用"><a class="header" href="#6-共享与重用">6. 共享与重用</a></h2>
<ul>
<li>
<p><strong>EXE 文件</strong>：</p>
<ul>
<li>每次运行一个 EXE 文件时，操作系统会为该程序创建一个新的进程，程序中的所有变量、内存都是独立的，不会与其他程序共享。</li>
</ul>
</li>
<li>
<p><strong>DLL 文件</strong>：</p>
<ul>
<li>DLL 文件通常用于代码共享，一个 DLL 文件可以被多个程序加载，节省内存和存储空间。此外，多个进程可以共享同一个 DLL 文件的代码段，但数据段仍然是独立的。</li>
</ul>
</li>
</ul>
<h2 id="7-优势和应用场景"><a class="header" href="#7-优势和应用场景">7. 优势和应用场景</a></h2>
<h3 id="exe-文件的优势"><a class="header" href="#exe-文件的优势">EXE 文件的优势：</a></h3>
<ul>
<li><strong>独立执行</strong>：EXE 文件可以独立运行，无需依赖其他文件。</li>
<li><strong>进程隔离</strong>：每个 EXE 文件运行时，操作系统为其分配独立的进程和内存空间，互不干扰。</li>
</ul>
<h3 id="dll-文件的优势"><a class="header" href="#dll-文件的优势">DLL 文件的优势：</a></h3>
<ul>
<li><strong>代码重用</strong>：DLL 文件可以在多个程序之间共享，提高代码的重用性。</li>
<li><strong>减少内存占用</strong>：因为多个程序可以同时使用同一个 DLL 文件，所以可以节省内存。</li>
<li><strong>更新灵活</strong>：DLL 文件可以独立于主程序更新，更新库文件时不需要重新编译主程序。</li>
</ul>
<h3 id="exe-文件的应用场景"><a class="header" href="#exe-文件的应用场景">EXE 文件的应用场景：</a></h3>
<ul>
<li>独立应用程序，如文本编辑器、浏览器等，通常是通过 EXE 文件启动的。</li>
</ul>
<h3 id="dll-文件的应用场景"><a class="header" href="#dll-文件的应用场景">DLL 文件的应用场景：</a></h3>
<ul>
<li>操作系统库、图形库、数学库等常用功能模块通常以 DLL 文件的形式存在，多个应用程序可以加载这些库，重用其中的功能。</li>
</ul>
<h2 id="8-总结"><a class="header" href="#8-总结">8. 总结</a></h2>
<ul>
<li><strong>EXE 文件</strong>：是一种独立的可执行文件，用户可以直接运行，操作系统为其分配独立的进程和内存。</li>
<li><strong>DLL 文件</strong>：是一种动态链接库，不能直接运行，而是作为共享库由 EXE 或其他 DLL 文件加载和调用。它提供代码重用和模块化的好处，并能被多个进程共享。</li>
<li><strong>关键区别</strong>：EXE 文件可以独立执行，而 DLL 文件需要被其他文件加载和调用。EXE 文件启动一个新的进程，而 DLL 文件被加载到调用者的进程空间中。</li>
</ul>
<p>EXE 和 DLL 文件在应用程序开发中各有优势，开发者可以根据不同的需求选择使用。EXE 适合独立运行的程序，而 DLL 适合模块化和代码共享的场景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是-c-语言的预处理文件"><a class="header" href="#什么是-c-语言的预处理文件">什么是 C 语言的预处理文件</a></h1>
<h2 id="什么是-c-语言的预处理文件-1"><a class="header" href="#什么是-c-语言的预处理文件-1">什么是 C 语言的预处理文件？</a></h2>
<p><strong>预处理文件</strong> 是 C 语言编译过程中的一个中间产物，是经过<strong>预处理器</strong>处理后的源代码。C 语言的编译过程分为多个阶段，其中的<strong>预处理</strong>是第一步，预处理的结果就是生成一个预处理文件。该文件是原始源代码经过宏替换、头文件包含、条件编译等预处理指令处理后的代码。预处理文件通常以 <code>.i</code> 或 <code>.ii</code> 为扩展名，视具体的编译器而定。</p>
<p>预处理文件并不直接参与最终的可执行文件生成，而是作为编译过程的中间结果，供后续编译器进一步编译为目标文件。</p>
<h2 id="c-语言编译过程中的预处理步骤"><a class="header" href="#c-语言编译过程中的预处理步骤">C 语言编译过程中的预处理步骤</a></h2>
<p>C 语言的编译过程可以分为四个阶段：</p>
<ol>
<li><strong>预处理</strong>：处理宏定义、头文件包含、条件编译等预处理指令。</li>
<li><strong>编译</strong>：将经过预处理的源代码翻译成汇编代码。</li>
<li><strong>汇编</strong>：将汇编代码转换为机器代码，生成目标文件（object file）。</li>
<li><strong>链接</strong>：将多个目标文件和库文件链接成最终的可执行文件。</li>
</ol>
<h2 id="预处理文件生成过程"><a class="header" href="#预处理文件生成过程">预处理文件生成过程</a></h2>
<p>在 C 语言中，预处理指令以 <code>#</code> 开头，常见的预处理指令有：</p>
<ul>
<li><code>#include</code>：包含头文件。</li>
<li><code>#define</code>：定义宏。</li>
<li><code>#ifdef</code> / <code>#ifndef</code> / <code>#if</code> / <code>#else</code> / <code>#endif</code>：条件编译。</li>
<li><code>#undef</code>：取消宏定义。</li>
<li><code>#pragma</code>：设置编译器的特定行为。</li>
</ul>
<p>预处理器在处理源代码时，会执行以下操作：</p>
<ol>
<li><strong>宏替换</strong>：将所有使用 <code>#define</code> 定义的宏替换为相应的内容。</li>
<li><strong>头文件展开</strong>：将 <code>#include</code> 指令包含的头文件插入到源文件中，头文件内容会直接被复制到源文件中的 <code>#include</code> 位置。</li>
<li><strong>条件编译</strong>：根据条件编译指令（如 <code>#ifdef</code>、<code>#if</code> 等）决定是否包含某些代码段。</li>
<li><strong>去除注释</strong>：将源代码中的所有注释（<code>//</code> 和 <code>/* */</code>）都去除。</li>
</ol>
<p>生成的预处理文件是纯粹的 C 代码，不再包含任何预处理指令，预处理完成后，该文件将交由编译器进行编译。</p>
<h2 id="如何生成预处理文件"><a class="header" href="#如何生成预处理文件">如何生成预处理文件</a></h2>
<p>大多数 C 编译器提供了生成预处理文件的选项。以 <code>gcc</code> 为例，可以使用 <code>-E</code> 选项只进行预处理，而不进行编译：</p>
<pre><code class="language-bash">gcc -E main.c -o main.i
</code></pre>
<ul>
<li><code>-E</code>：表示只进行预处理，不进行编译、汇编和链接。</li>
<li><code>main.i</code>：生成的预处理文件。</li>
</ul>
<p>这样，<code>gcc</code> 会处理所有的宏、头文件和条件编译指令，并将处理后的内容输出到 <code>main.i</code> 文件中。</p>
<h2 id="预处理文件的内容"><a class="header" href="#预处理文件的内容">预处理文件的内容</a></h2>
<p>预处理文件的内容与原始源代码不同，它是已经展开并处理过的代码，常见的变化包括：</p>
<ol>
<li>
<p><strong>宏替换</strong>：所有的宏定义和使用都被展开，宏被替换为具体的代码。</p>
<p>原始代码：</p>
<pre><code class="language-c">#define PI 3.14
float area = PI * r * r;
</code></pre>
<p>预处理后的代码：</p>
<pre><code class="language-c">float area = 3.14 * r * r;
</code></pre>
</li>
<li>
<p><strong>头文件展开</strong>：所有 <code>#include</code> 指令包含的头文件会被替换为头文件中的具体内容。</p>
<p>原始代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>预处理后的代码：</p>
<pre><code class="language-c">// 展开 stdio.h 的内容
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
</code></pre>
</li>
<li>
<p><strong>条件编译</strong>：根据条件的不同，选择性地包含或排除代码。</p>
<p>原始代码：</p>
<pre><code class="language-c">#ifdef DEBUG
printf("Debug mode\n");
#endif
</code></pre>
<p>如果没有定义 <code>DEBUG</code>，预处理后的代码将不包含 <code>printf</code> 语句：</p>
<pre><code class="language-c">// 代码被预处理器移除了，因为 DEBUG 没有定义
</code></pre>
</li>
<li>
<p><strong>去除注释</strong>：所有的注释都会被删除。</p>
<p>原始代码：</p>
<pre><code class="language-c">// 这是一个单行注释
/* 这是一个多行注释 */
int a = 10;
</code></pre>
<p>预处理后的代码：</p>
<pre><code class="language-c">int a = 10;
</code></pre>
</li>
</ol>
<h2 id="预处理文件的作用"><a class="header" href="#预处理文件的作用">预处理文件的作用</a></h2>
<ol>
<li><strong>调试宏替换</strong>：预处理文件可以帮助开发者检查宏替换是否正确展开，确保复杂的宏定义在使用时得到预期的结果。</li>
<li><strong>调试头文件包含问题</strong>：有时头文件的包含顺序可能会影响程序的编译。通过生成预处理文件，开发者可以清楚看到每个 <code>#include</code> 指令所包含的具体内容，帮助排查问题。</li>
<li><strong>调试条件编译</strong>：条件编译指令常用于在不同环境下生成不同版本的代码。生成预处理文件可以帮助开发者确定哪些代码被编译器选择性包含，哪些代码被排除。</li>
<li><strong>优化编译过程</strong>：生成预处理文件可以加速多次编译中不变的部分，尤其是当某些头文件包含了大量宏定义或复杂的逻辑时，使用预处理文件可以避免重复处理。</li>
</ol>
<h2 id="使用预处理文件的注意事项"><a class="header" href="#使用预处理文件的注意事项">使用预处理文件的注意事项</a></h2>
<ol>
<li>
<p><strong>预处理文件的体积可能非常大</strong>：因为预处理器会展开所有宏和头文件，最终生成的预处理文件可能远比源代码大得多，尤其是在包含了大量标准库或第三方库时。</p>
</li>
<li>
<p><strong>可读性下降</strong>：预处理文件已经展开了所有宏定义、条件编译和头文件，它不再是开发者编写的原始代码，读起来可能比较困难。</p>
</li>
<li>
<p><strong>调试预处理指令问题</strong>：预处理文件是调试与预处理相关问题的一个重要工具，但它只显示预处理后的结果，开发者仍需从原始代码中查找和修改问题。</p>
</li>
</ol>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<h2 id="原始代码mainc"><a class="header" href="#原始代码mainc">原始代码（<code>main.c</code>）：</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define SQUARE(x) ((x) * (x))

int main() {
    int num = 5;
    printf("The square of %d is %d\n", num, SQUARE(num));
    return 0;
}
</code></pre>
<h2 id="预处理文件maini"><a class="header" href="#预处理文件maini">预处理文件（<code>main.i</code>）：</a></h2>
<pre><code class="language-c"># 1 "main.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "main.c"
# 1 "/usr/include/stdio.h" 1 3 4
// stdio.h 文件的展开内容...
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
// ...
# 2 "main.c" 2
int main() {
    int num = 5;
    printf("The square of %d is %d\n", num, ((num) * (num)));
    return 0;
}
</code></pre>
<p>在这个预处理文件中，<code>#include &lt;stdio.h&gt;</code> 被替换成了标准库的内容，宏 <code>SQUARE(x)</code> 也被替换为具体的表达式 <code>((x) * (x))</code>。</p>
<h2 id="总结-8"><a class="header" href="#总结-8">总结</a></h2>
<ul>
<li><strong>预处理文件</strong>是 C 编译器生成的一个中间文件，包含了源代码经过宏替换、头文件展开和条件编译处理后的代码。</li>
<li><strong>用途</strong>：用于帮助开发者检查预处理过程，调试宏定义、头文件包含和条件编译问题。</li>
<li><strong>生成方式</strong>：通过编译器选项（如 <code>gcc -E</code>）可以生成预处理文件。</li>
<li><strong>文件内容</strong>：预处理文件是纯粹的 C 代码，包含展开的宏、头文件和被保留的代码段，没有注释和预处理指令。</li>
</ul>
<p>预处理文件是编译器处理源代码的一个重要环节，它确保了代码能够在不同环境下进行正确编译，同时为开发者提供了灵活的宏和条件编译工具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前置声明"><a class="header" href="#前置声明">前置声明</a></h1>
<h2 id="c-语言中的不完整类型forward-declaration与-typedef-的用法"><a class="header" href="#c-语言中的不完整类型forward-declaration与-typedef-的用法">C 语言中的不完整类型（Forward Declaration）与 <code>typedef</code> 的用法</a></h2>
<p>在 C 语言中，<code>typedef</code> 和结构体的定义有一些灵活性。你提到的代码：</p>
<pre><code class="language-c">typedef struct TCCState TCCState;
</code></pre>
<p>是一个典型的<strong>不完整类型声明</strong>（Forward Declaration），同时结合了 <code>typedef</code>。让我们详细解释一下为什么能够这样定义，并且解释 <strong><code>struct TCCState</code></strong> 和 <strong><code>TCCState</code></strong> 是否可以同时使用。</p>
<h2 id="1-不完整类型声明forward-declaration"><a class="header" href="#1-不完整类型声明forward-declaration">1. <strong>不完整类型声明</strong>（Forward Declaration）</a></h2>
<p>首先，<code>struct TCCState;</code> 是一个不完整类型声明，也就是<strong>前置声明</strong>。它告诉编译器“存在一个名为 <code>TCCState</code> 的结构体”，但不提供结构体的具体定义。这样的声明允许在稍后定义结构体之前，使用该结构体的指针。例如：</p>
<pre><code class="language-c">struct TCCState;  // 不完整声明

struct TCCState *s;  // 可以声明一个指向 TCCState 的指针，但不能直接使用该结构体的成员
</code></pre>
<p>这段代码可以通过编译，因为你只声明了指向 <code>TCCState</code> 的指针，但并没有实际访问或定义它的内容。在程序的其他部分，你可以稍后提供这个结构体的完整定义。</p>
<h2 id="2-typedef-的用法"><a class="header" href="#2-typedef-的用法">2. <strong><code>typedef</code> 的用法</strong></a></h2>
<p>在 C 中，<code>typedef</code> 允许你为现有的类型定义一个新的名字。结合前面的前置声明：</p>
<pre><code class="language-c">typedef struct TCCState TCCState;
</code></pre>
<p>这句代码可以分解成两部分：</p>
<ul>
<li><code>struct TCCState</code>：不完整类型声明，告诉编译器有一个结构体 <code>TCCState</code>，但暂时不需要知道它的完整内容。</li>
<li><code>typedef struct TCCState TCCState;</code>：将 <code>struct TCCState</code> 定义为类型 <code>TCCState</code> 的别名，这样你就可以直接使用 <code>TCCState</code> 作为类型名，而不用每次都写 <code>struct TCCState</code>。</li>
</ul>
<p>这种用法在 C 语言中非常常见，尤其是在定义复杂结构体时。它使代码更加简洁，因为你可以直接使用 <code>TCCState</code> 而不是 <code>struct TCCState</code>。</p>
<h2 id="3-完整定义结构体"><a class="header" href="#3-完整定义结构体">3. <strong>完整定义结构体</strong></a></h2>
<p>稍后你可能会为 <code>TCCState</code> 提供完整定义，如下所示：</p>
<pre><code class="language-c">typedef struct TCCState {
    int some_field;
    // 其他成员...
} TCCState;
</code></pre>
<p>这时，<code>struct TCCState</code> 和 <code>TCCState</code> 变得完全等价。你可以在任何地方使用 <code>TCCState</code> 作为类型，而不必写 <code>struct TCCState</code>。</p>
<h2 id="4-struct-tccstate-与-tccstate-的混用"><a class="header" href="#4-struct-tccstate-与-tccstate-的混用">4. <strong><code>struct TCCState</code> 与 <code>TCCState</code> 的混用</strong></a></h2>
<p>现在来回答你的问题：<strong>能否同时使用 <code>struct TCCState s</code> 和 <code>TCCState s</code>？</strong></p>
<ul>
<li><strong>是的，可以同时使用</strong>，但有前提条件：
<ul>
<li>在<strong>没有定义 <code>typedef</code> 别名</strong>的情况下，必须使用 <code>struct TCCState</code> 来声明该结构体类型的变量。</li>
<li>在<strong>定义了 <code>typedef</code> 别名</strong>后，你可以直接使用 <code>TCCState</code> 作为结构体类型，而不需要写 <code>struct TCCState</code>。</li>
</ul>
</li>
</ul>
<h2 id="示例-1没有-typedef"><a class="header" href="#示例-1没有-typedef">示例 1：没有 <code>typedef</code></a></h2>
<pre><code class="language-c">struct TCCState {
    int some_field;
};

struct TCCState s;  // 正确
TCCState s2;  // 错误，因为没有 typedef，不能省略 struct
</code></pre>
<h2 id="示例-2有-typedef"><a class="header" href="#示例-2有-typedef">示例 2：有 <code>typedef</code></a></h2>
<pre><code class="language-c">typedef struct TCCState {
    int some_field;
} TCCState;

struct TCCState s1;  // 正确
TCCState s2;  // 正确
</code></pre>
<p>在这种情况下，<code>struct TCCState</code> 和 <code>TCCState</code> 是等价的，因为 <code>typedef</code> 已经将 <code>struct TCCState</code> 重命名为 <code>TCCState</code>。</p>
<h2 id="5-为什么要用-typedef"><a class="header" href="#5-为什么要用-typedef">5. 为什么要用 <code>typedef</code>？</a></h2>
<p>使用 <code>typedef</code> 的一个主要目的就是<strong>简化代码</strong>，减少写 <code>struct</code> 的频率。在 C 中，使用 <code>struct</code> 定义的结构体每次声明变量时都需要加上 <code>struct</code> 关键字。通过 <code>typedef</code>，你可以将结构体类型的名称变得简洁：</p>
<pre><code class="language-c">typedef struct TCCState TCCState;
</code></pre>
<ul>
<li>之后你可以直接写 <code>TCCState</code> 而不是 <code>struct TCCState</code>，从而让代码更易读、更简洁。</li>
</ul>
<h2 id="6-低级实现底层内存布局"><a class="header" href="#6-低级实现底层内存布局">6. 低级实现（底层内存布局）</a></h2>
<p>在底层，<code>typedef</code> 只是定义了一个别名，<code>typedef</code> 不会影响内存布局或编译后的程序执行。无论是 <code>struct TCCState</code> 还是 <code>TCCState</code>，它们都会在内存中有相同的布局。</p>
<p>这意味着，使用 <code>typedef</code> 的代码在性能上与不使用 <code>typedef</code> 的代码没有任何区别。<code>typedef</code> 仅仅是为了提高代码的可读性和简洁性。</p>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<ul>
<li><code>typedef struct TCCState TCCState;</code> 定义了 <code>TCCState</code> 作为 <code>struct TCCState</code> 的别名，使得你可以简化代码中的结构体声明。</li>
<li>定义了 <code>typedef</code> 后，<code>struct TCCState s</code> 和 <code>TCCState s</code> 是等价的，都可以使用。</li>
<li>如果没有 <code>typedef</code>，则只能使用 <code>struct TCCState</code>。</li>
<li><code>typedef</code> 主要用于简化代码，减少书写 <code>struct</code> 关键字的频率，提高代码可读性。</li>
</ul>
<p>这个机制广泛用于 C 语言的库和项目中，使得定义和使用复杂数据结构更加方便和简洁。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25-tccstate"><a class="header" href="#25-tccstate">2.5 TCCState</a></h1>
<p>libtcc.h 中有这个定义：</p>
<pre><code class="language-c">typedef struct TCCState TCCState;
</code></pre>
<p>为什么能这么定义， 使用的时候 struct TCCState s 和  TCCState s 能同时使用吗？如果有这些疑问可以参考这里: <a href="chapter_2/./%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E.html">类型前置声明</a></p>
<p>tcc.h 中定义了 TCCState 这个结构体：</p>
<pre><code class="language-c">struct TCCState {
    unsigned char verbose; /* if true, display some information during compilation */
    unsigned char nostdinc; /* if true, no standard headers are added */
    unsigned char nostdlib; /* if true, no standard libraries are added */
    unsigned char nocommon; /* if true, do not use common symbols for .bss data */
    unsigned char static_link; /* if true, static linking is performed */
    unsigned char rdynamic; /* if true, all symbols are exported */
    unsigned char symbolic; /* if true, resolve symbols in the current module first */
    unsigned char filetype; /* file type for compilation (NONE,C,ASM) */
    unsigned char optimize; /* only to #define __OPTIMIZE__ */
    unsigned char option_pthread; /* -pthread option */
    unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */
    unsigned int  cversion; /* supported C ISO version, 199901 (the default), 201112, ... */

    /* C language options */
    unsigned char char_is_unsigned;
    unsigned char leading_underscore;
    unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */
    unsigned char dollars_in_identifiers;  /* allows '$' char in identifiers */
    unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */

    /* warning switches */
    unsigned char warn_none;
    unsigned char warn_all;
    unsigned char warn_error;
    unsigned char warn_write_strings;
    unsigned char warn_unsupported;
    unsigned char warn_implicit_function_declaration;
    unsigned char warn_discarded_qualifiers;
    #define WARN_ON  1 /* warning is on (-Woption) */
    unsigned char warn_num; /* temp var for tcc_warning_c() */

    unsigned char option_r; /* option -r */
    unsigned char do_bench; /* option -bench */
    unsigned char just_deps; /* option -M  */
    unsigned char gen_deps; /* option -MD  */
    unsigned char include_sys_deps; /* option -MD  */
    unsigned char gen_phony_deps; /* option -MP */

    /* compile with debug symbol (and use them if error during execution) */
    unsigned char do_debug;
    unsigned char dwarf;
    unsigned char do_backtrace;
#ifdef CONFIG_TCC_BCHECK
    /* compile with built-in memory and bounds checker */
    unsigned char do_bounds_check;
#endif
    unsigned char test_coverage;  /* generate test coverage code */

    /* use GNU C extensions */
    unsigned char gnu_ext;
    /* use TinyCC extensions */
    unsigned char tcc_ext;

    unsigned char dflag; /* -dX value */
    unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */

#ifdef TCC_TARGET_X86_64
    unsigned char nosse; /* For -mno-sse support. */
#endif
#ifdef TCC_TARGET_ARM
    unsigned char float_abi; /* float ABI of the generated code*/
#endif

    unsigned char has_text_addr;
    addr_t text_addr; /* address of text section */
    unsigned section_align; /* section alignment */
#ifdef TCC_TARGET_I386
    int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */
#endif

    char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */
    char *soname; /* as specified on the command line (-soname) */
    char *rpath; /* as specified on the command line (-Wl,-rpath=) */
    char *elf_entryname; /* "_start" unless set */
    char *init_symbol; /* symbols to call at load-time (not used currently) */
    char *fini_symbol; /* symbols to call at unload-time (not used currently) */
    char *mapfile; /* create a mapfile (not used currently) */

    /* output type, see TCC_OUTPUT_XXX */
    int output_type;
    /* output format, see TCC_OUTPUT_FORMAT_xxx */
    int output_format;
    /* nth test to run with -dt -run */
    int run_test;

    /* array of all loaded dlls (including those referenced by loaded dlls) */
    DLLReference **loaded_dlls;
    int nb_loaded_dlls;

    /* include paths */
    char **include_paths;
    int nb_include_paths;

    char **sysinclude_paths;
    int nb_sysinclude_paths;

    /* library paths */
    char **library_paths;
    int nb_library_paths;

    /* crt?.o object path */
    char **crt_paths;
    int nb_crt_paths;

    /* -D / -U options */
    CString cmdline_defs;
    /* -include options */
    CString cmdline_incl;

    /* error handling */
    void *error_opaque;
    void (*error_func)(void *opaque, const char *msg);
    int error_set_jmp_enabled;
    jmp_buf error_jmp_buf;
    int nb_errors;

    /* output file for preprocessing (-E) */
    FILE *ppfp;

    /* for -MD/-MF: collected dependencies for this compilation */
    char **target_deps;
    int nb_target_deps;

    /* compilation */
    BufferedFile *include_stack[INCLUDE_STACK_SIZE];
    BufferedFile **include_stack_ptr;

    int ifdef_stack[IFDEF_STACK_SIZE];
    int *ifdef_stack_ptr;

    /* included files enclosed with #ifndef MACRO */
    int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE];
    CachedInclude **cached_includes;
    int nb_cached_includes;

    /* #pragma pack stack */
    int pack_stack[PACK_STACK_SIZE];
    int *pack_stack_ptr;
    char **pragma_libs;
    int nb_pragma_libs;

    /* inline functions are stored as token lists and compiled last
       only if referenced */
    struct InlineFunc **inline_fns;
    int nb_inline_fns;

    /* sections */
    Section **sections;
    int nb_sections; /* number of sections, including first dummy section */

    Section **priv_sections;
    int nb_priv_sections; /* number of private sections */

    /* predefined sections */
    Section *text_section, *data_section, *rodata_section, *bss_section;
    Section *common_section;
    Section *cur_text_section; /* current section where function code is generated */
#ifdef CONFIG_TCC_BCHECK
    /* bound check related sections */
    Section *bounds_section; /* contains global data bound description */
    Section *lbounds_section; /* contains local data bound description */
#endif
    /* symbol section */
    union { Section *symtab_section, *symtab; }; /* historical alias */
    /* temporary dynamic symbol sections (for dll loading) */
    Section *dynsymtab_section;
    /* exported dynamic symbol section */
    Section *dynsym;
    /* got &amp; plt handling */
    Section *got, *plt;
    /* debug sections */
    Section *stab_section;
    Section *dwarf_info_section;
    Section *dwarf_abbrev_section;
    Section *dwarf_line_section;
    Section *dwarf_aranges_section;
    Section *dwarf_str_section;
    Section *dwarf_line_str_section;
    int dwlo, dwhi; /* dwarf section range */
    /* test coverage */
    Section *tcov_section;
    /* debug state */
    struct _tccdbg *dState;

    /* Is there a new undefined sym since last new_undef_sym() */
    int new_undef_sym;
    /* extra attributes (eg. GOT/PLT value) for symtab symbols */
    struct sym_attr *sym_attrs;
    int nb_sym_attrs;
    /* ptr to next reloc entry reused */
    ElfW_Rel *qrel;
    #define qrel s1-&gt;qrel

#ifdef TCC_TARGET_RISCV64
    struct pcrel_hi { addr_t addr, val; } last_hi;
    #define last_hi s1-&gt;last_hi
#endif

#ifdef TCC_TARGET_PE
    /* PE info */
    int pe_subsystem;
    unsigned pe_characteristics;
    unsigned pe_file_align;
    unsigned pe_stack_size;
    addr_t pe_imagebase;
# ifdef TCC_TARGET_X86_64
    Section *uw_pdata;
    int uw_sym;
    unsigned uw_offs;
# endif
#else
    unsigned shf_RELRO; /* section flags for RELRO sections */
#endif

#if defined TCC_TARGET_MACHO
    char *install_name;
    uint32_t compatibility_version;
    uint32_t current_version;
#endif

#ifndef ELF_OBJ_ONLY
    int nb_sym_versions;
    struct sym_version *sym_versions;
    int nb_sym_to_version;
    int *sym_to_version;
    int dt_verneednum;
    Section *versym_section;
    Section *verneed_section;
#endif

#ifdef TCC_IS_NATIVE
    const char *run_main; /* entry for tcc_run() */
    void *run_ptr; /* runtime_memory */
    unsigned run_size; /* size of runtime_memory  */
#ifdef _WIN64
    void *run_function_table; /* unwind data */
#endif
    struct TCCState *next;
    struct rt_context *rc; /* pointer to backtrace info block */
    void *run_lj, *run_jb; /* sj/lj for tcc_setjmp()/tcc_run() */
    TCCBtFunc *bt_func;
    void *bt_data;
#endif

#ifdef CONFIG_TCC_BACKTRACE
    int rt_num_callers;
#endif

    /* benchmark info */
    int total_idents;
    int total_lines;
    unsigned int total_bytes;
    unsigned int total_output[4];

    /* option -dnum (for general development purposes) */
    int g_debug;

    /* used by tcc_load_ldscript */
    int fd, cc;

    /* for warnings/errors for object files */
    const char *current_filename;

    /* used by main and tcc_parse_args only */
    struct filespec **files; /* files seen on command line */
    int nb_files; /* number thereof */
    int nb_libraries; /* number of libs thereof */
    char *outfile; /* output filename */
    char *deps_outfile; /* option -MF */
    int argc;
    char **argv;
    CString linker_arg; /* collect -Wl options */
};
</code></pre>
<p>这个结构体定义地可真是够复杂的！C 语言中结构体最大能有多大呢？哪个控制这个结构体的大小呢？</p>
<p>现在还不想每个字段每个字段单独的解析这个。</p>
<h2 id="tcc_new-函数"><a class="header" href="#tcc_new-函数">tcc_new 函数</a></h2>
<pre><code class="language-c">LIBTCCAPI TCCState *tcc_new(void)
{
    TCCState *s;
    s = tcc_mallocz(sizeof(TCCState));  // 分配结构体的大小，在堆里面的
#ifdef MEM_DEBUG
    tcc_memcheck(1);
#endif

#undef gnu_ext
    // 因为这里需要堆 gnu_ext 赋值，之前可能会有这个 gnu_ext 的宏定义，所以需要取消
    s-&gt;gnu_ext = 1; 
    s-&gt;tcc_ext = 1;
    s-&gt;nocommon = 1;
    s-&gt;dollars_in_identifiers = 1; /*on by default like in gcc/clang*/
    s-&gt;cversion = 199901; /* default unless -std=c11 is supplied */
    s-&gt;warn_implicit_function_declaration = 1;
    s-&gt;warn_discarded_qualifiers = 1;
    s-&gt;ms_extensions = 1;

#ifdef CHAR_IS_UNSIGNED
    s-&gt;char_is_unsigned = 1;
#endif
#ifdef TCC_TARGET_I386
    s-&gt;seg_size = 32;
#endif
    /* enable this if you want symbols with leading underscore on windows: */
#if defined TCC_TARGET_MACHO /* || defined TCC_TARGET_PE */
    s-&gt;leading_underscore = 1;
#endif
#ifdef TCC_TARGET_ARM
    s-&gt;float_abi = ARM_FLOAT_ABI;
#endif
#ifdef CONFIG_NEW_DTAGS
    s-&gt;enable_new_dtags = 1;
#endif
    s-&gt;ppfp = stdout;
    /* might be used in error() before preprocess_start() */
    s-&gt;include_stack_ptr = s-&gt;include_stack;

    tcc_set_lib_path(s, CONFIG_TCCDIR);
    return s;
}
</code></pre>
<h2 id="tcc_mallocz-函数"><a class="header" href="#tcc_mallocz-函数">tcc_mallocz 函数</a></h2>
<h2 id="undef-gnu_ext"><a class="header" href="#undef-gnu_ext">#undef gnu_ext</a></h2>
<p>这个见 <a href="chapter_2/./#undefgnu_ext%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D.html">#undef gnu_ext 是什么意思</a></p>
<p>tcc.h 中有定义:</p>
<pre><code class="language-c">    /* use GNU C extensions */
    unsigned char gnu_ext;
    /* use TinyCC extensions */
    unsigned char tcc_ext;
</code></pre>
<p>tcc.h 中还有这个定义：</p>
<pre><code class="language-c">#define gnu_ext             TCC_STATE_VAR(gnu_ext)
</code></pre>
<p>感觉就是封装一个宏用于去取属性：</p>
<pre><code class="language-c">#undef TCC_STATE_VAR
#undef TCC_SET_STATE

#ifdef USING_GLOBALS
# define TCC_STATE_VAR(sym) tcc_state-&gt;sym
# define TCC_SET_STATE(fn) fn
# undef USING_GLOBALS
# undef _tcc_error
#else
# define TCC_STATE_VAR(sym) s1-&gt;sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)
# define _tcc_error use_tcc_error_noabort
#endif
</code></pre>
<h2 id="using_globals"><a class="header" href="#using_globals">USING_GLOBALS</a></h2>
<p>TODO</p>
<h2 id="seg_size-是啥"><a class="header" href="#seg_size-是啥">seg_size 是啥？</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undef-gnu_ext-是什么意思"><a class="header" href="#undef-gnu_ext-是什么意思">#undef gnu_ext 是什么意思</a></h1>
<p>在 C 语言中，<code>#undef</code> 是一个预处理指令，它用于<strong>取消之前定义的宏</strong>。当你看到 <code>#undef gnu_ext</code> 时，它的意思是<strong>取消宏 <code>gnu_ext</code> 的定义</strong>，也就是说，在该行之后，<code>gnu_ext</code> 宏将不再有效。</p>
<h2 id="详细解释"><a class="header" href="#详细解释">详细解释：</a></h2>
<h2 id="1-宏定义define"><a class="header" href="#1-宏定义define">1. 宏定义（<code>#define</code>）</a></h2>
<p>在 C 语言中，使用 <code>#define</code> 可以定义一个宏。例如：</p>
<pre><code class="language-c">#define gnu_ext 1
</code></pre>
<p>这行代码将定义一个名为 <code>gnu_ext</code> 的宏，并将其值设置为 <code>1</code>。从此之后，<code>gnu_ext</code> 可以在代码中被引用，编译器在预处理时会将它替换为 <code>1</code>。</p>
<h2 id="2-取消宏定义undef"><a class="header" href="#2-取消宏定义undef">2. 取消宏定义（<code>#undef</code>）</a></h2>
<p><code>#undef</code> 用于取消宏定义。假设之前定义了 <code>gnu_ext</code> 宏：</p>
<pre><code class="language-c">#define gnu_ext 1
</code></pre>
<p>然后在某个位置使用了 <code>#undef</code>：</p>
<pre><code class="language-c">#undef gnu_ext
</code></pre>
<p>这行代码的作用是<strong>取消之前对 <code>gnu_ext</code> 的定义</strong>。从 <code>#undef</code> 那一行开始，<code>gnu_ext</code> 宏将不再有效。如果之后的代码尝试使用 <code>gnu_ext</code>，将会导致编译错误，或者根据编译器的实现，它可能会被视为未定义的标识符。</p>
<h2 id="示例-2"><a class="header" href="#示例-2">示例：</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define gnu_ext 1  // 定义宏 gnu_ext

int main() {
    #ifdef gnu_ext
        printf("gnu_ext is defined: %d\n", gnu_ext);
    #endif

    #undef gnu_ext  // 取消宏 gnu_ext 的定义

    #ifdef gnu_ext
        printf("gnu_ext is still defined.\n");
    #else
        printf("gnu_ext is undefined.\n");
    #endif

    return 0;
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>gnu_ext is defined: 1
gnu_ext is undefined.
</code></pre>
<p>在这个示例中，程序首先定义了宏 <code>gnu_ext</code> 并输出了它的值，然后通过 <code>#undef</code> 取消了 <code>gnu_ext</code> 的定义。之后，当程序尝试检查 <code>gnu_ext</code> 是否被定义时，发现它已经被取消，因此输出 "gnu_ext is undefined."。</p>
<h2 id="什么时候使用-undef"><a class="header" href="#什么时候使用-undef">什么时候使用 <code>#undef</code>？</a></h2>
<ul>
<li><strong>取消不再需要的宏</strong>：当你在某个范围内定义了一个宏，但在之后不再需要该宏时，可以使用 <code>#undef</code> 取消它的定义，避免在后续代码中误用它。</li>
<li><strong>避免宏冲突</strong>：有时不同的库或代码模块可能会使用相同的宏名，为避免冲突，你可以使用 <code>#undef</code> 取消某个宏的定义，以确保后续代码或第三方库不会受到影响。</li>
<li><strong>调试和控制代码生成</strong>：你可以使用 <code>#undef</code> 控制条件编译。如果一个宏在多个地方被定义，通过 <code>#undef</code> 可以确保特定的条件编译路径不会被选择。</li>
</ul>
<h2 id="总结-10"><a class="header" href="#总结-10">总结</a></h2>
<p><code>#undef gnu_ext</code> 的意思是<strong>取消对宏 <code>gnu_ext</code> 的定义</strong>。在 <code>#undef</code> 之后，<code>gnu_ext</code> 将不再是一个宏，不能再使用。如果代码中有多个地方定义了同名宏，<code>#undef</code> 可以有效防止宏冲突，并且帮助控制代码中的宏行为。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="27-tcc_parse_args-命令行参数的解析"><a class="header" href="#27-tcc_parse_args-命令行参数的解析">2.7 tcc_parse_args: 命令行参数的解析</a></h1>
<h2 id="调用"><a class="header" href="#调用">调用</a></h2>
<p>在 main 函数中是这么调用的：</p>
<pre><code class="language-c">opt = tcc_parse_args(s, &amp;argc, &amp;argv, 1);
</code></pre>
<h2 id="函数定义"><a class="header" href="#函数定义">函数定义</a></h2>
<p><code>tcc_parse_args</code> 这个函数也非常之长。</p>
<pre><code class="language-c">PUB_FUNC int tcc_parse_args(TCCState *s, int *pargc, char ***pargv, int optind)
{
    TCCState *s1 = s; // 传进来的状态
    const TCCOption *popt;  // TCCOption
    const char *optarg, *r;
    const char *run = NULL;
    int x;
    int tool = 0, arg_start = 0, noaction = optind;
    char **argv = *pargv;
    int argc = *pargc;

    cstr_reset(&amp;s-&gt;linker_arg); // 重置链接参数

    while (optind &lt; argc) { // optind 是选项的索引
        r = argv[optind];   // 获取第 optind 变量，这个是入参，从第几个开始解析
        if (r[0] == '@' &amp;&amp; r[1] != '\0') {
            if (args_parser_listfile(s, r + 1, optind, &amp;argc, &amp;argv))
                return -1;
            continue;
        }
        optind++;
        if (tool) {
            if (r[0] == '-' &amp;&amp; r[1] == 'v' &amp;&amp; r[2] == 0)
                ++s-&gt;verbose;
            continue;
        }
reparse:
        if (r[0] != '-' || r[1] == '\0') {
            args_parser_add_file(s, r, s-&gt;filetype);
            if (run) {
dorun:
                if (tcc_set_options(s, run))
                    return -1;
                arg_start = optind - 1;
                break;
            }
            continue;
        }

        /* allow "tcc files... -run -- args ..." */
        if (r[1] == '-' &amp;&amp; r[2] == '\0' &amp;&amp; run)
            goto dorun;

        /* find option in table */
        for(popt = tcc_options; ; ++popt) {
            const char *p1 = popt-&gt;name;
            const char *r1 = r + 1;
            if (p1 == NULL)
                return tcc_error_noabort("invalid option -- '%s'", r);
            if (!strstart(p1, &amp;r1))
                continue;
            optarg = r1;
            if (popt-&gt;flags &amp; TCC_OPTION_HAS_ARG) {
                if (*r1 == '\0' &amp;&amp; !(popt-&gt;flags &amp; TCC_OPTION_NOSEP)) {
                    if (optind &gt;= argc)
                arg_err:
                        return tcc_error_noabort("argument to '%s' is missing", r);
                    optarg = argv[optind++];
                }
            } else if (*r1 != '\0')
                continue;
            break;
        }

        switch(popt-&gt;index) {
        case TCC_OPTION_HELP:
            x = OPT_HELP;
            goto extra_action;
        case TCC_OPTION_HELP2:
            x = OPT_HELP2;
            goto extra_action;
        case TCC_OPTION_I:
            tcc_add_include_path(s, optarg);
            break;
        case TCC_OPTION_D:
            tcc_define_symbol(s, optarg, NULL);
            break;
        case TCC_OPTION_U:
            tcc_undefine_symbol(s, optarg);
            break;
        case TCC_OPTION_L:
            tcc_add_library_path(s, optarg);
            break;
        case TCC_OPTION_B:
            /* set tcc utilities path (mainly for tcc development) */
            tcc_set_lib_path(s, optarg);
            ++noaction;
            break;
        case TCC_OPTION_l:
            args_parser_add_file(s, optarg, AFF_TYPE_LIB | (s-&gt;filetype &amp; ~AFF_TYPE_MASK));
            s-&gt;nb_libraries++;
            break;
        case TCC_OPTION_pthread:
            s-&gt;option_pthread = 1;
            break;
        case TCC_OPTION_bench:
            s-&gt;do_bench = 1;
            break;
#ifdef CONFIG_TCC_BACKTRACE
        case TCC_OPTION_bt:
            s-&gt;rt_num_callers = atoi(optarg); /* zero = default (6) */
            goto enable_backtrace;
        enable_backtrace:
            s-&gt;do_backtrace = 1;
            s-&gt;do_debug = s-&gt;do_debug ? s-&gt;do_debug : 1;
	    s-&gt;dwarf = DWARF_VERSION;
            break;
#ifdef CONFIG_TCC_BCHECK
        case TCC_OPTION_b:
            s-&gt;do_bounds_check = 1;
            goto enable_backtrace;
#endif
#endif
        case TCC_OPTION_g:
            s-&gt;do_debug = 2;
            s-&gt;dwarf = DWARF_VERSION;
            if (strstart("dwarf", &amp;optarg)) {
                s-&gt;dwarf = (*optarg) ? (0 - atoi(optarg)) : DEFAULT_DWARF_VERSION;
            } else if (isnum(*optarg)) {
                x = *optarg - '0';
                /* -g0 = no info, -g1 = lines/functions only, -g2 = full info */
                s-&gt;do_debug = x &gt; 2 ? 2 : x == 0 &amp;&amp; s-&gt;do_backtrace ? 1 : x;
#ifdef TCC_TARGET_PE
            } else if (0 == strcmp(".pdb", optarg)) {
                s-&gt;dwarf = 5, s-&gt;do_debug |= 16;
#endif
            }
            break;
        case TCC_OPTION_c:
            x = TCC_OUTPUT_OBJ;
        set_output_type:
            if (s-&gt;output_type)
                tcc_warning("-%s: overriding compiler action already specified", popt-&gt;name);
            s-&gt;output_type = x;
            break;
        case TCC_OPTION_d:
            if (*optarg == 'D')
                s-&gt;dflag = 3;
            else if (*optarg == 'M')
                s-&gt;dflag = 7;
            else if (*optarg == 't')
                s-&gt;dflag = 16;
            else if (isnum(*optarg))
                s-&gt;g_debug |= atoi(optarg);
            else
                goto unsupported_option;
            break;
        case TCC_OPTION_static:
            s-&gt;static_link = 1;
            break;
        case TCC_OPTION_std:
            if (strcmp(optarg, "=c11") == 0)
                s-&gt;cversion = 201112;
            break;
        case TCC_OPTION_shared:
            x = TCC_OUTPUT_DLL;
            goto set_output_type;
        case TCC_OPTION_soname:
            s-&gt;soname = tcc_strdup(optarg);
            break;
        case TCC_OPTION_o:
            if (s-&gt;outfile) {
                tcc_warning("multiple -o option");
                tcc_free(s-&gt;outfile);
            }
            s-&gt;outfile = tcc_strdup(optarg);
            break;
        case TCC_OPTION_r:
            /* generate a .o merging several output files */
            s-&gt;option_r = 1;
            x = TCC_OUTPUT_OBJ;
            goto set_output_type;
        case TCC_OPTION_isystem:
            tcc_add_sysinclude_path(s, optarg);
            break;
        case TCC_OPTION_include:
            cstr_printf(&amp;s-&gt;cmdline_incl, "#include \"%s\"\n", optarg);
            break;
        case TCC_OPTION_nostdinc:
            s-&gt;nostdinc = 1;
            break;
        case TCC_OPTION_nostdlib:
            s-&gt;nostdlib = 1;
            break;
        case TCC_OPTION_run:
#ifndef TCC_IS_NATIVE
            return tcc_error_noabort("-run is not available in a cross compiler");
#else
            run = optarg;
            x = TCC_OUTPUT_MEMORY;
            goto set_output_type;
#endif
        case TCC_OPTION_v:
            do ++s-&gt;verbose; while (*optarg++ == 'v');
            ++noaction;
            break;
        case TCC_OPTION_f:
            if (set_flag(s, options_f, optarg) &lt; 0)
                goto unsupported_option;
            break;
#ifdef TCC_TARGET_ARM
        case TCC_OPTION_mfloat_abi:
            /* tcc doesn't support soft float yet */
            if (!strcmp(optarg, "softfp")) {
                s-&gt;float_abi = ARM_SOFTFP_FLOAT;
            } else if (!strcmp(optarg, "hard"))
                s-&gt;float_abi = ARM_HARD_FLOAT;
            else
                return tcc_error_noabort("unsupported float abi '%s'", optarg);
            break;
#endif
        case TCC_OPTION_m:
            if (set_flag(s, options_m, optarg) &lt; 0) {
                if (x = atoi(optarg), x != 32 &amp;&amp; x != 64)
                    goto unsupported_option;
                if (PTR_SIZE != x/8)
                    return x;
                ++noaction;
            }
            break;
        case TCC_OPTION_W:
            s-&gt;warn_none = 0;
            if (optarg[0] &amp;&amp; set_flag(s, options_W, optarg) &lt; 0)
                goto unsupported_option;
            break;
        case TCC_OPTION_w:
            s-&gt;warn_none = 1;
            break;
        case TCC_OPTION_rdynamic:
            s-&gt;rdynamic = 1;
            break;
        case TCC_OPTION_Wl:
            if (s-&gt;linker_arg.size)
                ((char*)s-&gt;linker_arg.data)[s-&gt;linker_arg.size - 1] = ',';
            cstr_cat(&amp;s-&gt;linker_arg, optarg, 0);
            x = tcc_set_linker(s, s-&gt;linker_arg.data);
            if (x)
                cstr_reset(&amp;s-&gt;linker_arg);
            if (x &lt; 0)
                return -1;
            break;
        case TCC_OPTION_Wp:
            r = optarg;
            goto reparse;
        case TCC_OPTION_E:
            x = TCC_OUTPUT_PREPROCESS;
            goto set_output_type;
        case TCC_OPTION_P:
            s-&gt;Pflag = atoi(optarg) + 1;
            break;
        case TCC_OPTION_M:
            s-&gt;include_sys_deps = 1;
            // fall through
        case TCC_OPTION_MM:
            s-&gt;just_deps = 1;
            if(!s-&gt;deps_outfile)
                s-&gt;deps_outfile = tcc_strdup("-");
            // fall through
        case TCC_OPTION_MMD:
            s-&gt;gen_deps = 1;
            break;
        case TCC_OPTION_MD:
            s-&gt;gen_deps = 1;
            s-&gt;include_sys_deps = 1;
            break;
        case TCC_OPTION_MF:
            s-&gt;deps_outfile = tcc_strdup(optarg);
            break;
        case TCC_OPTION_MP:
            s-&gt;gen_phony_deps = 1;
            break;
        case TCC_OPTION_dumpmachine:
            printf("%s\n", dumpmachine_str);
            exit(0);
        case TCC_OPTION_dumpversion:
            printf ("%s\n", TCC_VERSION);
            exit(0);
        case TCC_OPTION_x:
            x = 0;
            if (*optarg == 'c')
                x = AFF_TYPE_C;
            else if (*optarg == 'a')
                x = AFF_TYPE_ASMPP;
            else if (*optarg == 'b')
                x = AFF_TYPE_BIN;
            else if (*optarg == 'n')
                x = AFF_TYPE_NONE;
            else
                tcc_warning("unsupported language '%s'", optarg);
            s-&gt;filetype = x | (s-&gt;filetype &amp; ~AFF_TYPE_MASK);
            break;
        case TCC_OPTION_O:
            s-&gt;optimize = atoi(optarg);
            break;
        case TCC_OPTION_print_search_dirs:
            x = OPT_PRINT_DIRS;
            goto extra_action;
        case TCC_OPTION_impdef:
            x = OPT_IMPDEF;
            goto extra_action;
#if defined TCC_TARGET_MACHO
        case TCC_OPTION_dynamiclib:
            x = TCC_OUTPUT_DLL;
            goto set_output_type;
        case TCC_OPTION_flat_namespace:
	     break;
        case TCC_OPTION_two_levelnamespace:
	     break;
        case TCC_OPTION_undefined:
	     break;
        case TCC_OPTION_install_name:
	    s-&gt;install_name = tcc_strdup(optarg);
            break;
        case TCC_OPTION_compatibility_version:
	    s-&gt;compatibility_version = parse_version(s, optarg);
            break;
        case TCC_OPTION_current_version:
	    s-&gt;current_version = parse_version(s, optarg);;
            break;
#endif
        case TCC_OPTION_ar:
            x = OPT_AR;
        extra_action:
            arg_start = optind - 1;
            if (arg_start != noaction)
                return tcc_error_noabort("cannot parse %s here", r);
            tool = x;
            break;
        default:
unsupported_option:
            tcc_warning_c(warn_unsupported)("unsupported option '%s'", r);
            break;
        }
    }
    if (s-&gt;linker_arg.size) {
        r = s-&gt;linker_arg.data;
        goto arg_err;
    }
    *pargc = argc - arg_start;
    *pargv = argv + arg_start;
    if (tool)
        return tool;
    if (optind != noaction)
        return 0;
    if (s-&gt;verbose == 2)
        return OPT_PRINT_DIRS;
    if (s-&gt;verbose)
        return OPT_V;
    return OPT_HELP;
}
</code></pre>
<h2 id="pub_func-宏"><a class="header" href="#pub_func-宏">PUB_FUNC 宏</a></h2>
<pre><code class="language-c"># ifdef LIBTCC_AS_DLL
#  define LIBTCCAPI __declspec(dllexport)
#  define PUB_FUNC LIBTCCAPI
# endif



#ifndef PUB_FUNC /* functions used by tcc.c but not in libtcc.h */
# define PUB_FUNC
#endif
</code></pre>
<p>在 TinyCC（TCC）的代码中，<code>PUB_FUNC</code> 宏用于控制函数的导出方式，尤其是在构建<strong>动态链接库</strong>（DLL）时的导出策略。让我们逐步分析这段代码，解释 <code>PUB_FUNC</code> 宏以及它的作用。</p>
<h3 id="1-libtcc_as_dll-的作用"><a class="header" href="#1-libtcc_as_dll-的作用">1. <code>LIBTCC_AS_DLL</code> 的作用</a></h3>
<pre><code class="language-c"># ifdef LIBTCC_AS_DLL
</code></pre>
<p>这段代码首先检查是否定义了 <code>LIBTCC_AS_DLL</code>。这个宏通常在构建 TinyCC 作为<strong>动态链接库</strong>（DLL）时定义。如果 <code>LIBTCC_AS_DLL</code> 被定义，意味着当前正在构建 TinyCC 的动态库版本，此时某些函数和符号需要显式导出，以供外部程序或库使用。</p>
<h3 id="2-libtccapi-和-pub_func-宏"><a class="header" href="#2-libtccapi-和-pub_func-宏">2. <code>LIBTCCAPI</code> 和 <code>PUB_FUNC</code> 宏</a></h3>
<pre><code class="language-c">#  define LIBTCCAPI __declspec(dllexport)
#  define PUB_FUNC LIBTCCAPI
# endif
</code></pre>
<ul>
<li>
<p><strong><code>__declspec(dllexport)</code></strong>：这是一个用于 Windows 平台的特定声明，表示将某个符号（通常是函数或变量）导出，以便其他模块（比如其他 EXE 或 DLL 文件）可以使用它。</p>
<ul>
<li>当编译一个 DLL 文件时，只有使用了 <code>__declspec(dllexport)</code> 声明的符号会被导出供外部使用。</li>
</ul>
</li>
<li>
<p><strong><code>LIBTCCAPI</code></strong>：<code>LIBTCCAPI</code> 被定义为 <code>__declspec(dllexport)</code>，意味着任何使用 <code>LIBTCCAPI</code> 的函数声明将被导出到 DLL 中。</p>
</li>
<li>
<p><strong><code>PUB_FUNC</code></strong>：接着，<code>PUB_FUNC</code> 被定义为 <code>LIBTCCAPI</code>，也就是 <code>__declspec(dllexport)</code>。所以，在 <code>LIBTCC_AS_DLL</code> 被定义时，<code>PUB_FUNC</code> 实际上是一个符号导出声明，它将指定的函数导出到 DLL。</p>
</li>
</ul>
<h3 id="3-ifndef-pub_func-宏块"><a class="header" href="#3-ifndef-pub_func-宏块">3. <code>#ifndef PUB_FUNC</code> 宏块</a></h3>
<pre><code class="language-c">#ifndef PUB_FUNC /* functions used by tcc.c but not in libtcc.h */
# define PUB_FUNC
#endif
</code></pre>
<p>这部分代码用于处理一种情况：如果 <code>LIBTCC_AS_DLL</code> 没有被定义，那么 <code>PUB_FUNC</code> 之前并没有被定义为 <code>LIBTCCAPI</code>。因此，它会为 <code>PUB_FUNC</code> 提供一个默认定义，使其为空。</p>
<p>换句话说：</p>
<ul>
<li><strong>如果没有定义 <code>LIBTCC_AS_DLL</code></strong>，<code>PUB_FUNC</code> 将被定义为空（即它不做任何事情）。</li>
<li><strong>如果定义了 <code>LIBTCC_AS_DLL</code></strong>，<code>PUB_FUNC</code> 将被定义为 <code>__declspec(dllexport)</code>，用于导出函数。</li>
</ul>
<h3 id="总结-11"><a class="header" href="#总结-11">总结</a></h3>
<ul>
<li>
<p><strong><code>PUB_FUNC</code> 宏的作用</strong>：<code>PUB_FUNC</code> 控制函数的导出。在构建动态库时，它确保指定的函数可以被导出并供外部使用。在构建静态库或普通可执行文件时，<code>PUB_FUNC</code> 为空，起不到任何作用。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当 TCC 被编译成 DLL 时，<code>PUB_FUNC</code> 宏会被展开为 <code>__declspec(dllexport)</code>，使得标记为 <code>PUB_FUNC</code> 的函数能够导出。</li>
<li>当 TCC 被编译为静态库或普通可执行文件时，<code>PUB_FUNC</code> 不会导出任何函数，只是一个空的占位符。</li>
</ul>
</li>
</ul>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<p>假设我们有一个函数：</p>
<pre><code class="language-c">PUB_FUNC void my_function() {
    // 函数实现
}
</code></pre>
<ul>
<li>
<p>如果在构建 TCC 时定义了 <code>LIBTCC_AS_DLL</code>，这段代码会被展开为：</p>
<pre><code class="language-c">__declspec(dllexport) void my_function() {
    // 函数实现
}
</code></pre>
<p>这样，<code>my_function</code> 函数就会被导出到 DLL 中，外部程序可以调用它。</p>
</li>
<li>
<p>如果没有定义 <code>LIBTCC_AS_DLL</code>，则 <code>PUB_FUNC</code> 会被定义为空，最终代码变为：</p>
<pre><code class="language-c">void my_function() {
    // 函数实现
}
</code></pre>
<p>在这种情况下，<code>my_function</code> 只是一个普通的函数，不会被导出到 DLL 中。</p>
</li>
</ul>
<h3 id="好处和使用场景"><a class="header" href="#好处和使用场景">好处和使用场景</a></h3>
<ul>
<li>
<p><strong>跨平台支持</strong>：通过使用宏（如 <code>LIBTCCAPI</code> 和 <code>PUB_FUNC</code>），可以在构建动态库时控制符号导出，同时也可以支持跨平台（虽然 <code>__declspec(dllexport)</code> 是 Windows 特定的，但类似机制在其他平台上也有，比如 <code>__attribute__((visibility("default")))</code> 在 Linux 中）。</p>
</li>
<li>
<p><strong>灵活性</strong>：通过这种宏定义，你可以在同一套代码中灵活地控制符号导出，适应不同的编译配置，而无需在代码中进行繁杂的修改。</p>
</li>
</ul>
<p>总结来说，<code>PUB_FUNC</code> 是一种预处理宏，用来灵活控制在不同编译环境（DLL 或非 DLL）中函数是否需要导出给外部使用。</p>
<h2 id="libtccapi"><a class="header" href="#libtccapi">LIBTCCAPI</a></h2>
<pre><code>#ifndef LIBTCCAPI
# define LIBTCCAPI
#endif


# ifdef LIBTCC_AS_DLL
#  define LIBTCCAPI __declspec(dllexport)
#  define PUB_FUNC LIBTCCAPI
# endif
</code></pre>
<p>在 C 语言中，使用 <code>#ifndef</code>（如果没有定义）和 <code>#define</code> 的模式是一种非常常见的防御性编程方法，用来确保宏或标识符有一个默认定义。这种模式主要是为了避免编译器报错并保证代码在各种环境下的兼容性和健壮性。</p>
<p>对于你提到的代码：</p>
<pre><code class="language-c">#ifndef LIBTCCAPI
# define LIBTCCAPI
#endif
</code></pre>
<p>这个做法背后的原因可以归结为以下几点：</p>
<h3 id="1-确保宏总有一个定义"><a class="header" href="#1-确保宏总有一个定义">1. <strong>确保宏总有一个定义</strong></a></h3>
<p><code>#ifndef</code> 的意思是“如果没有定义 <code>LIBTCCAPI</code>”，则定义它为默认值。在这种情况下，<code>LIBTCCAPI</code> 被定义为空（<code>#define LIBTCCAPI</code>）。这样做的目的是确保代码在某些编译环境下，即使没有明确定义 <code>LIBTCCAPI</code>，也能正常编译。</p>
<p>例如，<code>LIBTCCAPI</code> 可能用于在不同的编译配置中标识函数的导出或可见性，但在某些情况下（例如静态编译或不需要导出的环境中），可能没有设置这个宏。这时，如果没有给它一个默认值（空值），编译器可能会报错，因为没有定义的宏会导致未预期的行为。</p>
<h3 id="2-增强代码的可移植性"><a class="header" href="#2-增强代码的可移植性">2. <strong>增强代码的可移植性</strong></a></h3>
<p>通过这种防御性编程模式，开发者可以确保代码能够在<strong>不同的编译器</strong>和<strong>不同的编译选项</strong>下正常工作。举个例子：</p>
<ul>
<li>在<strong>Windows 动态链接库</strong>（DLL）编译时，<code>LIBTCCAPI</code> 可能需要定义为 <code>__declspec(dllexport)</code> 来导出函数。</li>
<li>在<strong>静态链接</strong>或<strong>普通编译</strong>时，<code>LIBTCCAPI</code> 不需要定义任何东西，因为没有函数需要导出。在这种情况下，<code>#define LIBTCCAPI</code>（即定义为空）就确保了代码的兼容性。</li>
</ul>
<p>这样，代码就可以在动态链接、静态链接、不同平台之间保持兼容。</p>
<h3 id="3-避免重复定义或冲突"><a class="header" href="#3-避免重复定义或冲突">3. <strong>避免重复定义或冲突</strong></a></h3>
<p>通过这种模式，开发者可以确保在代码的其他地方（或者通过编译器命令行参数）已经定义了 <code>LIBTCCAPI</code> 的情况下，不会重新定义它，避免重复定义的错误。</p>
<p>例如，可能在编译时已经通过编译器选项或在其他头文件中定义了 <code>LIBTCCAPI</code>，如果再重新定义会导致冲突。<code>#ifndef LIBTCCAPI</code> 确保只有在 <code>LIBTCCAPI</code> 未定义时才会给它一个默认定义，防止重复定义和冲突。</p>
<h3 id="4-代码的灵活性和可维护性"><a class="header" href="#4-代码的灵活性和可维护性">4. <strong>代码的灵活性和可维护性</strong></a></h3>
<p>使用这种结构可以使代码更易于维护。你可以在不同的编译环境下自定义 <code>LIBTCCAPI</code>，而无需修改源代码的每一个地方。例如，如果你要在某个编译环境中导出函数，你只需要在编译器或项目的配置中定义 <code>LIBTCCAPI</code>，而不需要修改头文件：</p>
<pre><code class="language-c">// Windows DLL 编译时，可能通过编译器参数定义 LIBTCCAPI 为 __declspec(dllexport)
gcc -DLIBTCCAPI=__declspec(dllexport)
</code></pre>
<p>在这种情况下，<code>LIBTCCAPI</code> 就不会被 <code>#define LIBTCCAPI</code> 空替代，因为它已经在编译时被定义了。</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>考虑以下代码片段：</p>
<pre><code class="language-c">#ifndef LIBTCCAPI
# define LIBTCCAPI
#endif

LIBTCCAPI void my_function();
</code></pre>
<p>在不同的编译配置下：</p>
<ul>
<li><strong>Windows 动态链接库</strong>（DLL）编译时，<code>LIBTCCAPI</code> 可能被定义为 <code>__declspec(dllexport)</code>，从而导出 <code>my_function</code>。</li>
<li><strong>静态库编译</strong>或<strong>普通可执行文件</strong>时，<code>LIBTCCAPI</code> 不需要任何定义。在这种情况下，<code>#define LIBTCCAPI</code> 将会使它为空，这样代码仍然能正常工作。</li>
</ul>
<h3 id="5-总结"><a class="header" href="#5-总结">5. <strong>总结</strong></a></h3>
<ul>
<li><strong>目的</strong>：<code>#ifndef LIBTCCAPI #define LIBTCCAPI</code> 是为了防止 <code>LIBTCCAPI</code> 未定义导致的编译错误，并确保代码在不同平台和编译环境下的兼容性和可移植性。</li>
<li><strong>灵活性</strong>：它允许 <code>LIBTCCAPI</code> 在特定环境中（例如 DLL 编译时）被自定义，而在其他环境中提供一个默认的空定义，确保代码不会因为未定义的宏而出错。</li>
<li><strong>可移植性和健壮性</strong>：这种防御性编程使得代码能够在不同的编译器和平台下更稳健地运行。</li>
</ul>
<p>通过这种方式，开发者可以写出更通用、更健壮的代码，在不同的编译环境中都能正常工作。</p>
<h2 id="cstr_reset"><a class="header" href="#cstr_reset">cstr_reset</a></h2>
<pre><code class="language-c">/* reset string to empty */
ST_FUNC void cstr_reset(CString *cstr)
{
    cstr-&gt;size = 0;
}
</code></pre>
<h2 id="tcc_parse_args-的返回码"><a class="header" href="#tcc_parse_args-的返回码">tcc_parse_args 的返回码</a></h2>
<pre><code class="language-c">/* tcc_parse_args return codes: */
#define OPT_HELP 1
#define OPT_HELP2 2
#define OPT_V 3
#define OPT_PRINT_DIRS 4
#define OPT_AR 5
#define OPT_IMPDEF 6
#define OPT_M32 32
#define OPT_M64 64
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_environment"><a class="header" href="#set_environment">set_environment</a></h1>
<h2 id="函数源码"><a class="header" href="#函数源码">函数源码</a></h2>
<pre><code class="language-c">static void set_environment(TCCState *s)
{
    char * path;

    path = getenv("C_INCLUDE_PATH");
    if(path != NULL) {
        tcc_add_sysinclude_path(s, path);
    }
    path = getenv("CPATH");
    if(path != NULL) {
        tcc_add_include_path(s, path);
    }
    path = getenv("LIBRARY_PATH");
    if(path != NULL) {
        tcc_add_library_path(s, path);
    }
}

</code></pre>
<h2 id="c_include_pathcpath和library_path"><a class="header" href="#c_include_pathcpath和library_path">C_INCLUDE_PATH，CPATH和LIBRARY_PATH</a></h2>
<p>在 C 和 C++ 编译环境中，环境变量用于指定编译器和链接器搜索头文件和库文件的路径。你提到的三个环境变量 <code>C_INCLUDE_PATH</code>、<code>CPATH</code> 和 <code>LIBRARY_PATH</code>，分别用于影响编译器的头文件和库文件搜索路径。它们的用途如下：</p>
<h3 id="1-c_include_path"><a class="header" href="#1-c_include_path">1. <strong><code>C_INCLUDE_PATH</code></strong>：</a></h3>
<ul>
<li><strong>作用</strong>：<code>C_INCLUDE_PATH</code> 是专门为 C 语言设置的环境变量，它告诉编译器在指定路径中查找 C 语言的<strong>头文件</strong>（<code>*.h</code> 文件）。</li>
<li><strong>用法</strong>：当编译器遇到 <code>#include</code> 指令时，会首先在源代码指定的路径（如 <code>#include "header.h"</code> 的路径）查找，如果找不到，就会根据 <code>C_INCLUDE_PATH</code> 中列出的路径进行搜索。</li>
</ul>
<h4 id="示例-4"><a class="header" href="#示例-4">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/headers/myheader.h
</code></pre>
<p>你可以设置 <code>C_INCLUDE_PATH</code> 让编译器知道应该查找这个路径：</p>
<pre><code class="language-bash">export C_INCLUDE_PATH=/home/user/headers
</code></pre>
<p>然后在代码中：</p>
<pre><code class="language-c">#include &lt;myheader.h&gt;
</code></pre>
<p>编译器会在 <code>/home/user/headers</code> 中查找 <code>myheader.h</code>。</p>
<h4 id="注意"><a class="header" href="#注意">注意：</a></h4>
<ul>
<li><code>C_INCLUDE_PATH</code> 仅适用于 C 语言。如果你使用 C++ 编译器，它不会查找 <code>C_INCLUDE_PATH</code>，但你可以使用 <code>CPLUS_INCLUDE_PATH</code> 来指定 C++ 的头文件搜索路径。</li>
</ul>
<h3 id="2-cpath"><a class="header" href="#2-cpath">2. <strong><code>CPATH</code></strong>：</a></h3>
<ul>
<li><strong>作用</strong>：<code>CPATH</code> 是一个更通用的环境变量，它适用于 C、C++ 以及其他语言的编译器。编译器会在 <code>CPATH</code> 中指定的路径中查找头文件（包括 <code>*.h</code> 文件和其他头文件）。</li>
<li><strong>优先级</strong>：<code>CPATH</code> 的优先级低于 <code>C_INCLUDE_PATH</code> 和 <code>CPLUS_INCLUDE_PATH</code>。也就是说，如果这两个变量定义了，编译器会首先使用它们指定的路径，而 <code>CPATH</code> 中的路径在它们之后被搜索。</li>
</ul>
<h4 id="示例-5"><a class="header" href="#示例-5">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/headers2/myheader.h
</code></pre>
<p>你可以设置 <code>CPATH</code> 来告诉编译器在哪些路径中查找头文件：</p>
<pre><code class="language-bash">export CPATH=/home/user/headers2
</code></pre>
<p>然后在代码中：</p>
<pre><code class="language-c">#include &lt;myheader.h&gt;
</code></pre>
<p>编译器会在 <code>/home/user/headers2</code> 中查找 <code>myheader.h</code>。</p>
<h4 id="注意-1"><a class="header" href="#注意-1">注意：</a></h4>
<ul>
<li><code>CPATH</code> 适用于所有语言，而不仅仅是 C 或 C++。因此，它的作用范围更广。</li>
</ul>
<h3 id="3-library_path"><a class="header" href="#3-library_path">3. <strong><code>LIBRARY_PATH</code></strong>：</a></h3>
<ul>
<li>
<p><strong>作用</strong>：<code>LIBRARY_PATH</code> 用于指定链接器在链接阶段查找库文件（<code>.a</code>、<code>.so</code>、<code>.lib</code> 文件）的路径。编译器在编译阶段查找头文件，而在链接阶段查找库文件时，会参考 <code>LIBRARY_PATH</code> 中指定的目录。</p>
</li>
<li>
<p><strong>用法</strong>：当你在编译过程中链接动态库或静态库时，如果库文件不在标准库路径下（如 <code>/usr/lib</code>），你可以通过设置 <code>LIBRARY_PATH</code> 来告诉编译器在指定路径中查找库文件。</p>
</li>
</ul>
<h4 id="示例-6"><a class="header" href="#示例-6">示例：</a></h4>
<p>假设你有以下目录结构：</p>
<pre><code>/home/user/libs/mylib.a
</code></pre>
<p>你可以设置 <code>LIBRARY_PATH</code> 让链接器在 <code>/home/user/libs</code> 中查找库文件：</p>
<pre><code class="language-bash">export LIBRARY_PATH=/home/user/libs
</code></pre>
<p>然后编译时：</p>
<pre><code class="language-bash">gcc -o myprogram myprogram.c -lmylib
</code></pre>
<p>链接器会在 <code>/home/user/libs</code> 中查找 <code>mylib.a</code> 并链接到程序中。</p>
<h4 id="注意-2"><a class="header" href="#注意-2">注意：</a></h4>
<ul>
<li><code>LIBRARY_PATH</code> 仅在编译器的<strong>链接阶段</strong>使用，与头文件的搜索路径无关。</li>
<li>对于运行时动态链接的库（<code>.so</code> 文件），链接器会使用 <code>LD_LIBRARY_PATH</code> 来查找。</li>
</ul>
<h3 id="三者的作用总结"><a class="header" href="#三者的作用总结">三者的作用总结：</a></h3>
<ol>
<li><strong><code>C_INCLUDE_PATH</code></strong>：专门用于 C 语言，指定编译器在编译 C 代码时查找头文件的路径。</li>
<li><strong><code>CPATH</code></strong>：更通用，适用于 C、C++ 及其他编程语言，指定编译器查找头文件的路径。</li>
<li><strong><code>LIBRARY_PATH</code></strong>：指定链接器在链接阶段查找库文件的路径。</li>
</ol>
<h4 id="环境变量的优先级"><a class="header" href="#环境变量的优先级">环境变量的优先级：</a></h4>
<ul>
<li>编译器会首先搜索默认的系统路径（如 <code>/usr/include</code>、<code>/usr/lib</code>），然后按照如下优先级搜索指定的路径：
<ul>
<li>C 语言头文件：先搜索 <code>C_INCLUDE_PATH</code>，再搜索 <code>CPATH</code>。</li>
<li>C++ 语言头文件：先搜索 <code>CPLUS_INCLUDE_PATH</code>，再搜索 <code>CPATH</code>。</li>
<li>库文件：搜索 <code>LIBRARY_PATH</code>。</li>
</ul>
</li>
</ul>
<h3 id="使用这些环境变量的好处"><a class="header" href="#使用这些环境变量的好处">使用这些环境变量的好处</a></h3>
<ol>
<li>
<p><strong>简化编译命令</strong>：通过预先设置这些环境变量，编译时无需使用 <code>-I</code>、<code>-L</code> 等编译选项来手动指定头文件和库的路径，简化了编译过程。</p>
</li>
<li>
<p><strong>跨项目使用共享的头文件和库</strong>：可以将常用的头文件和库路径放到这些环境变量中，多个项目都可以使用这些共享的资源，而无需在每个项目的构建文件中重复指定路径。</p>
</li>
</ol>
<h3 id="示例实际使用"><a class="header" href="#示例实际使用">示例：实际使用</a></h3>
<p>假设你有一个项目，其头文件和库文件位于以下自定义路径中：</p>
<pre><code>/home/user/project/include/myheader.h
/home/user/project/lib/mylib.a
</code></pre>
<p>为了编译时自动查找这些文件，你可以在终端中设置环境变量：</p>
<pre><code class="language-bash">export C_INCLUDE_PATH=/home/user/project/include
export LIBRARY_PATH=/home/user/project/lib
</code></pre>
<p>然后使用 <code>gcc</code> 编译项目时，不需要手动指定头文件和库文件路径：</p>
<pre><code class="language-bash">gcc -o myprogram main.c -lmylib
</code></pre>
<p>这将会在指定的路径中找到 <code>myheader.h</code> 和 <code>mylib.a</code>，并将它们包含到编译和链接过程中。</p>
<h3 id="总结-12"><a class="header" href="#总结-12">总结</a></h3>
<ul>
<li><strong><code>C_INCLUDE_PATH</code></strong>：用于 C 语言头文件的查找路径。</li>
<li><strong><code>CPATH</code></strong>：通用的头文件查找路径，适用于 C、C++ 等语言。</li>
<li><strong><code>LIBRARY_PATH</code></strong>：用于库文件（<code>.a</code>、<code>.so</code> 等）的查找路径，影响链接器的搜索行为。</li>
</ul>
<p>这些环境变量的使用简化了构建过程，特别是在多个项目共享库和头文件的情况下。</p>
<h2 id="getenv-函数"><a class="header" href="#getenv-函数">getenv 函数</a></h2>
<pre><code class="language-c">char *__cdecl getenv(const char *_VarName);
</code></pre>
<h3 id="getenv-函数详解"><a class="header" href="#getenv-函数详解"><code>getenv</code> 函数详解</a></h3>
<p>在 C 语言中，<code>getenv</code> 是一个用于获取<strong>环境变量</strong>值的函数。环境变量是操作系统维护的一些字符串，它们可以影响正在运行的程序的行为。通过 <code>getenv</code> 函数，程序可以访问这些环境变量的值，从而获取一些配置信息或系统信息。</p>
<h3 id="函数原型"><a class="header" href="#函数原型">函数原型</a></h3>
<p><code>getenv</code> 函数的原型在头文件 <code>&lt;stdlib.h&gt;</code> 中定义：</p>
<pre><code class="language-c">char *getenv(const char *name);
</code></pre>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<ul>
<li><strong><code>name</code></strong>：这是一个指向字符串的指针，用于指定要获取的环境变量的名称。该字符串是区分大小写的。</li>
</ul>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<ul>
<li>如果环境变量 <code>name</code> 存在，<code>getenv</code> 函数返回指向环境变量值的指针，该指针指向一个以空字符 <code>\0</code> 结尾的字符串。</li>
<li>如果环境变量 <code>name</code> 不存在，<code>getenv</code> 返回 <code>NULL</code>。</li>
</ul>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p><code>getenv</code> 常用于获取操作系统中设置的环境变量，比如 <code>PATH</code>、<code>HOME</code>、<code>USER</code> 等。程序可以通过这些环境变量来配置自己的行为。</p>
<h3 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // 获取环境变量 HOME 的值
    char *home = getenv("HOME");
    if (home != NULL) {
        printf("HOME environment variable: %s\n", home);
    } else {
        printf("HOME environment variable is not set.\n");
    }

    // 获取环境变量 PATH 的值
    char *path = getenv("PATH");
    if (path != NULL) {
        printf("PATH environment variable: %s\n", path);
    } else {
        printf("PATH environment variable is not set.\n");
    }

    return 0;
}
</code></pre>
<h4 id="示例输出"><a class="header" href="#示例输出">示例输出：</a></h4>
<pre><code class="language-bash">HOME environment variable: /home/user
PATH environment variable: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ol>
<li>
<p><strong>返回的指针指向静态内存</strong>：<code>getenv</code> 返回的指针指向的是一个静态内存区域，这意味着你不应该修改这个指针指向的内容，因为它可能会影响程序的其他部分。同时，该内存区域会在下一次调用 <code>getenv</code> 时被覆盖。</p>
</li>
<li>
<p><strong>线程安全性</strong>：<code>getenv</code> 通常不是线程安全的，多个线程同时调用时可能会出现数据竞态问题。标准库中的 <code>getenv</code> 函数可能会返回同一个全局缓冲区的地址，如果多个线程同时修改或读取环境变量，可能会导致不可预期的行为。为了在多线程中安全使用，某些系统（如 Linux）提供了 <code>secure_getenv</code> 函数，或类似的线程安全解决方案。</p>
</li>
<li>
<p><strong>大小写敏感</strong>：环境变量的名字在大多数操作系统中是区分大小写的。例如，<code>PATH</code> 和 <code>path</code> 是不同的环境变量。</p>
</li>
<li>
<p><strong>空值</strong>：如果指定的环境变量不存在，<code>getenv</code> 返回 <code>NULL</code>。在使用返回值之前，一定要检查它是否为 <code>NULL</code>，以避免程序崩溃。</p>
</li>
<li>
<p><strong>依赖环境</strong>：<code>getenv</code> 依赖于系统的环境变量配置，这些变量可能会因操作系统、启动方式等不同而有所差异。在跨平台开发时，需要注意不同平台上环境变量的命名和内容可能有所不同。</p>
</li>
</ol>
<h3 id="常见环境变量"><a class="header" href="#常见环境变量">常见环境变量</a></h3>
<p>以下是一些常见的环境变量：</p>
<ul>
<li><strong><code>PATH</code></strong>：指定可执行文件的搜索路径。当你在命令行中运行一个命令时，系统会在 <code>PATH</code> 中指定的目录中查找对应的可执行文件。</li>
<li><strong><code>HOME</code></strong>：表示当前用户的主目录路径。</li>
<li><strong><code>USER</code></strong>：当前登录的用户名。</li>
<li><strong><code>PWD</code></strong>：当前工作目录。</li>
<li><strong><code>SHELL</code></strong>：用户使用的默认 shell（如 <code>/bin/bash</code>）。</li>
<li><strong><code>TEMP</code></strong>：指定临时文件存储的路径。</li>
</ul>
<h3 id="使用-getenv-来检查自定义环境变量"><a class="header" href="#使用-getenv-来检查自定义环境变量">使用 <code>getenv</code> 来检查自定义环境变量</a></h3>
<p>有时，程序可能依赖于自定义的环境变量来配置某些行为。你可以使用 <code>getenv</code> 来检查这些变量，并根据变量的值做出相应的操作。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例：</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // 检查 MY_APP_MODE 自定义环境变量
    char *mode = getenv("MY_APP_MODE");
    
    if (mode != NULL &amp;&amp; strcmp(mode, "DEBUG") == 0) {
        printf("Program is running in DEBUG mode.\n");
    } else {
        printf("Program is running in NORMAL mode.\n");
    }

    return 0;
}
</code></pre>
<p>假设我们设置了环境变量 <code>MY_APP_MODE</code>：</p>
<pre><code class="language-bash">export MY_APP_MODE=DEBUG
</code></pre>
<p>执行该程序时，将输出：</p>
<pre><code class="language-bash">Program is running in DEBUG mode.
</code></pre>
<p>如果没有设置 <code>MY_APP_MODE</code>，输出将会是：</p>
<pre><code class="language-bash">Program is running in NORMAL mode.
</code></pre>
<h3 id="使用场景-1"><a class="header" href="#使用场景-1">使用场景</a></h3>
<ul>
<li><strong>动态配置</strong>：通过环境变量配置程序的运行模式、数据库连接信息、文件路径等。</li>
<li><strong>跨平台适配</strong>：不同平台上，环境变量可以用来适配不同的系统路径和依赖项。</li>
<li><strong>调试</strong>：环境变量常用于切换程序的调试模式（如 <code>DEBUG</code>），以输出调试信息或加载不同的配置。</li>
</ul>
<h3 id="getenv-的底层工作原理"><a class="header" href="#getenv-的底层工作原理"><code>getenv</code> 的底层工作原理</a></h3>
<p>在大多数操作系统中，环境变量是进程属性的一部分。每个进程都有一个环境块（environment block），存储了当前进程的所有环境变量。<code>getenv</code> 函数实际上是通过查询这个环境块来获取变量值的。</p>
<p>例如，POSIX 系统中，环境变量存储在全局变量 <code>environ</code> 中，它是一个指向字符串数组的指针。每个字符串的形式为 <code>"KEY=VALUE"</code>。</p>
<pre><code class="language-c">extern char **environ;
</code></pre>
<p><code>getenv</code> 的实现通常是遍历这个 <code>environ</code> 数组，查找与指定 <code>name</code> 匹配的键，找到后返回对应的值。</p>
<h3 id="总结-13"><a class="header" href="#总结-13">总结</a></h3>
<ul>
<li><strong><code>getenv</code> 函数</strong>：用于获取系统中的环境变量值。通过传递环境变量的名称作为参数，返回该变量的值。</li>
<li><strong>返回值</strong>：成功时返回指向环境变量值的指针，失败时返回 <code>NULL</code>。</li>
<li><strong>常见用途</strong>：获取系统环境配置信息、配置程序行为、调试等。</li>
<li><strong>注意事项</strong>：返回的指针指向静态内存区域，不应修改，且 <code>getenv</code> 在多线程中可能不是线程安全的。</li>
</ul>
<p><code>getenv</code> 是一个非常有用的函数，特别是在需要根据环境动态调整程序行为的场景下，可以帮助开发者编写更加灵活和可配置的程序。</p>
<h2 id="添加-tcc-state-的路径中"><a class="header" href="#添加-tcc-state-的路径中">添加 tcc state 的路径中</a></h2>
<pre><code class="language-c">LIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;include_paths, &amp;s-&gt;nb_include_paths, pathname);
    return 0;
}

LIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;sysinclude_paths, &amp;s-&gt;nb_sysinclude_paths, pathname);
    return 0;
}

LIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname)
{
    tcc_split_path(s, &amp;s-&gt;library_paths, &amp;s-&gt;nb_library_paths, pathname);
    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译的整体流程"><a class="header" href="#编译的整体流程">编译的整体流程</a></h1>
<h2 id="main-函数中剩余的方法"><a class="header" href="#main-函数中剩余的方法">main 函数中剩余的方法</a></h2>
<pre><code class="language-c">    // 如果输出是在内存里面或者预处理的话，做了 blabla......
    if ((s-&gt;output_type == TCC_OUTPUT_MEMORY
      || s-&gt;output_type == TCC_OUTPUT_PREPROCESS)
        &amp;&amp; (s-&gt;dflag &amp; 16)) { /* -dt option */
        if (t)
            s-&gt;dflag |= 32;
        s-&gt;run_test = ++t;
        if (n)
            --n;
    }

    /* compile or add each files or library */
    first_file = NULL;
    do {
        struct filespec *f = s-&gt;files[n];
        s-&gt;filetype = f-&gt;type;
        printf("#### 编译单个文件 -&gt; %s\n", f-&gt;name);
        if (f-&gt;type &amp; AFF_TYPE_LIB) {
            printf("AFF_TYPE_LIB类型......... 使用枚举来判断\n");
            ret = tcc_add_library_err(s, f-&gt;name);
        } else {
            if (1 == s-&gt;verbose)
                printf("-&gt; %s\n", f-&gt;name);
            if (!first_file)        // 为什么要有 first_file 呢?
                first_file = f-&gt;name;
            ret = tcc_add_file(s, f-&gt;name);
            printf("tcc_add_file 是干啥的...........\n");
        }
        done = ret || ++n &gt;= s-&gt;nb_files;
        printf("判断是否 done了..................\n");
    } while (!done &amp;&amp; (s-&gt;output_type != TCC_OUTPUT_OBJ || s-&gt;option_r));

    if (s-&gt;do_bench) {
        printf("判断是否是 bench, 如果是的话计算时间");
        end_time = getclock_ms();
    }
        

    if (s-&gt;run_test) {
        t = 0;
    } else if (s-&gt;output_type == TCC_OUTPUT_PREPROCESS) {
        ;
    } else if (0 == ret) {
        if (s-&gt;output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
            ret = tcc_run(s, argc, argv);
#endif
        } else {
            if (!s-&gt;outfile)
                s-&gt;outfile = default_outputfile(s, first_file);
            if (!s-&gt;just_deps &amp;&amp; tcc_output_file(s, s-&gt;outfile))
                ;
            else if (s-&gt;gen_deps)
                gen_makedeps(s, s-&gt;outfile, s-&gt;deps_outfile);
        }
    }

    done = 1;
    if (t)
        done = 0; /* run more tests with -dt -run */
    else if (s-&gt;nb_errors)
        ret = 1;
    else if (n &lt; s-&gt;nb_files)
        done = 0; /* compile more files with -c */
    else if (s-&gt;do_bench)
        tcc_print_stats(s, end_time - start_time);
    tcc_delete(s);
    if (!done) {  printf("#### 没有完成,跳转到 redo 继续.........\n");
        goto redo;}
    if (ppfp &amp;&amp; ppfp != stdout)
        fclose(ppfp);
    printf("编译结束了....... 返回的结果是 %d, 是否成功: %s\n", ret, ret ? "失败" : "成功");
    return ret;
}
</code></pre>
<h2 id="tcc_add_library_err"><a class="header" href="#tcc_add_library_err">tcc_add_library_err</a></h2>
<pre><code class="language-c">if (f-&gt;type &amp; AFF_TYPE_LIB) {
    printf("AFF_TYPE_LIB类型......... 使用枚举来判断\n");
    ret = tcc_add_library_err(s, f-&gt;name);
} else {
</code></pre>
<p>如果文件类型为 <code>AFF_TYPE_LIB</code> 时，就执行 <code>tcc_add_library_err</code> 这个函数。</p>
<pre><code class="language-c">PUB_FUNC int tcc_add_library_err(TCCState *s1, const char *libname)
{
    int ret = tcc_add_library(s1, libname);
    if (ret == FILE_NOT_FOUND)
        tcc_error_noabort("library '%s' not found", libname);
    return ret;
}
</code></pre>
<p>将库文件加入进来，如果有报错的话就执行 <code>tcc_error_noabort</code> 返回报错。</p>
<p><code>ret</code> 会用来判断是否 done 了:</p>
<pre><code class="language-c">done = ret || ++n &gt;= s-&gt;nb_files;  printf("判断是否 done了..................\n");
</code></pre>
<h2 id="tcc_add_file"><a class="header" href="#tcc_add_file">tcc_add_file</a></h2>
<p><code>tcc_add_file</code> 这个函数出现的位置是在 <code>libtcc.c</code> 中</p>
<p>在这里好像逻辑还好，就是判断了文件的类型，然后调用了  <code>tcc_add_file_internal</code> 方法，在 tcc_add_file_internal 中处理了不同的文件类型。</p>
<pre><code class="language-c">LIBTCCAPI int tcc_add_file(TCCState *s, const char *filename)
{
    printf("执行 tcc_add_file 这个方法,LIBTCCAPI 这个宏是啥意思? filename 当做了入参了\n");
    int filetype = s-&gt;filetype; // 文件类型：c 源文件，汇编文件或者其他的
    if (0 == (filetype &amp; AFF_TYPE_MASK)) {
        /* use a file extension to detect a filetype */
        const char *ext = tcc_fileextension(filename);
	    printf("获取 文件的后缀名..... %s\n", ext);
        if (ext[0]) {
            ext++;
            if (!strcmp(ext, "S")) filetype = AFF_TYPE_ASMPP; // PP是预处理吗
            else if (!strcmp(ext, "s")) filetype = AFF_TYPE_ASM;   // 汇编文件
            else if (!PATHCMP(ext, "c") || !PATHCMP(ext, "h") || !PATHCMP(ext, "i")) 
                filetype = AFF_TYPE_C;      // 源文件
            else filetype |= AFF_TYPE_BIN;  // 二进制的
        } else {
            filetype = AFF_TYPE_C;
        }
    }
    printf("准备调用 tcc_add_file_internal 方法了\n");
    return tcc_add_file_internal(s, filename, filetype | AFF_PRINT_ERROR);
}
</code></pre>
<h2 id="tcc_add_file_internal"><a class="header" href="#tcc_add_file_internal">tcc_add_file_internal</a></h2>
<p><code>tcc_add_file_internal</code> 这个文件还是在 libtcc.h 这个文件中</p>
<p>源码：</p>
<pre><code class="language-c">ST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags)
{
    int fd, ret = -1;

#if defined TARGETOS_OpenBSD &amp;&amp; !defined _WIN32
    printf("不知道这里定义的是啥.........\n");
    char buf[1024];
    if (tcc_glob_so(s1, filename, buf, sizeof buf) &gt;= 0)
        filename = buf;
#endif

    /* ignore binary files with -E */
    if (s1-&gt;output_type == TCC_OUTPUT_PREPROCESS &amp;&amp; (flags &amp; AFF_TYPE_BIN))
        return 0;

    /* open the file */
    printf("在 tcc_add_file_internal 中 使用  _tcc_open 打开文件 %s\n", filename);
    fd = _tcc_open(s1, filename);
    if (fd &lt; 0) {
        if (flags &amp; AFF_PRINT_ERROR)
            tcc_error_noabort("file '%s' not found", filename);
        return FILE_NOT_FOUND;
    }

    s1-&gt;current_filename = filename;
    if (flags &amp; AFF_TYPE_BIN) {
        ElfW(Ehdr) ehdr;
        int obj_type;

        obj_type = tcc_object_type(fd, &amp;ehdr);
        lseek(fd, 0, SEEK_SET);

        switch (obj_type) {

        case AFF_BINTYPE_REL:
            ret = tcc_load_object_file(s1, fd, 0);
            break;

        case AFF_BINTYPE_AR:
            ret = tcc_load_archive(s1, fd, !(flags &amp; AFF_WHOLE_ARCHIVE));
            break;

#ifdef TCC_TARGET_PE
        default:
            ret = pe_load_file(s1, fd, filename);
            goto check_success;

#elif defined TCC_TARGET_MACHO
        case AFF_BINTYPE_DYN:
        case_dyn_or_tbd:
            if (s1-&gt;output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
                void* dl;
                const char* soname = filename;
                if (obj_type != AFF_BINTYPE_DYN)
                    soname = macho_tbd_soname(filename);
                dl = dlopen(soname, RTLD_GLOBAL | RTLD_LAZY);
                if (dl)
                    tcc_add_dllref(s1, soname, 0)-&gt;handle = dl, ret = 0;
	        if (filename != soname)
		    tcc_free((void *)soname);
#endif
            } else if (obj_type == AFF_BINTYPE_DYN) {
                ret = macho_load_dll(s1, fd, filename, (flags &amp; AFF_REFERENCED_DLL) != 0);
            } else {
                ret = macho_load_tbd(s1, fd, filename, (flags &amp; AFF_REFERENCED_DLL) != 0);
            }
            goto check_success;
        default:
        {
            const char *ext = tcc_fileextension(filename);
            if (!strcmp(ext, ".tbd"))
                goto case_dyn_or_tbd;
            if (!strcmp(ext, ".dylib")) {
                obj_type = AFF_BINTYPE_DYN;
                goto case_dyn_or_tbd;
            }
            goto check_success;
        }

#else /* unix */
        case AFF_BINTYPE_DYN:
            if (s1-&gt;output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
                void* dl = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);
                if (dl)
                    tcc_add_dllref(s1, filename, 0)-&gt;handle = dl, ret = 0;
#endif
            } else
                ret = tcc_load_dll(s1, fd, filename, (flags &amp; AFF_REFERENCED_DLL) != 0);
            break;

        default:
            /* as GNU ld, consider it is an ld script if not recognized */
            ret = tcc_load_ldscript(s1, fd);
            goto check_success;

#endif /* pe / macos / unix */

check_success:
            if (ret &lt; 0)
                tcc_error_noabort("%s: unrecognized file type", filename);
            break;

#ifdef TCC_TARGET_COFF
        case AFF_BINTYPE_C67:
            ret = tcc_load_coff(s1, fd);
            break;
#endif
        }
        close(fd);
    } else {
        /* update target deps */
        dynarray_add(&amp;s1-&gt;target_deps, &amp;s1-&gt;nb_target_deps, tcc_strdup(filename));
	    printf("tcc_add_file_internal 感觉到了这里就是对文件进行编译了...... %s\n", filename);
        printf("flags 好像和文件类型有关\n");
        ret = tcc_compile(s1, flags, filename, fd);
    }
    s1-&gt;current_filename = NULL;
    return ret;
}
</code></pre>
<h2 id="tcc_glob_so"><a class="header" href="#tcc_glob_so">tcc_glob_so</a></h2>
<p>好像是有条件的</p>
<pre><code class="language-c">/* OpenBSD: choose latest from libxxx.so.x.y versions */
#if defined TARGETOS_OpenBSD &amp;&amp; !defined _WIN32
</code></pre>
<h2 id="dynarray_add"><a class="header" href="#dynarray_add">dynarray_add</a></h2>
<p>动态数组相关的</p>
<pre><code class="language-c">/********************************************************/
/* dynarrays */

ST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data)
{
    int nb, nb_alloc;
    void **pp;

    nb = *nb_ptr;
    pp = *(void ***)ptab;
    /* every power of two we double array size */
    if ((nb &amp; (nb - 1)) == 0) {
        if (!nb)
            nb_alloc = 1;
        else
            nb_alloc = nb * 2;
        pp = tcc_realloc(pp, nb_alloc * sizeof(void *));
        *(void***)ptab = pp;
    }
    pp[nb++] = data;
    *nb_ptr = nb;
}

ST_FUNC void dynarray_reset(void *pp, int *n)
{
    void **p;
    for (p = *(void***)pp; *n; ++p, --*n)
        if (*p)
            tcc_free(*p);
    tcc_free(*(void**)pp);
    *(void**)pp = NULL;
}

static void tcc_split_path(TCCState *s, void *p_ary, int *p_nb_ary, const char *in)
{
    const char *p;
    do {
        int c;
        CString str;

        cstr_new(&amp;str);
        for (p = in; c = *p, c != '\0' &amp;&amp; c != PATHSEP[0]; ++p) {
            if (c == '{' &amp;&amp; p[1] &amp;&amp; p[2] == '}') {
                c = p[1], p += 2;
                if (c == 'B')
                    cstr_cat(&amp;str, s-&gt;tcc_lib_path, -1);
                if (c == 'R')
                    cstr_cat(&amp;str, CONFIG_SYSROOT, -1);
                if (c == 'f' &amp;&amp; file) {
                    /* substitute current file's dir */
                    const char *f = file-&gt;true_filename;
                    const char *b = tcc_basename(f);
                    if (b &gt; f)
                        cstr_cat(&amp;str, f, b - f - 1);
                    else
                        cstr_cat(&amp;str, ".", 1);
                }
            } else {
                cstr_ccat(&amp;str, c);
            }
        }
        if (str.size) {
            cstr_ccat(&amp;str, '\0');
            dynarray_add(p_ary, p_nb_ary, tcc_strdup(str.data));
        }
        cstr_free(&amp;str);
        in = p+1;
    } while (*p);
}
</code></pre>
<h2 id="tcc_compile"><a class="header" href="#tcc_compile">tcc_compile</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st_func-的用法"><a class="header" href="#st_func-的用法">ST_FUNC 的用法</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>定义的位置是在 <code>tcc.h</code> 中，其实就是 static 关键字</p>
<pre><code>#if ONE_SOURCE
#define ST_INLN static inline
#define ST_FUNC static
#define ST_DATA static
#else
#define ST_INLN
#define ST_FUNC
#define ST_DATA extern
#endif

#ifdef TCC_PROFILE /* profile all functions */
# define static
# define inline
#endif
</code></pre>
<h2 id="作用"><a class="header" href="#作用">作用</a></h2>
<h2 id="出现的位置"><a class="header" href="#出现的位置">出现的位置</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="tcc_compile-1"><a class="header" href="#tcc_compile-1">tcc_compile</a></h1>
<h2 id="源码"><a class="header" href="#源码">源码</a></h2>
<pre><code class="language-c">/* compile the file opened in 'file'. Return non zero if errors. */
static int tcc_compile(TCCState *s1, int filetype, const char *str, int fd)
{
	printf("#### tcc_compile  compile the file opened in 'file'. Return non zero if errors. \n");
    /* Here we enter the code section where we use the global variables for
       parsing and code generation (tccpp.c, tccgen.c, &lt;target&gt;-gen.c).
       Other threads need to wait until we're done.

       Alternatively we could use thread local storage for those global
       variables, which may or may not have advantages */

    tcc_enter_state(s1);
    s1-&gt;error_set_jmp_enabled = 1;

    if (setjmp(s1-&gt;error_jmp_buf) == 0) {
        s1-&gt;nb_errors = 0;

        if (fd == -1) {
            int len = strlen(str);
            tcc_open_bf(s1, "&lt;string&gt;", len);
            memcpy(file-&gt;buffer, str, len);
        } else {
            tcc_open_bf(s1, str, 0);
            file-&gt;fd = fd;
        }

	    printf("#### tcc compile   preprocess_start........\n");
        preprocess_start(s1, filetype);
	    printf("#### tcc compile   tccgen_init........\n");
        tccgen_init(s1);

        if (s1-&gt;output_type == TCC_OUTPUT_PREPROCESS) {
		    printf("#### tcc compile   tcc_preprocess........\n");
            tcc_preprocess(s1);
        } else {
		    printf("#### tcc compile   tccelf_begin_file........\n");
            tccelf_begin_file(s1);
            if (filetype &amp; (AFF_TYPE_ASM | AFF_TYPE_ASMPP)) {
                tcc_assemble(s1, !!(filetype &amp; AFF_TYPE_ASMPP));
            } else {

		        printf("#### tcc compile   tccgen_compile........\n");
                tccgen_compile(s1);
            }
            tccelf_end_file(s1);
        }
    }
    tccgen_finish(s1);
    preprocess_end(s1);
    s1-&gt;error_set_jmp_enabled = 0;
    tcc_exit_state(s1);
    return s1-&gt;nb_errors != 0 ? -1 : 0;
}
</code></pre>
<h2 id="流程"><a class="header" href="#流程">流程</a></h2>
<p>预处理，代码生成，汇编，编译</p>
<h2 id="tcc_open_bf"><a class="header" href="#tcc_open_bf">tcc_open_bf</a></h2>
<h2 id="preprocess_start"><a class="header" href="#preprocess_start">preprocess_start</a></h2>
<h2 id="tccgen_init"><a class="header" href="#tccgen_init">tccgen_init</a></h2>
<h2 id="tcc_preprocess"><a class="header" href="#tcc_preprocess">tcc_preprocess</a></h2>
<h2 id="tccelf_begin_file"><a class="header" href="#tccelf_begin_file">tccelf_begin_file</a></h2>
<h2 id="tcc_assemble"><a class="header" href="#tcc_assemble">tcc_assemble</a></h2>
<h2 id="tccgen_compile"><a class="header" href="#tccgen_compile">tccgen_compile</a></h2>
<h2 id="tccelf_end_file"><a class="header" href="#tccelf_end_file">tccelf_end_file</a></h2>
<h2 id="tccelf_end_file-1"><a class="header" href="#tccelf_end_file-1">tccelf_end_file</a></h2>
<h2 id="tccgen_finish"><a class="header" href="#tccgen_finish">tccgen_finish</a></h2>
<h2 id="preprocess_end"><a class="header" href="#preprocess_end">preprocess_end</a></h2>
<h2 id="tcc_exit_state"><a class="header" href="#tcc_exit_state">tcc_exit_state</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcc_enter_state"><a class="header" href="#tcc_enter_state">tcc_enter_state</a></h1>
<h2 id="tcc_enter_state-1"><a class="header" href="#tcc_enter_state-1">tcc_enter_state</a></h2>
<pre><code class="language-c">PUB_FUNC void tcc_enter_state(TCCState *s1)
{
    if (s1-&gt;error_set_jmp_enabled)
        return;
    WAIT_SEM(&amp;tcc_compile_sem);
    tcc_state = s1;
}

PUB_FUNC void tcc_exit_state(TCCState *s1)
{
    if (s1-&gt;error_set_jmp_enabled)
        return;
    tcc_state = NULL;
    POST_SEM(&amp;tcc_compile_sem);
}
</code></pre>
<h2 id="tcc_exit_state-1"><a class="header" href="#tcc_exit_state-1">tcc_exit_state</a></h2>
<h2 id="wait_sem"><a class="header" href="#wait_sem">WAIT_SEM</a></h2>
<p>好像是加锁</p>
<pre><code class="language-c">/********************************************************/
#if CONFIG_TCC_SEMLOCK
#if defined _WIN32
typedef struct { int init; CRITICAL_SECTION cr; } TCCSem;
#elif defined __APPLE__
#include &lt;dispatch/dispatch.h&gt;
typedef struct { int init; dispatch_semaphore_t sem; } TCCSem;
#else
#include &lt;semaphore.h&gt;
typedef struct { int init; sem_t sem; } TCCSem;
#endif
ST_FUNC void wait_sem(TCCSem *p);
ST_FUNC void post_sem(TCCSem *p);
#define TCC_SEM(s) TCCSem s
#define WAIT_SEM wait_sem
#define POST_SEM post_sem
#else
#define TCC_SEM(s)
#define WAIT_SEM(p)
#define POST_SEM(p)
#endif
</code></pre>
<h2 id="tcc_compile_sem"><a class="header" href="#tcc_compile_sem">tcc_compile_sem</a></h2>
<pre><code class="language-c">/********************************************************/
/* global variables */

/* XXX: get rid of this ASAP (or maybe not) */
ST_DATA struct TCCState *tcc_state;
TCC_SEM(static tcc_compile_sem);
/* an array of pointers to memory to be free'd after errors */
ST_DATA void** stk_data;
ST_DATA int nb_stk_data;
</code></pre>
<h2 id="tcc_sem"><a class="header" href="#tcc_sem">TCC_SEM</a></h2>
<h2 id="tccsem"><a class="header" href="#tccsem">TCCSem</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocess_start-1"><a class="header" href="#preprocess_start-1">preprocess_start</a></h1>
<h2 id="源码-1"><a class="header" href="#源码-1">源码</a></h2>
<pre><code class="language-c">ST_FUNC void preprocess_start(TCCState *s1, int filetype)
{
    // 判断是否是汇编
    int is_asm = !!(filetype &amp; (AFF_TYPE_ASM|AFF_TYPE_ASMPP));

    tccpp_new(s1);

    // #include 栈指针， include_stack
    s1-&gt;include_stack_ptr = s1-&gt;include_stack;

    // ifdef 栈指针， ifdef 栈
    s1-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack;
    file-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack_ptr;
    pp_expr = 0;
    pp_counter = 0;
    pp_debug_tok = pp_debug_symv = 0;
    s1-&gt;pack_stack[0] = 0;
    s1-&gt;pack_stack_ptr = s1-&gt;pack_stack;

    set_idnum('$', !is_asm &amp;&amp; s1-&gt;dollars_in_identifiers ? IS_ID : 0);
    set_idnum('.', is_asm ? IS_ID : 0);

    if (!(filetype &amp; AFF_TYPE_ASM)) {
        CString cstr;
        cstr_new(&amp;cstr);
        tcc_predefs(s1, &amp;cstr, is_asm);
        if (s1-&gt;cmdline_defs.size)
          cstr_cat(&amp;cstr, s1-&gt;cmdline_defs.data, s1-&gt;cmdline_defs.size);
        if (s1-&gt;cmdline_incl.size)
          cstr_cat(&amp;cstr, s1-&gt;cmdline_incl.data, s1-&gt;cmdline_incl.size);
        //printf("%.*s\n", cstr.size, (char*)cstr.data);
        *s1-&gt;include_stack_ptr++ = file;
        tcc_open_bf(s1, "&lt;command line&gt;", cstr.size);
        memcpy(file-&gt;buffer, cstr.data, cstr.size);
        cstr_free(&amp;cstr);
    }
    parse_flags = is_asm ? PARSE_FLAG_ASM_FILE : 0;
}

## tccpp_new


## tcc_predefs

预定义的宏：

```c
static void tcc_predefs(TCCState *s1, CString *cs, int is_asm)
{
    cstr_printf(cs, "#define __TINYC__ 9%.2s\n", TCC_VERSION + 4);
    putdefs(cs, target_machine_defs);
    putdefs(cs, target_os_defs);

#ifdef TCC_TARGET_ARM
    if (s1-&gt;float_abi == ARM_HARD_FLOAT)
      putdef(cs, "__ARM_PCS_VFP");
#endif
    if (is_asm)
      putdef(cs, "__ASSEMBLER__");
    if (s1-&gt;output_type == TCC_OUTPUT_PREPROCESS)
      putdef(cs, "__TCC_PP__");
    if (s1-&gt;output_type == TCC_OUTPUT_MEMORY)
      putdef(cs, "__TCC_RUN__");
#ifdef CONFIG_TCC_BACKTRACE
    if (s1-&gt;do_backtrace)
      putdef(cs, "__TCC_BACKTRACE__");
#endif
#ifdef CONFIG_TCC_BCHECK
    if (s1-&gt;do_bounds_check)
      putdef(cs, "__TCC_BCHECK__");
#endif
    if (s1-&gt;char_is_unsigned)
      putdef(cs, "__CHAR_UNSIGNED__");
    if (s1-&gt;optimize &gt; 0)
      putdef(cs, "__OPTIMIZE__");
    if (s1-&gt;option_pthread)
      putdef(cs, "_REENTRANT");
    if (s1-&gt;leading_underscore)
      putdef(cs, "__leading_underscore");
    cstr_printf(cs, "#define __SIZEOF_POINTER__ %d\n", PTR_SIZE);
    cstr_printf(cs, "#define __SIZEOF_LONG__ %d\n", LONG_SIZE);
    if (!is_asm) {
      putdef(cs, "__STDC__");
      cstr_printf(cs, "#define __STDC_VERSION__ %dL\n", s1-&gt;cversion);
      cstr_cat(cs,
        /* load more predefs and __builtins */
#if CONFIG_TCC_PREDEFS
        #include "tccdefs_.h" /* include as strings */
#else
        "#include &lt;tccdefs.h&gt;\n" /* load at runtime */
#endif
        , -1);
    }
    cstr_printf(cs, "#define __BASE_FILE__ \"%s\"\n", file-&gt;filename);
}
</code></pre>
<h2 id="tcc_open_bf-1"><a class="header" href="#tcc_open_bf-1">tcc_open_bf</a></h2>
<p>好像是对每个文件都搞一个 buffer</p>
<pre><code class="language-c">ST_FUNC void tcc_open_bf(TCCState *s1, const char *filename, int initlen)
{
    BufferedFile *bf;
    int buflen = initlen ? initlen : IO_BUF_SIZE;

    bf = tcc_mallocz(sizeof(BufferedFile) + buflen);
    bf-&gt;buf_ptr = bf-&gt;buffer;
    bf-&gt;buf_end = bf-&gt;buffer + initlen;
    bf-&gt;buf_end[0] = CH_EOB; /* put eob symbol */
    pstrcpy(bf-&gt;filename, sizeof(bf-&gt;filename), filename);
#ifdef _WIN32
    normalize_slashes(bf-&gt;filename);
#endif
    bf-&gt;true_filename = bf-&gt;filename;
    bf-&gt;line_num = 1;
    bf-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack_ptr;
    bf-&gt;fd = -1;
    bf-&gt;prev = file;
    bf-&gt;prev_tok_flags = tok_flags;
    file = bf;
    tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="tccgen_init-1"><a class="header" href="#tccgen_init-1">tccgen_init</a></h1>
<h2 id="源码-2"><a class="header" href="#源码-2">源码</a></h2>
<pre><code class="language-c">/* ------------------------------------------------------------------------- */
/* initialize vstack and types.  This must be done also for tcc -E */
ST_FUNC void tccgen_init(TCCState *s1)
{
    vtop = vstack - 1;
    memset(vtop, 0, sizeof *vtop);

    /* define some often used types */
    int_type.t = VT_INT;

    char_type.t = VT_BYTE;
    if (s1-&gt;char_is_unsigned)
        char_type.t |= VT_UNSIGNED;
    char_pointer_type = char_type;
    mk_pointer(&amp;char_pointer_type);

    func_old_type.t = VT_FUNC;
    func_old_type.ref = sym_push(SYM_FIELD, &amp;int_type, 0, 0);
    func_old_type.ref-&gt;f.func_call = FUNC_CDECL;
    func_old_type.ref-&gt;f.func_type = FUNC_OLD;
#ifdef precedence_parser
    init_prec();
#endif
    cstr_new(&amp;initstr);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="next"><a class="header" href="#next">next</a></h1>
<h2 id="源码-3"><a class="header" href="#源码-3">源码</a></h2>
<pre><code class="language-c">/* return next token with macro substitution */
ST_FUNC void next(void)
{
    int t;
    while (macro_ptr) {
redo:
        t = *macro_ptr;
        if (TOK_HAS_VALUE(t)) {
            tok_get(&amp;tok, &amp;macro_ptr, &amp;tokc);
            if (t == TOK_LINENUM) {
                file-&gt;line_num = tokc.i;
                goto redo; // GOTO
            }
            goto convert;   // GOTO
        } else if (t == 0) {
            /* end of macro or unget token string */
            end_macro();
            continue;
        } else if (t == TOK_EOF) {
            /* do nothing */
        } else {
            ++macro_ptr;
            t &amp;= ~SYM_FIELD; /* remove 'nosubst' marker */
            if (t == '\\') {
                if (!(parse_flags &amp; PARSE_FLAG_ACCEPT_STRAYS))
                    tcc_error("stray '\\' in program");
            }
        }
        tok = t;
        return;
    }

    next_nomacro();
    t = tok;
    if (t &gt;= TOK_IDENT &amp;&amp; (parse_flags &amp; PARSE_FLAG_PREPROCESS)) {
        /* if reading from file, try to substitute macros */
        Sym *s = define_find(t);
        if (s) {
            Sym *nested_list = NULL;
            macro_subst_tok(&amp;tokstr_buf, &amp;nested_list, s);
            tok_str_add(&amp;tokstr_buf, 0);
            begin_macro(&amp;tokstr_buf, 0);
            goto redo;
        }
        return;
    }

convert:
    /* convert preprocessor tokens into C tokens */
    if (t == TOK_PPNUM) {
        if  (parse_flags &amp; PARSE_FLAG_TOK_NUM)
            parse_number(tokc.str.data);
    } else if (t == TOK_PPSTR) {
        if (parse_flags &amp; PARSE_FLAG_TOK_STR)
            parse_string(tokc.str.data, tokc.str.size - 1);
    }
}
</code></pre>
<h2 id="macro_ptr"><a class="header" href="#macro_ptr">macro_ptr</a></h2>
<pre><code class="language-c">ST_DATA struct BufferedFile *file;
ST_DATA int tok;
ST_DATA CValue tokc;
ST_DATA const int *macro_ptr;
ST_DATA int parse_flags;
ST_DATA int tok_flags;
ST_DATA CString tokcstr; /* current parsed string, if any */
</code></pre>
<p>全局变量，<code>macro_ptr</code> 是一个 int 类型的指针</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decl"><a class="header" href="#decl">decl</a></h1>
<h2 id="源码-4"><a class="header" href="#源码-4">源码</a></h2>
<pre><code class="language-c">/* 'l' is VT_LOCAL or VT_CONST to define default storage type
   or VT_CMP if parsing old style parameter list
   or VT_JMP if parsing c99 for decl: for (int i = 0, ...) */
static int decl(int l)
{
    int v, has_init, r, oldint;
    CType type, btype;
    Sym *sym;
    AttributeDef ad, adbase;

    while (1) {

        oldint = 0;
        if (!parse_btype(&amp;btype, &amp;adbase, l == VT_LOCAL)) {
            if (l == VT_JMP)
                return 0;
            /* skip redundant ';' if not in old parameter decl scope */
            if (tok == ';' &amp;&amp; l != VT_CMP) {
                next();
                continue;
            }
            if (tok == TOK_STATIC_ASSERT) {
                do_Static_assert();
                continue;
            }
            if (l != VT_CONST)
                break;
            if (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3) {
                /* global asm block */
                asm_global_instr();
                continue;
            }
            if (tok &gt;= TOK_UIDENT) {
               /* special test for old K&amp;R protos without explicit int
                  type. Only accepted when defining global data */
                btype.t = VT_INT;
                oldint = 1;
            } else {
                if (tok != TOK_EOF)
                    expect("declaration");
                break;
            }
        }

        if (tok == ';') {
	    if ((btype.t &amp; VT_BTYPE) == VT_STRUCT) {
		v = btype.ref-&gt;v;
		if (!(v &amp; SYM_FIELD) &amp;&amp; (v &amp; ~SYM_STRUCT) &gt;= SYM_FIRST_ANOM)
        	    tcc_warning("unnamed struct/union that defines no instances");
                next();
                continue;
	    }
            if (IS_ENUM(btype.t)) {
                next();
                continue;
            }
        }

        while (1) { /* iterate thru each declaration */
            type = btype;
	    ad = adbase;
            type_decl(&amp;type, &amp;ad, &amp;v, TYPE_DIRECT);
#if 0
            {
                char buf[500];
                type_to_str(buf, sizeof(buf), &amp;type, get_tok_str(v, NULL));
                printf("type = '%s'\n", buf);
            }
#endif
            if ((type.t &amp; VT_BTYPE) == VT_FUNC) {
                if ((type.t &amp; VT_STATIC) &amp;&amp; (l != VT_CONST))
                    tcc_error("function without file scope cannot be static");
                /* if old style function prototype, we accept a
                   declaration list */
                sym = type.ref;
                if (sym-&gt;f.func_type == FUNC_OLD &amp;&amp; l == VT_CONST) {
                    func_vt = type;
                    decl(VT_CMP);
                }
#if defined TCC_TARGET_MACHO || defined TARGETOS_ANDROID
                if (sym-&gt;f.func_alwinl
                    &amp;&amp; ((type.t &amp; (VT_EXTERN | VT_INLINE))
                        == (VT_EXTERN | VT_INLINE))) {
                    /* always_inline functions must be handled as if they
                       don't generate multiple global defs, even if extern
                       inline, i.e. GNU inline semantics for those.  Rewrite
                       them into static inline.  */
                    type.t &amp;= ~VT_EXTERN;
                    type.t |= VT_STATIC;
                }
#endif
                /* always compile 'extern inline' */
                if (type.t &amp; VT_EXTERN)
                    type.t &amp;= ~VT_INLINE;

            } else if (oldint) {
                tcc_warning("type defaults to int");
            }

            if (gnu_ext &amp;&amp; (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3)) {
                ad.asm_label = asm_label_instr();
                /* parse one last attribute list, after asm label */
                parse_attribute(&amp;ad);
            #if 0
                /* gcc does not allow __asm__("label") with function definition,
                   but why not ... */
                if (tok == '{')
                    expect(";");
            #endif
            }

#ifdef TCC_TARGET_PE
            if (ad.a.dllimport || ad.a.dllexport) {
                if (type.t &amp; VT_STATIC)
                    tcc_error("cannot have dll linkage with static");
                if (type.t &amp; VT_TYPEDEF) {
                    tcc_warning("'%s' attribute ignored for typedef",
                        ad.a.dllimport ? (ad.a.dllimport = 0, "dllimport") :
                        (ad.a.dllexport = 0, "dllexport"));
                } else if (ad.a.dllimport) {
                    if ((type.t &amp; VT_BTYPE) == VT_FUNC)
                        ad.a.dllimport = 0;
                    else
                        type.t |= VT_EXTERN;
                }
            }
#endif
            if (tok == '{') {
                if (l != VT_CONST)
                    tcc_error("cannot use local functions");
                if ((type.t &amp; VT_BTYPE) != VT_FUNC)
                    expect("function definition");

                /* reject abstract declarators in function definition
                   make old style params without decl have int type */
                sym = type.ref;
                while ((sym = sym-&gt;next) != NULL) {
                    if (!(sym-&gt;v &amp; ~SYM_FIELD))
                        expect("identifier");
                    if (sym-&gt;type.t == VT_VOID)
                        sym-&gt;type = int_type;
                }

                /* apply post-declaraton attributes */
                merge_funcattr(&amp;type.ref-&gt;f, &amp;ad.f);

                /* put function symbol */
                type.t &amp;= ~VT_EXTERN;
                sym = external_sym(v, &amp;type, 0, &amp;ad);

                /* static inline functions are just recorded as a kind
                   of macro. Their code will be emitted at the end of
                   the compilation unit only if they are used */
                if (sym-&gt;type.t &amp; VT_INLINE) {
                    struct InlineFunc *fn;
                    fn = tcc_malloc(sizeof *fn + strlen(file-&gt;filename));
                    strcpy(fn-&gt;filename, file-&gt;filename);
                    fn-&gt;sym = sym;
                    dynarray_add(&amp;tcc_state-&gt;inline_fns,
				 &amp;tcc_state-&gt;nb_inline_fns, fn);
                    skip_or_save_block(&amp;fn-&gt;func_str);
                } else {
                    /* compute text section */
                    cur_text_section = ad.section;
                    if (!cur_text_section)
                        cur_text_section = text_section;
                    gen_function(sym);
                }
                break;
            } else {
		if (l == VT_CMP) {
		    /* find parameter in function parameter list */
		    for (sym = func_vt.ref-&gt;next; sym; sym = sym-&gt;next)
			if ((sym-&gt;v &amp; ~SYM_FIELD) == v)
			    goto found;
		    tcc_error("declaration for parameter '%s' but no such parameter",
			      get_tok_str(v, NULL));
                found:
		    if (type.t &amp; VT_STORAGE) /* 'register' is okay */
		        tcc_error("storage class specified for '%s'",
				  get_tok_str(v, NULL));
		    if (sym-&gt;type.t != VT_VOID)
		        tcc_error("redefinition of parameter '%s'",
				  get_tok_str(v, NULL));
		    convert_parameter_type(&amp;type);
		    sym-&gt;type = type;
		} else if (type.t &amp; VT_TYPEDEF) {
                    /* save typedefed type  */
                    /* XXX: test storage specifiers ? */
                    sym = sym_find(v);
                    if (sym &amp;&amp; sym-&gt;sym_scope == local_scope) {
                        if (!is_compatible_types(&amp;sym-&gt;type, &amp;type)
                            || !(sym-&gt;type.t &amp; VT_TYPEDEF))
                            tcc_error("incompatible redefinition of '%s'",
                                get_tok_str(v, NULL));
                        sym-&gt;type = type;
                    } else {
                        sym = sym_push(v, &amp;type, 0, 0);
                    }
                    sym-&gt;a = ad.a;
                    if ((type.t &amp; VT_BTYPE) == VT_FUNC)
                      merge_funcattr(&amp;sym-&gt;type.ref-&gt;f, &amp;ad.f);
                    if (debug_modes)
                        tcc_debug_typedef (tcc_state, sym);
		} else if ((type.t &amp; VT_BTYPE) == VT_VOID
			   &amp;&amp; !(type.t &amp; VT_EXTERN)) {
		    tcc_error("declaration of void object");
                } else {
                    r = 0;
                    if ((type.t &amp; VT_BTYPE) == VT_FUNC) {
                        /* external function definition */
                        /* specific case for func_call attribute */
                        merge_funcattr(&amp;type.ref-&gt;f, &amp;ad.f);
                    } else if (!(type.t &amp; VT_ARRAY)) {
                        /* not lvalue if array */
                        r |= VT_LVAL;
                    }
                    has_init = (tok == '=');
                    if (has_init &amp;&amp; (type.t &amp; VT_VLA))
                        tcc_error("variable length array cannot be initialized");

                    if (((type.t &amp; VT_EXTERN) &amp;&amp; (!has_init || l != VT_CONST))
		        || (type.t &amp; VT_BTYPE) == VT_FUNC
                        /* as with GCC, uninitialized global arrays with no size
                           are considered extern: */
                        || ((type.t &amp; VT_ARRAY) &amp;&amp; !has_init
                            &amp;&amp; l == VT_CONST &amp;&amp; type.ref-&gt;c &lt; 0)
                        ) {
                        /* external variable or function */
                        type.t |= VT_EXTERN;
                        sym = external_sym(v, &amp;type, r, &amp;ad);
                    } else {
                        if (l == VT_CONST || (type.t &amp; VT_STATIC))
                            r |= VT_CONST;
                        else
                            r |= VT_LOCAL;
                        if (has_init)
                            next();
                        else if (l == VT_CONST)
                            /* uninitialized global variables may be overridden */
                            type.t |= VT_EXTERN;
                        decl_initializer_alloc(&amp;type, &amp;ad, r, has_init, v, l == VT_CONST);
                    }

                    if (ad.alias_target &amp;&amp; l == VT_CONST) {
                        /* Aliases need to be emitted when their target symbol
                           is emitted, even if perhaps unreferenced.
                           We only support the case where the base is already
                           defined, otherwise we would need deferring to emit
                           the aliases until the end of the compile unit.  */
                        Sym *alias_target = sym_find(ad.alias_target);
                        ElfSym *esym = elfsym(alias_target);
                        if (!esym)
                            tcc_error("unsupported forward __alias__ attribute");
                        put_extern_sym2(sym_find(v), esym-&gt;st_shndx,
                                        esym-&gt;st_value, esym-&gt;st_size, 1);
                    }
                }
                if (tok != ',') {
                    if (l == VT_JMP)
                        return 1;
                    skip(';');
                    break;
                }
                next();
            }
        }
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-value"><a class="header" href="#token-value">token value</a></h1>
<pre><code class="language-c">/* token values */

/* conditional ops */
#define TOK_LAND  0x90
#define TOK_LOR   0x91
/* warning: the following compare tokens depend on i386 asm code */
#define TOK_ULT 0x92
#define TOK_UGE 0x93
#define TOK_EQ  0x94
#define TOK_NE  0x95
#define TOK_ULE 0x96
#define TOK_UGT 0x97
#define TOK_Nset 0x98
#define TOK_Nclear 0x99
#define TOK_LT  0x9c
#define TOK_GE  0x9d
#define TOK_LE  0x9e
#define TOK_GT  0x9f

#define TOK_ISCOND(t) (t &gt;= TOK_LAND &amp;&amp; t &lt;= TOK_GT)

#define TOK_DEC     0x80 /* -- */
#define TOK_MID     0x81 /* inc/dec, to void constant */
#define TOK_INC     0x82 /* ++ */
#define TOK_UDIV    0x83 /* unsigned division */
#define TOK_UMOD    0x84 /* unsigned modulo */
#define TOK_PDIV    0x85 /* fast division with undefined rounding for pointers */
#define TOK_UMULL   0x86 /* unsigned 32x32 -&gt; 64 mul */
#define TOK_ADDC1   0x87 /* add with carry generation */
#define TOK_ADDC2   0x88 /* add with carry use */
#define TOK_SUBC1   0x89 /* add with carry generation */
#define TOK_SUBC2   0x8a /* add with carry use */
#define TOK_SHL     '&lt;' /* shift left */
#define TOK_SAR     '&gt;' /* signed shift right */
#define TOK_SHR     0x8b /* unsigned shift right */
#define TOK_NEG     TOK_MID /* unary minus operation (for floats) */

#define TOK_ARROW   0xa0 /* -&gt; */
#define TOK_DOTS    0xa1 /* three dots */
#define TOK_TWODOTS 0xa2 /* C++ token ? */
#define TOK_TWOSHARPS 0xa3 /* ## preprocessing token */
#define TOK_PLCHLDR 0xa4 /* placeholder token as defined in C99 */
#define TOK_PPJOIN  (TOK_TWOSHARPS | SYM_FIELD) /* A '##' in a macro to mean pasting */
#define TOK_SOTYPE  0xa7 /* alias of '(' for parsing sizeof (type) */

/* assignment operators */
#define TOK_A_ADD   0xb0
#define TOK_A_SUB   0xb1
#define TOK_A_MUL   0xb2
#define TOK_A_DIV   0xb3
#define TOK_A_MOD   0xb4
#define TOK_A_AND   0xb5
#define TOK_A_OR    0xb6
#define TOK_A_XOR   0xb7
#define TOK_A_SHL   0xb8
#define TOK_A_SAR   0xb9

#define TOK_ASSIGN(t) (t &gt;= TOK_A_ADD &amp;&amp; t &lt;= TOK_A_SAR)
#define TOK_ASSIGN_OP(t) ("+-*/%&amp;|^&lt;&gt;"[t - TOK_A_ADD])

/* tokens that carry values (in additional token string space / tokc) --&gt; */
#define TOK_CCHAR   0xc0 /* char constant in tokc */
#define TOK_LCHAR   0xc1
#define TOK_CINT    0xc2 /* number in tokc */
#define TOK_CUINT   0xc3 /* unsigned int constant */
#define TOK_CLLONG  0xc4 /* long long constant */
#define TOK_CULLONG 0xc5 /* unsigned long long constant */
#define TOK_CLONG   0xc6 /* long constant */
#define TOK_CULONG  0xc7 /* unsigned long constant */
#define TOK_STR     0xc8 /* pointer to string in tokc */
#define TOK_LSTR    0xc9
#define TOK_CFLOAT  0xca /* float constant */
#define TOK_CDOUBLE 0xcb /* double constant */
#define TOK_CLDOUBLE 0xcc /* long double constant */
#define TOK_PPNUM   0xcd /* preprocessor number */
#define TOK_PPSTR   0xce /* preprocessor string */
#define TOK_LINENUM 0xcf /* line number info */

#define TOK_HAS_VALUE(t) (t &gt;= TOK_CCHAR &amp;&amp; t &lt;= TOK_LINENUM)

#define TOK_EOF       (-1)  /* end of file */
#define TOK_LINEFEED  10    /* line feed */

/* all identifiers and strings have token above that */
#define TOK_IDENT 256

enum tcc_token {
    TOK_LAST = TOK_IDENT - 1
#define DEF(id, str) ,id
#include "tcctok.h"
#undef DEF
};

/* keywords: tok &gt;= TOK_IDENT &amp;&amp; tok &lt; TOK_UIDENT */
#define TOK_UIDENT TOK_DEFINE
</code></pre>
<h2 id="tok_has_value"><a class="header" href="#tok_has_value">TOK_HAS_VALUE</a></h2>
<pre><code class="language-c">#define TOK_HAS_VALUE(t) (t &gt;= TOK_CCHAR &amp;&amp; t &lt;= TOK_LINENUM)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="next_nomacro"><a class="header" href="#next_nomacro">next_nomacro</a></h1>
<h2 id="源码-5"><a class="header" href="#源码-5">源码</a></h2>
<p>原来词法分析搁这儿呢</p>
<p>返回没有宏替换的 token 是啥意思？</p>
<pre><code class="language-c">/* return next token without macro substitution */
static void next_nomacro(void)
{
    int t, c, is_long, len;
    TokenSym *ts;
    uint8_t *p, *p1;
    unsigned int h;

    p = file-&gt;buf_ptr; // buffer 的指针
 redo_no_start:
    c = *p; // 获取第一个字符
    switch(c) {
    case ' ':
    case '\t':
        tok = c;
        p++;
 maybe_space:
        if (parse_flags &amp; PARSE_FLAG_SPACES)
            goto keep_tok_flags;
        while (isidnum_table[*p - CH_EOF] &amp; IS_SPC)
            ++p;
        goto redo_no_start;
    case '\f':
    case '\v':
    case '\r':
        p++;
        goto redo_no_start;
    case '\\':
        /* first look if it is in fact an end of buffer */
        c = handle_stray(&amp;p);
        if (c == '\\')
            goto parse_simple;
        if (c == CH_EOF) {
            TCCState *s1 = tcc_state;
            if (!(tok_flags &amp; TOK_FLAG_BOL)) {
                /* add implicit newline */
                goto maybe_newline;
            } else if (!(parse_flags &amp; PARSE_FLAG_PREPROCESS)) {
                tok = TOK_EOF;
            } else if (s1-&gt;ifdef_stack_ptr != file-&gt;ifdef_stack_ptr) {
                tcc_error("missing #endif");
            } else if (s1-&gt;include_stack_ptr == s1-&gt;include_stack) {
                /* no include left : end of file. */
                tok = TOK_EOF;
            } else {
                /* pop include file */

                /* test if previous '#endif' was after a #ifdef at
                   start of file */
                if (tok_flags &amp; TOK_FLAG_ENDIF) {
#ifdef INC_DEBUG
                    printf("#endif %s\n", get_tok_str(file-&gt;ifndef_macro_saved, NULL));
#endif
                    search_cached_include(s1, file-&gt;true_filename, 1)
                        -&gt;ifndef_macro = file-&gt;ifndef_macro_saved;
                    tok_flags &amp;= ~TOK_FLAG_ENDIF;
                }

                /* add end of include file debug info */
                tcc_debug_eincl(tcc_state);
                /* pop include stack */
                tcc_close();
                s1-&gt;include_stack_ptr--;
                p = file-&gt;buf_ptr;
                goto maybe_newline;
            }
        } else {
            goto redo_no_start;
        }
        break;

    case '\n':
        file-&gt;line_num++;
        p++;
maybe_newline:
        tok_flags |= TOK_FLAG_BOL;
        if (0 == (parse_flags &amp; PARSE_FLAG_LINEFEED))
            goto redo_no_start;
        tok = TOK_LINEFEED;
        goto keep_tok_flags;

    case '#':
        /* XXX: simplify */
        PEEKC(c, p);
        if ((tok_flags &amp; TOK_FLAG_BOL) &amp;&amp; 
            (parse_flags &amp; PARSE_FLAG_PREPROCESS)) {
            tok_flags &amp;= ~TOK_FLAG_BOL;
            file-&gt;buf_ptr = p;
            preprocess(tok_flags &amp; TOK_FLAG_BOF);
            p = file-&gt;buf_ptr;
            goto maybe_newline;
        } else {
            if (c == '#') {
                p++;
                tok = TOK_TWOSHARPS;
            } else {
#if !defined(TCC_TARGET_ARM)
                if (parse_flags &amp; PARSE_FLAG_ASM_FILE) {
                    p = parse_line_comment(p - 1);
                    goto redo_no_start;
                } else
#endif
                {
                    tok = '#';
                }
            }
        }
        break;
    
    /* dollar is allowed to start identifiers when not parsing asm */
    case '$':
        if (!(isidnum_table['$' - CH_EOF] &amp; IS_ID)
         || (parse_flags &amp; PARSE_FLAG_ASM_FILE))
            goto parse_simple;

    case 'a': case 'b': case 'c': case 'd':
    case 'e': case 'f': case 'g': case 'h':
    case 'i': case 'j': case 'k': case 'l':
    case 'm': case 'n': case 'o': case 'p':
    case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x':
    case 'y': case 'z': 
    case 'A': case 'B': case 'C': case 'D':
    case 'E': case 'F': case 'G': case 'H':
    case 'I': case 'J': case 'K': 
    case 'M': case 'N': case 'O': case 'P':
    case 'Q': case 'R': case 'S': case 'T':
    case 'U': case 'V': case 'W': case 'X':
    case 'Y': case 'Z': 
    case '_':
    parse_ident_fast:
        p1 = p;
        h = TOK_HASH_INIT;
        h = TOK_HASH_FUNC(h, c);
        while (c = *++p, isidnum_table[c - CH_EOF] &amp; (IS_ID|IS_NUM))
            h = TOK_HASH_FUNC(h, c);
        len = p - p1;
        if (c != '\\') {
            TokenSym **pts;

            /* fast case : no stray found, so we have the full token
               and we have already hashed it */
            h &amp;= (TOK_HASH_SIZE - 1);
            pts = &amp;hash_ident[h];
            for(;;) {
                ts = *pts;
                if (!ts)
                    break;
                if (ts-&gt;len == len &amp;&amp; !memcmp(ts-&gt;str, p1, len))
                    goto token_found;
                pts = &amp;(ts-&gt;hash_next);
            }
            ts = tok_alloc_new(pts, (char *) p1, len);
        token_found: ;
        } else {
            /* slower case */
            cstr_reset(&amp;tokcstr);
            cstr_cat(&amp;tokcstr, (char *) p1, len);
            p--;
            PEEKC(c, p);
        parse_ident_slow:
            while (isidnum_table[c - CH_EOF] &amp; (IS_ID|IS_NUM))
            {
                cstr_ccat(&amp;tokcstr, c);
                PEEKC(c, p);
            }
            ts = tok_alloc(tokcstr.data, tokcstr.size);
        }
        tok = ts-&gt;tok;
        break;
    case 'L':
        t = p[1];
        if (t != '\\' &amp;&amp; t != '\'' &amp;&amp; t != '\"') {
            /* fast case */
            goto parse_ident_fast;
        } else {
            PEEKC(c, p);
            if (c == '\'' || c == '\"') {
                is_long = 1;
                goto str_const;
            } else {
                cstr_reset(&amp;tokcstr);
                cstr_ccat(&amp;tokcstr, 'L');
                goto parse_ident_slow;
            }
        }
        break;

    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
    case '8': case '9':
        t = c;
        PEEKC(c, p);
        /* after the first digit, accept digits, alpha, '.' or sign if
           prefixed by 'eEpP' */
    parse_num:
        cstr_reset(&amp;tokcstr);
        for(;;) {
            cstr_ccat(&amp;tokcstr, t);
            if (!((isidnum_table[c - CH_EOF] &amp; (IS_ID|IS_NUM))
                  || c == '.'
                  || ((c == '+' || c == '-')
                      &amp;&amp; (((t == 'e' || t == 'E')
                            &amp;&amp; !(parse_flags &amp; PARSE_FLAG_ASM_FILE
                                /* 0xe+1 is 3 tokens in asm */
                                &amp;&amp; ((char*)tokcstr.data)[0] == '0'
                                &amp;&amp; toup(((char*)tokcstr.data)[1]) == 'X'))
                          || t == 'p' || t == 'P'))))
                break;
            t = c;
            PEEKC(c, p);
        }
        /* We add a trailing '\0' to ease parsing */
        cstr_ccat(&amp;tokcstr, '\0');
        tokc.str.size = tokcstr.size;
        tokc.str.data = tokcstr.data;
        tok = TOK_PPNUM;
        break;

    case '.':
        /* special dot handling because it can also start a number */
        PEEKC(c, p);
        if (isnum(c)) {
            t = '.';
            goto parse_num;
        } else if ((isidnum_table['.' - CH_EOF] &amp; IS_ID)
                   &amp;&amp; (isidnum_table[c - CH_EOF] &amp; (IS_ID|IS_NUM))) {
            *--p = c = '.';
            goto parse_ident_fast;
        } else if (c == '.') {
            PEEKC(c, p);
            if (c == '.') {
                p++;
                tok = TOK_DOTS;
            } else {
                *--p = '.'; /* may underflow into file-&gt;unget[] */
                tok = '.';
            }
        } else {
            tok = '.';
        }
        break;
    case '\'':
    case '\"':
        is_long = 0;
    str_const:
        cstr_reset(&amp;tokcstr);
        if (is_long)
            cstr_ccat(&amp;tokcstr, 'L');
        cstr_ccat(&amp;tokcstr, c);
        p = parse_pp_string(p, c, &amp;tokcstr);
        cstr_ccat(&amp;tokcstr, c);
        cstr_ccat(&amp;tokcstr, '\0');
        tokc.str.size = tokcstr.size;
        tokc.str.data = tokcstr.data;
        tok = TOK_PPSTR;
        break;

    case '&lt;':
        PEEKC(c, p);
        if (c == '=') {
            p++;
            tok = TOK_LE;
        } else if (c == '&lt;') {
            PEEKC(c, p);
            if (c == '=') {
                p++;
                tok = TOK_A_SHL;
            } else {
                tok = TOK_SHL;
            }
        } else {
            tok = TOK_LT;
        }
        break;
    case '&gt;':
        PEEKC(c, p);
        if (c == '=') {
            p++;
            tok = TOK_GE;
        } else if (c == '&gt;') {
            PEEKC(c, p);
            if (c == '=') {
                p++;
                tok = TOK_A_SAR;
            } else {
                tok = TOK_SAR;
            }
        } else {
            tok = TOK_GT;
        }
        break;
        
    case '&amp;':
        PEEKC(c, p);
        if (c == '&amp;') {
            p++;
            tok = TOK_LAND;
        } else if (c == '=') {
            p++;
            tok = TOK_A_AND;
        } else {
            tok = '&amp;';
        }
        break;
        
    case '|':
        PEEKC(c, p);
        if (c == '|') {
            p++;
            tok = TOK_LOR;
        } else if (c == '=') {
            p++;
            tok = TOK_A_OR;
        } else {
            tok = '|';
        }
        break;

    case '+':
        PEEKC(c, p);
        if (c == '+') {
            p++;
            tok = TOK_INC;
        } else if (c == '=') {
            p++;
            tok = TOK_A_ADD;
        } else {
            tok = '+';
        }
        break;
        
    case '-':
        PEEKC(c, p);
        if (c == '-') {
            p++;
            tok = TOK_DEC;
        } else if (c == '=') {
            p++;
            tok = TOK_A_SUB;
        } else if (c == '&gt;') {
            p++;
            tok = TOK_ARROW;
        } else {
            tok = '-';
        }
        break;

    PARSE2('!', '!', '=', TOK_NE)
    PARSE2('=', '=', '=', TOK_EQ)
    PARSE2('*', '*', '=', TOK_A_MUL)
    PARSE2('%', '%', '=', TOK_A_MOD)
    PARSE2('^', '^', '=', TOK_A_XOR)
        
        /* comments or operator */
    case '/':
        PEEKC(c, p);
        if (c == '*') {
            p = parse_comment(p);
            /* comments replaced by a blank */
            tok = ' ';
            goto maybe_space;
        } else if (c == '/') {
            p = parse_line_comment(p);
            tok = ' ';
            goto maybe_space;
        } else if (c == '=') {
            p++;
            tok = TOK_A_DIV;
        } else {
            tok = '/';
        }
        break;
        
        /* simple tokens */
    case '(':
    case ')':
    case '[':
    case ']':
    case '{':
    case '}':
    case ',':
    case ';':
    case ':':
    case '?':
    case '~':
    case '@': /* only used in assembler */
    parse_simple:
        tok = c;
        p++;
        break;
    default:
        if (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF) /* utf8 identifiers */
	    goto parse_ident_fast;
        if (parse_flags &amp; PARSE_FLAG_ASM_FILE)
            goto parse_simple;
        tcc_error("unrecognized character \\x%02x", c);
        break;
    }
    tok_flags = 0;
keep_tok_flags:
    file-&gt;buf_ptr = p;
#if defined(PARSE_DEBUG)
    printf("token = %d %s\n", tok, get_tok_str(tok, &amp;tokc));
#endif
}
</code></pre>
<h2 id="parse_flags-的定义"><a class="header" href="#parse_flags-的定义">parse_flags 的定义</a></h2>
<pre><code class="language-c">/* ------------ tccpp.c ------------ */

ST_DATA struct BufferedFile *file;
ST_DATA int tok;
ST_DATA CValue tokc;
ST_DATA const int *macro_ptr;
ST_DATA int parse_flags;
ST_DATA int tok_flags;
ST_DATA CString tokcstr; /* current parsed string, if any */
</code></pre>
<h2 id="parse_flag_spaces"><a class="header" href="#parse_flag_spaces">PARSE_FLAG_SPACES</a></h2>
<pre><code class="language-c">#define TOK_FLAG_BOL   0x0001 /* beginning of line before */
#define TOK_FLAG_BOF   0x0002 /* beginning of file before */
#define TOK_FLAG_ENDIF 0x0004 /* a endif was found matching starting #ifdef */

#define PARSE_FLAG_PREPROCESS 0x0001 /* activate preprocessing */
#define PARSE_FLAG_TOK_NUM    0x0002 /* return numbers instead of TOK_PPNUM */
#define PARSE_FLAG_LINEFEED   0x0004 /* line feed is returned as a
                                        token. line feed is also
                                        returned at eof */
#define PARSE_FLAG_ASM_FILE 0x0008 /* we processing an asm file: '#' can be used for line comment, etc. */
#define PARSE_FLAG_SPACES     0x0010 /* next() returns space tokens (for -E) */
#define PARSE_FLAG_ACCEPT_STRAYS 0x0020 /* next() returns '\\' token */
#define PARSE_FLAG_TOK_STR    0x0040 /* return parsed strings instead of TOK_PPSTR */
</code></pre>
<h2 id="ch_eof"><a class="header" href="#ch_eof">CH_EOF</a></h2>
<pre><code class="language-c">#define CH_EOB   '\\'       /* end of buffer or '\0' char in file */
#define CH_EOF   (-1)   /* end of file */
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="table_ident"><a class="header" href="#table_ident">table_ident</a></h1>
<pre><code class="language-c">/* display benchmark infos */
ST_DATA int tok_ident;
ST_DATA TokenSym **table_ident;
ST_DATA int pp_expr;
</code></pre>
<p>这又是一个全局变量了</p>
<pre><code class="language-c">/* allocate a new token */
static TokenSym *tok_alloc_new(TokenSym **pts, const char *str, int len)
{
    TokenSym *ts, **ptable;
    int i;

    if (tok_ident &gt;= SYM_FIRST_ANOM) 
        tcc_error("memory full (symbols)");

    /* expand token table if needed */
    // i 是符号的索引
    i = tok_ident - TOK_IDENT;
    // table_ident 为空或者刚好满了就继续分配
    if ((i % TOK_ALLOC_INCR) == 0) {
        ptable = tcc_realloc(table_ident, (i + TOK_ALLOC_INCR) * sizeof(TokenSym *));
        table_ident = ptable;
    }

    ts = tal_realloc(toksym_alloc, 0, sizeof(TokenSym) + len);
    table_ident[i] = ts;
    ts-&gt;tok = tok_ident++;
    ts-&gt;sym_define = NULL;
    ts-&gt;sym_label = NULL;
    ts-&gt;sym_struct = NULL;
    ts-&gt;sym_identifier = NULL;
    ts-&gt;len = len;
    ts-&gt;hash_next = NULL;
    memcpy(ts-&gt;str, str, len);
    ts-&gt;str[len] = '\0';
    *pts = ts;
    return ts;
}
</code></pre>
<h2 id="tok_alloc_incr"><a class="header" href="#tok_alloc_incr">TOK_ALLOC_INCR</a></h2>
<pre><code class="language-c">#define TOK_ALLOC_INCR      512  /* must be a power of two */
</code></pre>
<pre><code class="language-c">
/* -------------------------------------------- */

#define INCLUDE_STACK_SIZE  32
#define IFDEF_STACK_SIZE    64
#define VSTACK_SIZE         512
#define STRING_MAX_SIZE     1024
#define TOKSTR_MAX_SIZE     256
#define PACK_STACK_SIZE     8

#define TOK_HASH_SIZE       16384 /* must be a power of two */
#define TOK_ALLOC_INCR      512  /* must be a power of two */
#define TOK_MAX_SIZE        4 /* token max size in int unit when stored in string */
</code></pre>
<h2 id="tok_ident"><a class="header" href="#tok_ident">TOK_IDENT</a></h2>
<p>哦，所以说 TOK_IDENT 是一种类型咯，所有的标识符和字符串的 token 都是 TOK_IDENT</p>
<pre><code class="language-c">/* all identifiers and strings have token above that */
#define TOK_IDENT 256
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="没看懂-tinycc-中的--current-value-是什么意思"><a class="header" href="#没看懂-tinycc-中的--current-value-是什么意思">没看懂 tinycc 中的  current value 是什么意思？</a></h1>
<pre><code class="language-c">/* The current value can be: */
#define VT_VALMASK   0x003f  /* mask for value location, register or: */
#define VT_CONST     0x0030  /* constant in vc (must be first non register value) */
#define VT_LLOCAL    0x0031  /* lvalue, offset on stack */
#define VT_LOCAL     0x0032  /* offset on stack */
#define VT_CMP       0x0033  /* the value is stored in processor flags (in vc) */
#define VT_JMP       0x0034  /* value is the consequence of jmp true (even) */
#define VT_JMPI      0x0035  /* value is the consequence of jmp false (odd) */
#define VT_LVAL      0x0100  /* var is an lvalue */
#define VT_SYM       0x0200  /* a symbol value is added */
#define VT_MUSTCAST  0x0C00  /* value must be casted to be correct (used for
                                char/short stored in integer registers) */
#define VT_NONCONST  0x1000  /* VT_CONST, but not an (C standard) integer
                                constant expression */
#define VT_MUSTBOUND 0x4000  /* bound checking must be done before
                                dereferencing value */
#define VT_BOUNDED   0x8000  /* value is bounded. The address of the
                                bounding function call point is in vc */
/* types */
#define VT_BTYPE       0x000f  /* mask for basic type */
#define VT_VOID             0  /* void type */
#define VT_BYTE             1  /* signed byte type */
#define VT_SHORT            2  /* short type */
#define VT_INT              3  /* integer type */
#define VT_LLONG            4  /* 64 bit integer */
#define VT_PTR              5  /* pointer */
#define VT_FUNC             6  /* function type */
#define VT_STRUCT           7  /* struct/union definition */
#define VT_FLOAT            8  /* IEEE float */
#define VT_DOUBLE           9  /* IEEE double */
#define VT_LDOUBLE         10  /* IEEE long double */
#define VT_BOOL            11  /* ISOC99 boolean type */
#define VT_QLONG           13  /* 128-bit integer. Only used for x86-64 ABI */
#define VT_QFLOAT          14  /* 128-bit float. Only used for x86-64 ABI */

#define VT_UNSIGNED    0x0010  /* unsigned type */
#define VT_DEFSIGN     0x0020  /* explicitly signed or unsigned */
#define VT_ARRAY       0x0040  /* array type (also has VT_PTR) */
#define VT_BITFIELD    0x0080  /* bitfield modifier */
#define VT_CONSTANT    0x0100  /* const modifier */
#define VT_VOLATILE    0x0200  /* volatile modifier */
#define VT_VLA         0x0400  /* VLA type (also has VT_PTR and VT_ARRAY) */
#define VT_LONG        0x0800  /* long type (also has VT_INT rsp. VT_LLONG) */

/* storage */
#define VT_EXTERN  0x00001000  /* extern definition */
#define VT_STATIC  0x00002000  /* static variable */
#define VT_TYPEDEF 0x00004000  /* typedef definition */
#define VT_INLINE  0x00008000  /* inline definition */
/* currently unused: 0x000[1248]0000  */

#define VT_STRUCT_SHIFT 20     /* shift for bitfield shift values (32 - 2*6) */
#define VT_STRUCT_MASK (((1U &lt;&lt; (6+6)) - 1) &lt;&lt; VT_STRUCT_SHIFT | VT_BITFIELD)
#define BIT_POS(t) (((t) &gt;&gt; VT_STRUCT_SHIFT) &amp; 0x3f)
#define BIT_SIZE(t) (((t) &gt;&gt; (VT_STRUCT_SHIFT + 6)) &amp; 0x3f)

#define VT_UNION    (1 &lt;&lt; VT_STRUCT_SHIFT | VT_STRUCT)
#define VT_ENUM     (2 &lt;&lt; VT_STRUCT_SHIFT) /* integral type is an enum really */
#define VT_ENUM_VAL (3 &lt;&lt; VT_STRUCT_SHIFT) /* integral type is an enum constant really */

#define IS_ENUM(t) ((t &amp; VT_STRUCT_MASK) == VT_ENUM)
#define IS_ENUM_VAL(t) ((t &amp; VT_STRUCT_MASK) == VT_ENUM_VAL)
#define IS_UNION(t) ((t &amp; (VT_STRUCT_MASK|VT_BTYPE)) == VT_UNION)

#define VT_ATOMIC   VT_VOLATILE

/* type mask (except storage) */
#define VT_STORAGE (VT_EXTERN | VT_STATIC | VT_TYPEDEF | VT_INLINE)
#define VT_TYPE (~(VT_STORAGE|VT_STRUCT_MASK))

/* symbol was created by tccasm.c first */
#define VT_ASM (VT_VOID | 1 &lt;&lt; VT_STRUCT_SHIFT)
#define VT_ASM_FUNC (VT_ASM | 2 &lt;&lt; VT_STRUCT_SHIFT)
#define IS_ASM_SYM(sym) (((sym)-&gt;type.t &amp; (VT_BTYPE | VT_ASM)) == VT_ASM)

/* general: set/get the pseudo-bitfield value for bit-mask M */
#define BFVAL(M,N) ((unsigned)((M) &amp; ~((M) &lt;&lt; 1)) * (N))
#define BFGET(X,M) (((X) &amp; (M)) / BFVAL(M,1))
#define BFSET(X,M,N) ((X) = ((X) &amp; ~(M)) | BFVAL(M,N))
</code></pre>
<p>在 <code>TinyCC</code> 中，<code>current value</code> 是用于表示编译过程中一个表达式或变量的<strong>存储位置</strong>或者<strong>计算结果</strong>的具体状态。在表达式计算和代码生成过程中，编译器需要跟踪每个值的当前状态，以便知道它是保存在寄存器、栈、常量池，还是需要进行某种处理，比如跳转（<code>jmp</code>）或者符号引用（<code>symbol reference</code>）等。这个机制通过一系列的宏定义和位标志来实现，这些宏定义了值在编译器内部的各种状态。</p>
<p><code>current value</code> 的概念可以理解为在编译过程中一个值的<strong>具体位置或类型</strong>，编译器会根据这个信息来生成合适的代码。</p>
<h3 id="宏的解释"><a class="header" href="#宏的解释">宏的解释</a></h3>
<p>这些宏定义用于标记 <code>TinyCC</code> 编译器中的值类型和状态。它们被组合使用，编码了当前值在不同阶段的状态和位置。让我们逐一解释这些标志。</p>
<h4 id="1-vt_valmask"><a class="header" href="#1-vt_valmask">1. <code>VT_VALMASK</code></a></h4>
<pre><code class="language-c">#define VT_VALMASK  0x003f
</code></pre>
<ul>
<li>这是一个掩码，用于提取值的位置或类型信息。通过 <code>VT_VALMASK</code>，可以获得值在处理器中的具体位置或类型，比如是否是常量、局部变量等。</li>
</ul>
<h4 id="2-vt_const"><a class="header" href="#2-vt_const">2. <code>VT_CONST</code></a></h4>
<pre><code class="language-c">#define VT_CONST  0x0030
</code></pre>
<ul>
<li>表示一个<strong>常量</strong>值。常量存储在变量 <code>vc</code> 中，表示不需要从内存或寄存器读取的值，直接使用它的常量即可。</li>
</ul>
<h4 id="3-vt_llocal"><a class="header" href="#3-vt_llocal">3. <code>VT_LLOCAL</code></a></h4>
<pre><code class="language-c">#define VT_LLOCAL  0x0031
</code></pre>
<ul>
<li>表示一个<strong>左值</strong>（<code>lvalue</code>），并且它的值是位于栈上的<strong>局部变量</strong>。左值意味着可以对这个值进行赋值操作。</li>
</ul>
<h4 id="4-vt_local"><a class="header" href="#4-vt_local">4. <code>VT_LOCAL</code></a></h4>
<pre><code class="language-c">#define VT_LOCAL  0x0032
</code></pre>
<ul>
<li>表示一个局部变量的<strong>偏移量</strong>，它位于栈上。这个宏和 <code>VT_LLOCAL</code> 相似，但表示的是一个<strong>右值</strong>（<code>rvalue</code>），即一个可以被读取但不能直接赋值的值。</li>
</ul>
<h4 id="5-vt_cmp"><a class="header" href="#5-vt_cmp">5. <code>VT_CMP</code></a></h4>
<pre><code class="language-c">#define VT_CMP  0x0033
</code></pre>
<ul>
<li>表示比较操作的结果存储在<strong>处理器的标志位</strong>（flags）中。例如，在 x86 架构上，比较操作的结果会被存储在 <code>EFLAGS</code> 寄存器中，这个标志告诉后续代码生成如何利用这些标志位执行条件跳转。</li>
</ul>
<h4 id="6-vt_jmp-和-vt_jmpi"><a class="header" href="#6-vt_jmp-和-vt_jmpi">6. <code>VT_JMP</code> 和 <code>VT_JMPI</code></a></h4>
<pre><code class="language-c">#define VT_JMP  0x0034
#define VT_JMPI  0x0035
</code></pre>
<ul>
<li><code>VT_JMP</code> 表示一个值依赖于条件跳转的结果（比如 <code>if</code> 语句的 <code>true</code> 分支）。</li>
<li><code>VT_JMPI</code> 表示跳转结果是 <code>false</code>（<code>false</code> 分支的跳转）。</li>
</ul>
<p>这两个宏主要用于跟踪条件跳转指令的结果。</p>
<h4 id="7-vt_lval"><a class="header" href="#7-vt_lval">7. <code>VT_LVAL</code></a></h4>
<pre><code class="language-c">#define VT_LVAL  0x0100
</code></pre>
<ul>
<li>表示当前的值是一个<strong>左值</strong>（<code>lvalue</code>），即可以被赋值的变量或表达式。编译器在遇到赋值操作时会检查这个标志，以确认是否允许对当前值进行修改。</li>
</ul>
<h4 id="8-vt_sym"><a class="header" href="#8-vt_sym">8. <code>VT_SYM</code></a></h4>
<pre><code class="language-c">#define VT_SYM  0x0200
</code></pre>
<ul>
<li>表示当前的值是<strong>符号引用</strong>。符号可以是全局变量、函数名、或者其他在编译期间需要解析的标识符。</li>
</ul>
<h4 id="9-vt_mustcast"><a class="header" href="#9-vt_mustcast">9. <code>VT_MUSTCAST</code></a></h4>
<pre><code class="language-c">#define VT_MUSTCAST  0x0C00
</code></pre>
<ul>
<li>表示当前的值<strong>必须进行类型转换</strong>。这通常发生在小范围类型（如 <code>char</code> 或 <code>short</code>）存储在更大范围的寄存器中（如 <code>int</code> 类型时）。为了确保表达式的类型一致性，在生成代码前，编译器必须对这些值进行强制类型转换。</li>
</ul>
<h4 id="10-vt_nonconst"><a class="header" href="#10-vt_nonconst">10. <code>VT_NONCONST</code></a></h4>
<pre><code class="language-c">#define VT_NONCONST  0x1000
</code></pre>
<ul>
<li>表示当前的常量并不是一个 C 标准定义的<strong>整数常量表达式</strong>，例如它可能是一个浮点常量或其他非常量类型。这个标志有助于编译器在某些语法规则中区分不同类型的常量。</li>
</ul>
<h4 id="11-vt_mustbound"><a class="header" href="#11-vt_mustbound">11. <code>VT_MUSTBOUND</code></a></h4>
<pre><code class="language-c">#define VT_MUSTBOUND  0x4000
</code></pre>
<ul>
<li>表示在解引用值之前，必须进行<strong>边界检查</strong>。这通常用于编译器生成代码时的内存安全检查，确保指针解引用时不会越界。</li>
</ul>
<h4 id="12-vt_bounded"><a class="header" href="#12-vt_bounded">12. <code>VT_BOUNDED</code></a></h4>
<pre><code class="language-c">#define VT_BOUNDED  0x8000
</code></pre>
<ul>
<li>表示当前值已经过了边界检查。编译器可以在生成代码时跳过进一步的边界检查，因为这个值已经被安全验证过。</li>
</ul>
<h3 id="总体理解"><a class="header" href="#总体理解">总体理解</a></h3>
<p><code>TinyCC</code> 编译器通过这些宏来表示<strong>当前值的状态</strong>，这些状态主要与以下几点有关：</p>
<ol>
<li><strong>值的位置</strong>：是存储在寄存器、栈、内存、还是常量池中。</li>
<li><strong>值的类型</strong>：是常量、局部变量、左值、右值等。</li>
<li><strong>值的语义</strong>：比如是否需要类型转换、边界检查、符号解析等。</li>
</ol>
<p>这些宏结合在一起，用来管理和跟踪在表达式解析、类型检查和代码生成过程中每个值的状态。通过这些标志位，编译器能够决定如何处理值，比如生成相应的指令，做什么样的类型转换，或者执行什么样的跳转逻辑。</p>
<h3 id="使用场景-2"><a class="header" href="#使用场景-2">使用场景</a></h3>
<p>假设编译器在处理某个表达式时，它可以通过 <code>current value</code> 来记录这个表达式的计算结果的状态。如果这个表达式是一个常量（如 <code>5</code>），那么 <code>VT_CONST</code> 就会被设置。如果这个常量需要类型转换（如 <code>int</code> 转换为 <code>float</code>），则会设置 <code>VT_MUSTCAST</code>。</p>
<p>再例如，若某个值是一个局部变量，存储在栈上，编译器会设置 <code>VT_LOCAL</code> 或 <code>VT_LLOCAL</code>，表示该值的存储位置，以便后续生成代码时知道从哪里读取这个值。</p>
<p>通过这些标志，<code>TinyCC</code> 编译器能有效地管理和优化编译过程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">scope</a></h1>
<pre><code class="language-c">static struct scope {
    struct scope *prev;
    struct { int loc, locorig, num; } vla;
    struct { Sym *s; int n; } cl;
    int *bsym, *csym;
    Sym *lstk, *llstk;
} *cur_scope, *loop_scope, *root_scope;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filespec"><a class="header" href="#filespec">filespec</a></h1>
<pre><code class="language-c">struct filespec {
    char type;
    char name[1];
};
</code></pre>
<p>为什么这里使用的 <code>char name[1]</code> 长度只有1 但是，又可以放很长的字符串。</p>
<p>这是 C 语言中一种常见的技巧，称为<strong>柔性数组成员</strong>（Flexible Array Member），尽管在这个例子中，严格来说并不完全是标准的柔性数组成员实现，而是它的一个变种。具体而言，<code>char name[1]</code> 被用来表示这个结构体的最后一个成员是一个数组，但它的实际长度可以在运行时动态分配和使用，超出声明时的长度。</p>
<h3 id="1-为什么-char-name1-可以容纳更长的字符串"><a class="header" href="#1-为什么-char-name1-可以容纳更长的字符串">1. 为什么 <code>char name[1]</code> 可以容纳更长的字符串？</a></h3>
<p><code>char name[1]</code> 在这个结构体的定义中只是一个占位符。它的作用是让 <code>name</code> 作为数组的一部分进行引用，但并不真正限制其大小。通常，开发者会在分配这个结构体的内存时，额外分配足够的空间来存放整个字符串。</p>
<p>在内存分配的时候，实际的内存空间远大于 <code>name[1]</code> 表示的 1 个字符，结构体中的 <code>name</code> 只是在编译时占了 1 个字节的空间，但可以在运行时分配更多内存。</p>
<h4 id="例子-1"><a class="header" href="#例子-1">例子：</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct filespec {
    char type;
    char name[1]; // 占位符
};

int main() {
    const char *filename = "very_long_filename.txt";
    // 计算实际需要的结构体大小，并分配足够的内存
    size_t size = sizeof(struct filespec) + strlen(filename);
    struct filespec *file = (struct filespec *)malloc(size);
    
    // 设置 type
    file-&gt;type = 'f';
    
    // 复制字符串到 name 处
    strcpy(file-&gt;name, filename);
    
    printf("Type: %c, Name: %s\n", file-&gt;type, file-&gt;name);

    free(file);
    return 0;
}
</code></pre>
<p>在这个例子中：</p>
<ul>
<li>虽然 <code>name[1]</code> 声明只有 1 字节，但我们通过 <code>malloc</code> 实际分配了足够的内存来存储整个字符串。</li>
<li><code>sizeof(struct filespec)</code> 只包含 <code>name[1]</code> 的 1 字节加上 <code>type</code> 的 1 字节，但通过 <code>strlen(filename)</code> 计算实际需要的内存来存放整个字符串。</li>
<li>使用 <code>strcpy</code> 将长字符串复制到 <code>name</code> 的位置，<code>name</code> 处实际上可以容纳更长的字符串，因为它背后的内存已经扩展。</li>
</ul>
<h3 id="2-标准的柔性数组成员"><a class="header" href="#2-标准的柔性数组成员">2. 标准的柔性数组成员</a></h3>
<p>在 C99 及后来的标准中，标准的做法是使用<strong>柔性数组成员</strong>，这是一种更加规范的方法来表示结构体中的可变长度数组。与 <code>char name[1]</code> 不同，柔性数组成员的写法是 <code>char name[]</code>，数组的大小不在定义时指定，而是由分配的内存决定。</p>
<h4 id="例子柔性数组成员"><a class="header" href="#例子柔性数组成员">例子（柔性数组成员）：</a></h4>
<pre><code class="language-c">struct filespec {
    char type;
    char name[];  // 柔性数组成员
};
</code></pre>
<p>在使用柔性数组成员时，通常也是通过动态内存分配来确保有足够的空间。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct filespec {
    char type;
    char name[];  // 柔性数组成员
};

int main() {
    const char *filename = "very_long_filename.txt";
    // 计算需要的内存，分配结构体大小加上字符串长度
    size_t size = sizeof(struct filespec) + strlen(filename) + 1; // +1 是为了终止符 '\0'
    struct filespec *file = (struct filespec *)malloc(size);
    
    file-&gt;type = 'f';
    strcpy(file-&gt;name, filename);
    
    printf("Type: %c, Name: %s\n", file-&gt;type, file-&gt;name);

    free(file);
    return 0;
}
</code></pre>
<p>与前面 <code>name[1]</code> 的实现相比，柔性数组成员 <code>name[]</code> 是 C 标准中的做法，编译器也会对此进行一些额外的支持。两者在运行时的效果几乎一样，但后者是更标准、推荐的做法。</p>
<h3 id="3-为什么使用-char-name1"><a class="header" href="#3-为什么使用-char-name1">3. 为什么使用 <code>char name[1]</code>？</a></h3>
<p>在 C99 之前，C 语言标准没有引入柔性数组成员的概念。因此，早期的 C 编译器无法直接使用 <code>char name[]</code> 这种定义方式，于是开发者采用 <code>char name[1]</code> 这种技巧来实现可变长度的数组成员。这种用法是为了兼容 C89 标准或者早期编译器。</p>
<p>即使在 C99 及之后的标准中引入了柔性数组成员，仍然有一些旧代码保持了这种使用 <code>char name[1]</code> 的风格。</p>
<h3 id="4-总结"><a class="header" href="#4-总结">4. 总结</a></h3>
<ul>
<li><code>char name[1]</code> 是一个编程技巧，用来在结构体中存储可变长度的数组。它声明了一个长度为 1 的数组，但实际使用时通过动态内存分配确保足够的空间来存储更长的字符串。</li>
<li>这种做法在 C99 之前是常见的，在 C99 标准引入柔性数组成员后，<code>char name[]</code> 这种形式成为了更规范的做法。</li>
<li>使用这种技巧时需要确保在分配内存时足够大，以容纳结构体的其他成员和可变长度的数组。</li>
</ul>
<h3 id="5-需要注意的点"><a class="header" href="#5-需要注意的点">5. 需要注意的点</a></h3>
<ul>
<li><strong>内存管理</strong>：动态分配内存时必须确保有足够的空间，避免内存越界。</li>
<li><strong>兼容性</strong>：对于 C99 及之后的代码，建议使用柔性数组成员 <code>char name[]</code> 来替代 <code>char name[1]</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-ifdef-stack"><a class="header" href="#include-ifdef-stack">include ifdef stack</a></h1>
<h2 id="tinycc-中的这几个是干啥用的"><a class="header" href="#tinycc-中的这几个是干啥用的">tinycc 中的这几个是干啥用的？</a></h2>
<pre><code class="language-c">s1-&gt;include_stack_ptr = s1-&gt;include_stack;
s1-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack;
file-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack_ptr;
</code></pre>
<p>在 <code>TinyCC</code>（<code>TCC</code>）编译器中，<code>include_stack</code> 和 <code>ifdef_stack</code> 是用于管理<strong>头文件包含</strong>和<strong>条件编译状态</strong>的栈结构。这些栈的主要作用是在编译预处理阶段跟踪 <code>#include</code> 文件的嵌套层次和 <code>#ifdef</code>（条件编译）语句的嵌套状态。</p>
<h3 id="1-include_stack-和-include_stack_ptr"><a class="header" href="#1-include_stack-和-include_stack_ptr">1. <code>include_stack</code> 和 <code>include_stack_ptr</code></a></h3>
<ul>
<li><strong><code>include_stack</code></strong> 是一个栈结构，用于管理 <code>#include</code> 头文件的嵌套。C 语言的 <code>#include</code> 预处理指令允许嵌套多个头文件，编译器需要跟踪当前文件是通过哪些 <code>#include</code> 包含进来的。</li>
<li><strong><code>include_stack_ptr</code></strong> 是一个指针，它指向当前的栈顶位置，表示当前正在处理的文件。</li>
</ul>
<h4 id="工作原理"><a class="header" href="#工作原理">工作原理：</a></h4>
<p>当编译器遇到 <code>#include</code> 指令时，它会打开并处理头文件。在每次进入一个新的头文件时，编译器会将当前的文件状态（例如文件指针、文件名、行号等）推入 <code>include_stack</code> 中，并更新 <code>include_stack_ptr</code> 来指向下一个文件。这样可以确保在头文件处理完毕后，编译器能够回到正确的文件继续编译。</p>
<p>例如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include "myfile.h"
</code></pre>
<p>在编译 <code>myfile.h</code> 时，当前文件（比如 <code>main.c</code>）的状态会被保存到 <code>include_stack</code>，然后编译器切换到 <code>myfile.h</code>。一旦 <code>myfile.h</code> 处理完毕，编译器会从 <code>include_stack</code> 中弹出先前保存的状态，继续处理 <code>main.c</code>。</p>
<h3 id="2-ifdef_stack-和-ifdef_stack_ptr"><a class="header" href="#2-ifdef_stack-和-ifdef_stack_ptr">2. <code>ifdef_stack</code> 和 <code>ifdef_stack_ptr</code></a></h3>
<ul>
<li><strong><code>ifdef_stack</code></strong> 是另一个栈结构，用于管理条件编译的嵌套状态。在 C 语言的预处理阶段，<code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code> 和 <code>#endif</code> 指令允许根据预处理符号来有条件地包含代码。编译器需要跟踪这些条件编译的嵌套状态，以确保正确跳过或编译代码段。</li>
<li><strong><code>ifdef_stack_ptr</code></strong> 是指向条件编译栈的指针，表示当前的条件编译状态。</li>
</ul>
<h4 id="工作原理-1"><a class="header" href="#工作原理-1">工作原理：</a></h4>
<p>在编译时，遇到 <code>#ifdef</code> 或 <code>#ifndef</code> 时，编译器会将当前的条件状态（是否满足编译条件）推入 <code>ifdef_stack</code>，并更新 <code>ifdef_stack_ptr</code> 来指向新的状态。当遇到 <code>#else</code> 或 <code>#endif</code> 时，编译器从栈中弹出之前的条件状态，确保正确处理嵌套的条件编译。</p>
<p>例如：</p>
<pre><code class="language-c">#ifdef DEBUG
    // 仅在定义 DEBUG 时编译
#endif
</code></pre>
<p>当编译器遇到 <code>#ifdef DEBUG</code> 时，它会将当前的条件编译状态保存到 <code>ifdef_stack</code> 中，并更新 <code>ifdef_stack_ptr</code>，以便在遇到 <code>#endif</code> 时恢复之前的状态。</p>
<h3 id="3-代码分析"><a class="header" href="#3-代码分析">3. 代码分析</a></h3>
<pre><code class="language-c">s1-&gt;include_stack_ptr = s1-&gt;include_stack;
s1-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack;
file-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack_ptr;
</code></pre>
<p>这几行代码初始化了 <code>TinyCC</code> 的预处理器状态，主要用于设置 <code>include</code> 和 <code>ifdef</code> 栈的起始位置：</p>
<ul>
<li>
<p><code>s1-&gt;include_stack_ptr = s1-&gt;include_stack;</code>：将 <code>s1</code>（通常是表示编译状态的结构体）的 <code>include_stack_ptr</code> 指针指向 <code>include_stack</code> 的起始位置。表示在编译开始时，文件的包含栈处于栈底，也就是没有嵌套的 <code>#include</code> 文件。</p>
</li>
<li>
<p><code>s1-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack;</code>：将 <code>ifdef_stack_ptr</code> 初始化为 <code>ifdef_stack</code> 的起始位置，表示条件编译的栈也处于栈底，当前还没有任何 <code>#ifdef</code> 的嵌套。</p>
</li>
<li>
<p><code>file-&gt;ifdef_stack_ptr = s1-&gt;ifdef_stack_ptr;</code>：将 <code>file</code> 的 <code>ifdef_stack_ptr</code> 设置为当前全局的 <code>ifdef_stack_ptr</code>，这表示当前文件在进入之前的条件编译状态将与当前的全局条件编译状态同步。这样做的目的是在编译新文件时能继承并跟踪全局的条件编译状态。</p>
</li>
</ul>
<h3 id="总结-14"><a class="header" href="#总结-14">总结</a></h3>
<ul>
<li><strong><code>include_stack</code></strong>：用于管理 <code>#include</code> 头文件的嵌套情况，帮助编译器跟踪当前在哪个头文件中，以便在处理完头文件后正确返回。</li>
<li><strong><code>ifdef_stack</code></strong>：用于管理条件编译（如 <code>#ifdef</code>、<code>#ifndef</code>）的嵌套状态，确保正确编译或跳过代码块。</li>
<li><strong><code>*_stack_ptr</code></strong>：是指向栈顶的指针，表示当前的处理状态，通过这些指针可以动态跟踪文件的包含和条件编译的嵌套情况。</li>
</ul>
<p>这些栈结构的初始化和使用，确保了编译器可以正确处理多层的头文件包含和条件编译，是 <code>TinyCC</code> 预处理阶段的重要组成部分。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="gen_function"><a class="header" href="#gen_function">gen_function</a></h1>
<pre><code class="language-c">/* parse a function defined by symbol 'sym' and generate its code in
   'cur_text_section', 我尼玛的，你真是牛逼，直接就准备生成代码了？ */
static void gen_function(Sym *sym)
{
    struct scope f = { 0 };
    cur_scope = root_scope = &amp;f; // 当前作用域和跟作用域
    nocode_wanted = 0;

    cur_text_section-&gt;sh_flags |= SHF_EXECINSTR;
    ind = cur_text_section-&gt;data_offset;
    if (sym-&gt;a.aligned) {
	    size_t newoff = section_add(cur_text_section, 0, 1 &lt;&lt; (sym-&gt;a.aligned - 1));
	    gen_fill_nops(newoff - ind);
    }

    funcname = get_tok_str(sym-&gt;v, NULL);
    func_ind = ind;
    func_vt = sym-&gt;type.ref-&gt;type;
    func_var = sym-&gt;type.ref-&gt;f.func_type == FUNC_ELLIPSIS;

    /* NOTE: we patch the symbol size later */
    put_extern_sym(sym, cur_text_section, ind, 0);

    if (sym-&gt;type.ref-&gt;f.func_ctor)
        add_array (tcc_state, ".init_array", sym-&gt;c);
    if (sym-&gt;type.ref-&gt;f.func_dtor)
        add_array (tcc_state, ".fini_array", sym-&gt;c);

    /* put debug symbol */
    tcc_debug_funcstart(tcc_state, sym);

    /* push a dummy symbol to enable local sym storage */
    sym_push2(&amp;local_stack, SYM_FIELD, 0, 0);
    local_scope = 1; /* for function parameters */
    gfunc_prolog(sym);
    tcc_debug_prolog_epilog(tcc_state, 0);

    local_scope = 0;
    rsym = 0;
    clear_temp_local_var_list();
    func_vla_arg(sym);
    block(0);
    gsym(rsym);

    nocode_wanted = 0;
    /* reset local stack */
    pop_local_syms(NULL, 0);
    tcc_debug_prolog_epilog(tcc_state, 1);
    gfunc_epilog();

    /* end of function */
    tcc_debug_funcend(tcc_state, ind - func_ind);

    /* patch symbol size */
    elfsym(sym)-&gt;st_size = ind - func_ind;

    cur_text_section-&gt;data_offset = ind;
    local_scope = 0;
    label_pop(&amp;global_label_stack, NULL, 0);
    sym_pop(&amp;all_cleanups, NULL, 0);

    /* It's better to crash than to generate wrong code */
    cur_text_section = NULL;
    funcname = ""; /* for safety */
    func_vt.t = VT_VOID; /* for safety */
    func_var = 0; /* for safety */
    ind = 0; /* for safety */
    func_ind = -1;
    nocode_wanted = DATA_ONLY_WANTED;
    check_vstack();

    /* do this after funcend debug info */
    next();
}
</code></pre>
<p><code>gen_function</code> 是 <code>TinyCC</code> 中负责生成一个函数代码的核心函数。它的作用是完成函数代码的生成，包括设置作用域、处理函数的入口和出口、生成必要的调试信息、符号管理等。下面我会详细分解这个函数的每个步骤，帮助你理解它的内部逻辑。</p>
<h3 id="1-初始化作用域"><a class="header" href="#1-初始化作用域">1. 初始化作用域</a></h3>
<pre><code class="language-c">struct scope f = { 0 };
cur_scope = root_scope = &amp;f; // 当前作用域和根作用域
nocode_wanted = 0;
</code></pre>
<ul>
<li>定义并初始化了一个函数级别的作用域 <code>f</code>。</li>
<li><code>cur_scope</code> 和 <code>root_scope</code> 被设置为这个作用域，表示当前编译的作用域是函数内部的作用域，同时这个作用域是函数的根作用域。</li>
<li><code>nocode_wanted</code> 被设置为 0，意味着在此作用域下将会生成代码（而非仅仅处理数据声明）。</li>
</ul>
<h3 id="2-设置代码段属性"><a class="header" href="#2-设置代码段属性">2. 设置代码段属性</a></h3>
<pre><code class="language-c">cur_text_section-&gt;sh_flags |= SHF_EXECINSTR;
ind = cur_text_section-&gt;data_offset;
</code></pre>
<ul>
<li><code>cur_text_section</code> 表示当前的文本段（即保存可执行代码的段），其 <code>sh_flags</code> 被设置为 <code>SHF_EXECINSTR</code>，表示这个段包含可执行指令。</li>
<li><code>ind</code> 用来存储当前文本段的 <code>data_offset</code>（数据偏移），表示接下来生成代码的位置。</li>
</ul>
<h3 id="3-函数对齐与-nop-指令填充"><a class="header" href="#3-函数对齐与-nop-指令填充">3. 函数对齐与 NOP 指令填充</a></h3>
<pre><code class="language-c">if (sym-&gt;a.aligned) {
    size_t newoff = section_add(cur_text_section, 0, 1 &lt;&lt; (sym-&gt;a.aligned - 1));
    gen_fill_nops(newoff - ind);
}
</code></pre>
<ul>
<li>如果函数的符号 <code>sym</code> 具有对齐要求（即 <code>sym-&gt;a.aligned</code> 不为 0），则通过 <code>section_add</code> 函数调整文本段的位置以满足对齐要求。对齐值由 <code>sym-&gt;a.aligned</code> 决定。</li>
<li><code>gen_fill_nops</code> 函数用来在对齐区域中填充 NOP 指令，这样可以保证指令不会被对齐操作影响。</li>
</ul>
<h3 id="4-设置函数元数据"><a class="header" href="#4-设置函数元数据">4. 设置函数元数据</a></h3>
<pre><code class="language-c">funcname = get_tok_str(sym-&gt;v, NULL);
func_ind = ind;
func_vt = sym-&gt;type.ref-&gt;type;
func_var = sym-&gt;type.ref-&gt;f.func_type == FUNC_ELLIPSIS;
</code></pre>
<ul>
<li><code>funcname</code> 保存了函数的名字，通过 <code>get_tok_str</code> 从符号 <code>sym</code> 中提取。</li>
<li><code>func_ind</code> 记录了函数在文本段中的起始位置，<code>ind</code> 是文本段的偏移量。</li>
<li><code>func_vt</code> 表示函数的返回类型（变量类型，<code>vt</code> 即 <code>variable type</code>），<code>sym-&gt;type.ref-&gt;type</code> 获取到的是函数返回类型。</li>
<li><code>func_var</code> 表示函数是否是一个可变参数函数（<code>FUNC_ELLIPSIS</code> 表示这是一个带有可变参数的函数）。</li>
</ul>
<h3 id="5-处理符号表与构造析构函数"><a class="header" href="#5-处理符号表与构造析构函数">5. 处理符号表与构造/析构函数</a></h3>
<pre><code class="language-c">put_extern_sym(sym, cur_text_section, ind, 0);

if (sym-&gt;type.ref-&gt;f.func_ctor)
    add_array(tcc_state, ".init_array", sym-&gt;c);
if (sym-&gt;type.ref-&gt;f.func_dtor)
    add_array(tcc_state, ".fini_array", sym-&gt;c);
</code></pre>
<ul>
<li><code>put_extern_sym</code> 将函数的符号 <code>sym</code> 放入全局符号表中，并与当前文本段绑定（以便之后的链接）。</li>
<li>如果函数被标记为构造函数（<code>func_ctor</code>），则将其加入 <code>.init_array</code>，这意味着它会在程序启动时被调用。</li>
<li>如果函数被标记为析构函数（<code>func_dtor</code>），则将其加入 <code>.fini_array</code>，这意味着它会在程序结束时被调用。</li>
</ul>
<h3 id="6-生成调试符号与函数序言"><a class="header" href="#6-生成调试符号与函数序言">6. 生成调试符号与函数序言</a></h3>
<pre><code class="language-c">tcc_debug_funcstart(tcc_state, sym);

sym_push2(&amp;local_stack, SYM_FIELD, 0, 0);
local_scope = 1; /* for function parameters */
gfunc_prolog(sym);
tcc_debug_prolog_epilog(tcc_state, 0);
</code></pre>
<ul>
<li><code>tcc_debug_funcstart</code> 生成函数的调试符号（用于调试器）。</li>
<li><code>sym_push2</code> 向 <code>local_stack</code> 中推入一个空的符号，这样可以使后续的局部符号（变量等）能够有合适的作用域。</li>
<li><code>local_scope = 1</code> 设置为局部作用域，用于函数参数的处理。</li>
<li><code>gfunc_prolog</code> 生成函数的序言部分，这通常包括设置栈帧等代码，准备进入函数的正式执行。</li>
<li><code>tcc_debug_prolog_epilog</code> 用来生成调试信息，标记函数序言和尾声部分的开始和结束。</li>
</ul>
<h3 id="7-生成函数体"><a class="header" href="#7-生成函数体">7. 生成函数体</a></h3>
<pre><code class="language-c">local_scope = 0;
rsym = 0;
clear_temp_local_var_list();
func_vla_arg(sym);
block(0);
gsym(rsym);
</code></pre>
<ul>
<li><code>local_scope = 0</code> 重置局部作用域，表示函数体的局部变量的作用域从现在开始。</li>
<li><code>clear_temp_local_var_list</code> 清空临时局部变量列表。</li>
<li><code>func_vla_arg</code> 处理函数中的可变长度数组参数。</li>
<li><code>block(0)</code> 调用函数解析并生成函数体的代码。<code>block</code> 负责处理函数内部的代码块。</li>
<li><code>gsym(rsym)</code> 用于处理跳转符号（<code>rsym</code> 是保存跳转目标的符号）。</li>
</ul>
<h3 id="8-函数尾声处理与符号清理"><a class="header" href="#8-函数尾声处理与符号清理">8. 函数尾声处理与符号清理</a></h3>
<pre><code class="language-c">nocode_wanted = 0;
pop_local_syms(NULL, 0);
tcc_debug_prolog_epilog(tcc_state, 1);
gfunc_epilog();
</code></pre>
<ul>
<li><code>pop_local_syms</code> 清除局部符号（局部变量、临时变量等）。</li>
<li><code>tcc_debug_prolog_epilog(tcc_state, 1)</code> 生成调试信息，标记函数尾声部分。</li>
<li><code>gfunc_epilog</code> 生成函数尾声代码，通常包括恢复栈帧、返回值的处理等。</li>
</ul>
<h3 id="9-函数结束与符号大小补丁"><a class="header" href="#9-函数结束与符号大小补丁">9. 函数结束与符号大小补丁</a></h3>
<pre><code class="language-c">tcc_debug_funcend(tcc_state, ind - func_ind);
elfsym(sym)-&gt;st_size = ind - func_ind;
</code></pre>
<ul>
<li><code>tcc_debug_funcend</code> 生成函数结束的调试信息。</li>
<li><code>elfsym(sym)-&gt;st_size = ind - func_ind</code> 设置 ELF 符号表中该函数的大小，<code>ind - func_ind</code> 表示该函数生成的代码字节数。</li>
</ul>
<h3 id="10-清理操作与安全措施"><a class="header" href="#10-清理操作与安全措施">10. 清理操作与安全措施</a></h3>
<pre><code class="language-c">cur_text_section-&gt;data_offset = ind;
local_scope = 0;
label_pop(&amp;global_label_stack, NULL, 0);
sym_pop(&amp;all_cleanups, NULL, 0);

cur_text_section = NULL;
funcname = ""; /* for safety */
func_vt.t = VT_VOID; /* for safety */
func_var = 0; /* for safety */
ind = 0; /* for safety */
func_ind = -1;
nocode_wanted = DATA_ONLY_WANTED;
check_vstack();
</code></pre>
<ul>
<li><code>cur_text_section-&gt;data_offset = ind</code> 更新文本段的偏移位置。</li>
<li><code>label_pop</code> 和 <code>sym_pop</code> 负责清理全局标签和符号栈中的内容。</li>
<li>接下来的几行代码重置了函数相关的全局变量，为了避免生成错误的代码或者发生不安全的操作：
<ul>
<li><code>cur_text_section</code> 被置空；</li>
<li><code>funcname</code> 被设置为空字符串；</li>
<li><code>func_vt.t</code> 被设置为 <code>VT_VOID</code>；</li>
<li><code>func_var</code> 被置为 0；</li>
<li><code>ind</code> 被重置；</li>
<li><code>func_ind</code> 也被重置为 -1；</li>
<li><code>nocode_wanted</code> 被设置为 <code>DATA_ONLY_WANTED</code>，表示当前不再需要生成代码。</li>
</ul>
</li>
<li><code>check_vstack</code> 最后检查虚拟栈的状态，确保生成的代码没有栈溢出或未平衡的栈操作。</li>
</ul>
<h3 id="11-解析下一个-token"><a class="header" href="#11-解析下一个-token">11. 解析下一个 token</a></h3>
<pre><code class="language-c">next();
</code></pre>
<ul>
<li>这行代码表示从源代码中获取下一个 token，继续编译流程。</li>
</ul>
<h3 id="总结-15"><a class="header" href="#总结-15">总结</a></h3>
<p><code>gen_function</code> 函数是 <code>TinyCC</code> 中负责生成一个函数代码的核心逻辑。它执行的主要任务包括：</p>
<ol>
<li>初始化函数的作用域、符号表、代码段等必要的数据结构。</li>
<li>处理函数的对齐、符号信息，并生成调试信息。</li>
<li>生成函数的序言、函数体和尾声代码。</li>
<li>清理局部符号、更新符号表，并确保代码生成的安全性。</li>
</ol>
<p>它将函数编译的多个步骤紧密结合在一起，通过对符号、作用域和代码段的操作来实现函数代码的生成。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
