# 编译的整体流程



## main 函数中剩余的方法
```c
    // 如果输出是在内存里面或者预处理的话，做了 blabla......
    if ((s->output_type == TCC_OUTPUT_MEMORY
      || s->output_type == TCC_OUTPUT_PREPROCESS)
        && (s->dflag & 16)) { /* -dt option */
        if (t)
            s->dflag |= 32;
        s->run_test = ++t;
        if (n)
            --n;
    }

    /* compile or add each files or library */
    first_file = NULL;
    do {
        struct filespec *f = s->files[n];
        s->filetype = f->type;
        printf("#### 编译单个文件 -> %s\n", f->name);
        if (f->type & AFF_TYPE_LIB) {
            printf("AFF_TYPE_LIB类型......... 使用枚举来判断\n");
            ret = tcc_add_library_err(s, f->name);
        } else {
            if (1 == s->verbose)
                printf("-> %s\n", f->name);
            if (!first_file)        // 为什么要有 first_file 呢?
                first_file = f->name;
            ret = tcc_add_file(s, f->name);
            printf("tcc_add_file 是干啥的...........\n");
        }
        done = ret || ++n >= s->nb_files;
        printf("判断是否 done了..................\n");
    } while (!done && (s->output_type != TCC_OUTPUT_OBJ || s->option_r));

    if (s->do_bench) {
        printf("判断是否是 bench, 如果是的话计算时间");
        end_time = getclock_ms();
    }
        

    if (s->run_test) {
        t = 0;
    } else if (s->output_type == TCC_OUTPUT_PREPROCESS) {
        ;
    } else if (0 == ret) {
        if (s->output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
            ret = tcc_run(s, argc, argv);
#endif
        } else {
            if (!s->outfile)
                s->outfile = default_outputfile(s, first_file);
            if (!s->just_deps && tcc_output_file(s, s->outfile))
                ;
            else if (s->gen_deps)
                gen_makedeps(s, s->outfile, s->deps_outfile);
        }
    }

    done = 1;
    if (t)
        done = 0; /* run more tests with -dt -run */
    else if (s->nb_errors)
        ret = 1;
    else if (n < s->nb_files)
        done = 0; /* compile more files with -c */
    else if (s->do_bench)
        tcc_print_stats(s, end_time - start_time);
    tcc_delete(s);
    if (!done) {  printf("#### 没有完成,跳转到 redo 继续.........\n");
        goto redo;}
    if (ppfp && ppfp != stdout)
        fclose(ppfp);
    printf("编译结束了....... 返回的结果是 %d, 是否成功: %s\n", ret, ret ? "失败" : "成功");
    return ret;
}
```


## tcc_add_library_err

```c
if (f->type & AFF_TYPE_LIB) {
    printf("AFF_TYPE_LIB类型......... 使用枚举来判断\n");
    ret = tcc_add_library_err(s, f->name);
} else {
```

如果文件类型为 `AFF_TYPE_LIB` 时，就执行 `tcc_add_library_err` 这个函数。


```c
PUB_FUNC int tcc_add_library_err(TCCState *s1, const char *libname)
{
    int ret = tcc_add_library(s1, libname);
    if (ret == FILE_NOT_FOUND)
        tcc_error_noabort("library '%s' not found", libname);
    return ret;
}
```

将库文件加入进来，如果有报错的话就执行 `tcc_error_noabort` 返回报错。

`ret` 会用来判断是否 done 了:

```c
done = ret || ++n >= s->nb_files;  printf("判断是否 done了..................\n");
```

## tcc_add_file


`tcc_add_file` 这个函数出现的位置是在 `libtcc.c` 中

在这里好像逻辑还好，就是判断了文件的类型，然后调用了  `tcc_add_file_internal` 方法，在 tcc_add_file_internal 中处理了不同的文件类型。

```c
LIBTCCAPI int tcc_add_file(TCCState *s, const char *filename)
{
    printf("执行 tcc_add_file 这个方法,LIBTCCAPI 这个宏是啥意思? filename 当做了入参了\n");
    int filetype = s->filetype; // 文件类型：c 源文件，汇编文件或者其他的
    if (0 == (filetype & AFF_TYPE_MASK)) {
        /* use a file extension to detect a filetype */
        const char *ext = tcc_fileextension(filename);
	    printf("获取 文件的后缀名..... %s\n", ext);
        if (ext[0]) {
            ext++;
            if (!strcmp(ext, "S")) filetype = AFF_TYPE_ASMPP; // PP是预处理吗
            else if (!strcmp(ext, "s")) filetype = AFF_TYPE_ASM;   // 汇编文件
            else if (!PATHCMP(ext, "c") || !PATHCMP(ext, "h") || !PATHCMP(ext, "i")) 
                filetype = AFF_TYPE_C;      // 源文件
            else filetype |= AFF_TYPE_BIN;  // 二进制的
        } else {
            filetype = AFF_TYPE_C;
        }
    }
    printf("准备调用 tcc_add_file_internal 方法了\n");
    return tcc_add_file_internal(s, filename, filetype | AFF_PRINT_ERROR);
}
```

## tcc_add_file_internal
`tcc_add_file_internal` 这个文件还是在 libtcc.h 这个文件中


源码：

```c
ST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags)
{
    int fd, ret = -1;

#if defined TARGETOS_OpenBSD && !defined _WIN32
    printf("不知道这里定义的是啥.........\n");
    char buf[1024];
    if (tcc_glob_so(s1, filename, buf, sizeof buf) >= 0)
        filename = buf;
#endif

    /* ignore binary files with -E */
    if (s1->output_type == TCC_OUTPUT_PREPROCESS && (flags & AFF_TYPE_BIN))
        return 0;

    /* open the file */
    printf("在 tcc_add_file_internal 中 使用  _tcc_open 打开文件 %s\n", filename);
    fd = _tcc_open(s1, filename);
    if (fd < 0) {
        if (flags & AFF_PRINT_ERROR)
            tcc_error_noabort("file '%s' not found", filename);
        return FILE_NOT_FOUND;
    }

    s1->current_filename = filename;
    if (flags & AFF_TYPE_BIN) {
        ElfW(Ehdr) ehdr;
        int obj_type;

        obj_type = tcc_object_type(fd, &ehdr);
        lseek(fd, 0, SEEK_SET);

        switch (obj_type) {

        case AFF_BINTYPE_REL:
            ret = tcc_load_object_file(s1, fd, 0);
            break;

        case AFF_BINTYPE_AR:
            ret = tcc_load_archive(s1, fd, !(flags & AFF_WHOLE_ARCHIVE));
            break;

#ifdef TCC_TARGET_PE
        default:
            ret = pe_load_file(s1, fd, filename);
            goto check_success;

#elif defined TCC_TARGET_MACHO
        case AFF_BINTYPE_DYN:
        case_dyn_or_tbd:
            if (s1->output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
                void* dl;
                const char* soname = filename;
                if (obj_type != AFF_BINTYPE_DYN)
                    soname = macho_tbd_soname(filename);
                dl = dlopen(soname, RTLD_GLOBAL | RTLD_LAZY);
                if (dl)
                    tcc_add_dllref(s1, soname, 0)->handle = dl, ret = 0;
	        if (filename != soname)
		    tcc_free((void *)soname);
#endif
            } else if (obj_type == AFF_BINTYPE_DYN) {
                ret = macho_load_dll(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);
            } else {
                ret = macho_load_tbd(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);
            }
            goto check_success;
        default:
        {
            const char *ext = tcc_fileextension(filename);
            if (!strcmp(ext, ".tbd"))
                goto case_dyn_or_tbd;
            if (!strcmp(ext, ".dylib")) {
                obj_type = AFF_BINTYPE_DYN;
                goto case_dyn_or_tbd;
            }
            goto check_success;
        }

#else /* unix */
        case AFF_BINTYPE_DYN:
            if (s1->output_type == TCC_OUTPUT_MEMORY) {
#ifdef TCC_IS_NATIVE
                void* dl = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);
                if (dl)
                    tcc_add_dllref(s1, filename, 0)->handle = dl, ret = 0;
#endif
            } else
                ret = tcc_load_dll(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);
            break;

        default:
            /* as GNU ld, consider it is an ld script if not recognized */
            ret = tcc_load_ldscript(s1, fd);
            goto check_success;

#endif /* pe / macos / unix */

check_success:
            if (ret < 0)
                tcc_error_noabort("%s: unrecognized file type", filename);
            break;

#ifdef TCC_TARGET_COFF
        case AFF_BINTYPE_C67:
            ret = tcc_load_coff(s1, fd);
            break;
#endif
        }
        close(fd);
    } else {
        /* update target deps */
        dynarray_add(&s1->target_deps, &s1->nb_target_deps, tcc_strdup(filename));
	    printf("tcc_add_file_internal 感觉到了这里就是对文件进行编译了...... %s\n", filename);
        printf("flags 好像和文件类型有关\n");
        ret = tcc_compile(s1, flags, filename, fd);
    }
    s1->current_filename = NULL;
    return ret;
}
```



## tcc_glob_so

好像是有条件的

```c
/* OpenBSD: choose latest from libxxx.so.x.y versions */
#if defined TARGETOS_OpenBSD && !defined _WIN32
```





## dynarray_add

动态数组相关的


```c
/********************************************************/
/* dynarrays */

ST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data)
{
    int nb, nb_alloc;
    void **pp;

    nb = *nb_ptr;
    pp = *(void ***)ptab;
    /* every power of two we double array size */
    if ((nb & (nb - 1)) == 0) {
        if (!nb)
            nb_alloc = 1;
        else
            nb_alloc = nb * 2;
        pp = tcc_realloc(pp, nb_alloc * sizeof(void *));
        *(void***)ptab = pp;
    }
    pp[nb++] = data;
    *nb_ptr = nb;
}

ST_FUNC void dynarray_reset(void *pp, int *n)
{
    void **p;
    for (p = *(void***)pp; *n; ++p, --*n)
        if (*p)
            tcc_free(*p);
    tcc_free(*(void**)pp);
    *(void**)pp = NULL;
}

static void tcc_split_path(TCCState *s, void *p_ary, int *p_nb_ary, const char *in)
{
    const char *p;
    do {
        int c;
        CString str;

        cstr_new(&str);
        for (p = in; c = *p, c != '\0' && c != PATHSEP[0]; ++p) {
            if (c == '{' && p[1] && p[2] == '}') {
                c = p[1], p += 2;
                if (c == 'B')
                    cstr_cat(&str, s->tcc_lib_path, -1);
                if (c == 'R')
                    cstr_cat(&str, CONFIG_SYSROOT, -1);
                if (c == 'f' && file) {
                    /* substitute current file's dir */
                    const char *f = file->true_filename;
                    const char *b = tcc_basename(f);
                    if (b > f)
                        cstr_cat(&str, f, b - f - 1);
                    else
                        cstr_cat(&str, ".", 1);
                }
            } else {
                cstr_ccat(&str, c);
            }
        }
        if (str.size) {
            cstr_ccat(&str, '\0');
            dynarray_add(p_ary, p_nb_ary, tcc_strdup(str.data));
        }
        cstr_free(&str);
        in = p+1;
    } while (*p);
}
```


## tcc_compile


