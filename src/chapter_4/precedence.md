# 运算符的优先级

```c
static int precedence(int tok)
{
    switch (tok) {
        case TOK_LOR: 
            return 1;
        case TOK_LAND: 
            return 2;
	    case '|': 
            return 3;
	    case '^': 
            return 4;
	    case '&': 
            return 5;
	    case TOK_EQ: 
        case TOK_NE: 
            return 6;
 relat: case TOK_ULT: 
        case TOK_UGE: 
            return 7;
	    case TOK_SHL: 
        case TOK_SAR: 
            return 8;
	    case '+': 
        case '-': 
            return 9;
        case '*': 
        case '/': 
        case '%': 
            return 10;
	default:
	    if (tok >= TOK_ULE && tok <= TOK_GT)
	        goto relat;
	    return 0;
    }
}
```

`TinyCC` 中的 `precedence` 函数用于返回给定运算符的**优先级**，在编译器中这通常用于解析表达式时决定操作符的处理顺序。运算符优先级决定了哪些操作符在没有括号的情况下应先被处理。

### 函数解析

#### 函数签名
```c
static int precedence(int tok)
```

- `precedence` 是一个静态函数，表示它的作用范围仅限于定义它的文件。
- 它的参数 `tok` 是一个整数，表示操作符的**标记（token）**。
- 返回值是一个整数，表示该操作符的优先级。返回的值越大，表示优先级越高。

### 1. **使用 `switch` 判断运算符**

函数内部使用了 `switch-case` 结构来根据传入的 `tok` 值（即操作符）来返回不同的优先级。不同的运算符具有不同的优先级，影响它们在表达式中被解析的顺序。

#### 2. **运算符及其优先级**

- **逻辑或 (`||`)**：优先级为 `1`
  
  ```c
  case TOK_LOR: 
      return 1;
  ```

- **逻辑与 (`&&`)**：优先级为 `2`
  
  ```c
  case TOK_LAND: 
      return 2;
  ```

- **按位或 (`|`)**：优先级为 `3`
  
  ```c
  case '|': 
      return 3;
  ```

- **按位异或 (`^`)**：优先级为 `4`
  
  ```c
  case '^': 
      return 4;
  ```

- **按位与 (`&`)**：优先级为 `5`
  
  ```c
  case '&': 
      return 5;
  ```

- **相等 (`==`) 和不等 (`!=`)**：优先级为 `6`
  
  ```c
  case TOK_EQ: 
  case TOK_NE: 
      return 6;
  ```

- **比较运算符 (`<`, `>=`, `>`, `<=`)**：优先级为 `7`
  
  ```c
  relat: case TOK_ULT: 
  case TOK_UGE: 
      return 7;
  ```

  注意，`TOK_ULT` 和 `TOK_UGE` 是 TinyCC 特定的标记，分别表示“无符号小于”和“无符号大于等于”。对于其他类似的比较运算符，它们会使用 `goto relat` 语句跳转到这一块代码。

- **移位运算 (`<<`, `>>`)**：优先级为 `8`
  
  ```c
  case TOK_SHL: 
  case TOK_SAR: 
      return 8;
  ```

- **加 (`+`) 和减 (`-`)**：优先级为 `9`
  
  ```c
  case '+': 
  case '-': 
      return 9;
  ```

- **乘 (`*`)，除 (`/`)，取模 (`%`)**：优先级为 `10`
  
  ```c
  case '*': 
  case '/': 
  case '%': 
      return 10;
  ```

#### 3. **默认返回值**
如果给定的 `tok` 不属于任何已知的运算符，则返回 `0`，表示没有优先级。通常，返回 `0` 的情况用于处理非法或未识别的标记。

```c
default:
    if (tok >= TOK_ULE && tok <= TOK_GT)
        goto relat;
    return 0;
```

- 这里有一个 `if` 判断，如果 `tok` 处于 `TOK_ULE`（无符号小于等于）到 `TOK_GT`（大于）之间，会跳转到 `relat` 标签，返回优先级 `7`，与其他比较运算符相同。

#### 4. **`goto` 的使用**

```c
relat:
    case TOK_ULT: 
    case TOK_UGE: 
        return 7;
```

在 `default` 代码块中使用了 `goto` 语句跳转到 `relat` 标签。这样做的目的是处理类似比较运算符的情况（如 `<`、`<=`、`>`、`>=`），这些运算符通常具有相同的优先级，因此它们被跳转到同一个代码段来统一返回优先级 `7`。

### 优先级解释

优先级的数值越大，表示该操作符的优先级越高，在解析时会先于其他操作符进行计算。举例来说：

- 乘法和除法（优先级 `10`）会先于加法和减法（优先级 `9`）进行计算。
- 比较运算符（如 `<`、`>`, 优先级 `7`）会晚于加法和减法计算。

### 例子

假设我们有如下表达式：

```c
a + b * c
```

在编译器处理该表达式时，它会依赖 `precedence` 函数来确定操作符的优先级。

1. `precedence('+')` 返回 `9`。
2. `precedence('*')` 返回 `10`。

因此编译器知道应该先计算 `b * c`，再进行 `a + (b * c)` 的计算。

### 总结

- `precedence` 函数根据操作符的标记（`tok`）返回对应的优先级。
- 使用 `switch-case` 结构处理不同的操作符，并根据 C 语言的运算符优先级规则返回不同的数值。
- 函数处理了大多数常见的运算符，如逻辑与或、按位与或、加减乘除、移位、比较等。
- `goto` 被用来处理某些相同优先级的运算符，简化代码结构。

该函数是 `TinyCC` 编译器中用于解析表达式时的重要组成部分，决定了各个操作符的执行顺序。


# 详细解释这个相关的代码


```c
static unsigned char prec[256];
static void init_prec(void)
{
    int i;
    for (i = 0; i < 256; i++) {
        // precedence 使用来计算 token 的优先级的
        // 这里相当于提前缓存了 token 的优先级了？
	    prec[i] = precedence(i);
    }
}
#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)
```

在这段代码中，`TinyCC` 编译器使用了一个优化技巧，通过提前计算和缓存操作符的优先级来提高表达式解析的效率。让我们逐步分析每个部分。

### 1. **`prec` 数组**
```c
static unsigned char prec[256];
```

- **`prec`** 是一个长度为 256 的数组，元素类型为 `unsigned char`，用于存储操作符或 `token` 的优先级。数组的大小为 256，这与 `C` 语言中的 ASCII 字符集和其他常见符号（如运算符）有关，因为这些符号通常可以通过单字节表示。
- 这个数组的每个元素 `prec[i]` 将会存储 ASCII 值为 `i` 的字符对应的优先级。例如，字符 `'+'` 的 ASCII 值是 43，那么 `prec[43]` 将会存储 `+` 的优先级。

### 2. **`init_prec` 函数**
```c
static void init_prec(void)
{
    int i;
    for (i = 0; i < 256; i++) {
        // precedence 使用来计算 token 的优先级的
        // 这里相当于提前缓存了 token 的优先级了？
	    prec[i] = precedence(i);
    }
}
```

- 这个函数的作用是初始化 `prec` 数组。它遍历所有可能的字符（从 0 到 255，涵盖了所有可能的单字节 `token`），并调用 `precedence(i)` 来获取每个字符的优先级，然后将优先级缓存到 `prec` 数组的对应位置。
- **缓存优先级**：通过调用 `precedence(i)`，它将每个可能的 `token` 的优先级存入 `prec` 数组。这意味着当需要查询某个 `token` 的优先级时，不需要重新计算，而是可以直接从 `prec` 数组中查找，从而提高了效率。

### 3. **宏定义 `precedence`**
```c
#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)
```

- 这个宏定义重新定义了 `precedence`，它不再直接调用原来的 `precedence` 函数，而是根据传入的 `i` 值（`token`），直接查找 `prec` 数组。
  - 如果 `i` 小于 256（即属于单字节 `token` 的范围），就直接返回 `prec[i]` 中存储的优先级。
  - 如果 `i` 超出了 256 的范围，宏会返回 `0`，表示该 `token` 没有优先级，或者不适用于当前的计算。

### 优化分析

1. **缓存机制**：
   - 在最初的 `init_prec` 函数中调用了 `precedence(i)`（这是函数版的 `precedence`）来计算每个 `token` 的优先级，并将结果缓存到 `prec` 数组中。这种缓存机制避免了在编译过程中每次遇到 `token` 时都要重新调用 `precedence` 函数进行计算，从而提升了编译器解析表达式的效率。

2. **高效查询**：
   - 当我们需要查询某个 `token` 的优先级时，通过宏 `precedence(i)` 直接在 `prec` 数组中查找，查询速度是常数时间 `O(1)`，这比每次重新计算优先级更快。
   - 特别是在解析复杂表达式时，编译器会频繁调用 `precedence`，而这种优化能够显著加快解析速度。

3. **边界处理**：
   - 宏定义中 `(unsigned)i < 256` 这个条件确保了只有在 `i` 属于合法的单字节 `token` 范围内时，才会进行数组查找，否则返回 `0`，表示该 `token` 没有优先级。
   - 通过使用 `unsigned` 强制转换，可以防止负数 `i` 的情况发生（即使传入负值也会转换为大数，从而不符合 `< 256` 的条件）。

### 整体逻辑

1. **初始化**：`init_prec` 函数在编译器的初始化阶段被调用，遍历 0 到 255 的所有字符值，并为每个字符计算其优先级，存入 `prec` 数组。这个初始化过程只会进行一次。
2. **快速查找**：之后在编译器的整个编译过程中，每次需要查找 `token` 的优先级时，不再调用函数来计算，而是通过 `precedence(i)` 宏直接从 `prec` 数组中获取优先级。

### 实际效果

假设我们正在编译如下表达式：

```c
a + b * c;
```

在编译器解析这个表达式时，需要知道 `+` 和 `*` 的优先级，以决定它们的计算顺序。具体过程如下：

1. `precedence('+')`：`+` 的 ASCII 值是 43，因此 `precedence(43)` 会返回 `prec[43]` 中存储的值，它是在 `init_prec` 函数中通过 `precedence(43)` 计算得出的优先级（例如 `9`，假设加法优先级为 9）。
   
2. `precedence('*')`：`*` 的 ASCII 值是 42，因此 `precedence(42)` 会返回 `prec[42]` 中存储的值，假设乘法优先级为 `10`。

根据优先级，编译器知道应该先计算 `b * c`，然后再计算 `a + (b * c)`。

### 总结

- 该代码的主要目的是通过**缓存**每个 `token`（字符或操作符）的优先级来提高编译器处理表达式时的效率。
- `init_prec` 函数在编译器初始化时一次性计算并存储每个 `token` 的优先级。
- 后续所有优先级查询通过宏 `precedence(i)` 在常数时间内从 `prec` 数组中直接获取，从而提高编译效率，避免每次重复计算。


# 不会冲突吗？


```c
#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)


static int precedence(int tok)
```



你提到的 `#define precedence(i)` 宏和 `static int precedence(int tok)` 函数确实存在**命名冲突**的潜在风险。然而，在 C 语言中，这种冲突会根据具体的作用域和预处理的工作方式来决定是否真的会引发问题。

### 1. **宏与函数的命名冲突**

- 在 C 语言中，宏定义发生在**预处理阶段**，而函数的定义和调用发生在**编译阶段**。因此，宏会优先于函数，宏替换在编译器实际处理代码之前已经发生。
- 在你给出的代码中，宏 `#define precedence(i)` 和函数 `static int precedence(int tok)` 使用了相同的名字。如果在函数体之外的地方调用了 `precedence(i)`，该调用会被宏替换所覆盖，这会导致宏优先替换，函数实际上无法被正常调用，甚至可能会引发编译错误。

### 2. **如何避免冲突**

这种冲突通常会导致代码难以调试和理解，因此有几种方法可以避免它：

#### 方法 1：重命名宏或函数

最简单和常见的做法是重命名宏或者函数，以避免它们之间的名字冲突。例如，你可以重命名宏为 `prec_macro(i)`：

```c
#define prec_macro(i) ((unsigned)i < 256 ? prec[i] : 0)
```

这样，函数和宏就不会冲突。

#### 方法 2：局部取消宏定义

你可以通过在需要调用函数的地方临时**取消宏定义**，然后在需要时再次定义它。这种方法通常用在大型代码库或需要兼容宏的地方。

```c
#undef precedence  // 取消宏定义
static int precedence(int tok) {
    // 函数体
}
#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)  // 恢复宏定义
```

通过 `#undef` 可以临时禁用宏，使得在定义函数时不会发生冲突。

#### 方法 3：使用命名空间或前缀

在大型项目中，通常使用**前缀**来区分不同的命名空间。你可以给宏或函数加上前缀，例如将宏改为 `prec_precedence(i)`，或者将函数命名为 `precedence_func`：

```c
#define prec_precedence(i) ((unsigned)i < 256 ? prec[i] : 0)

static int precedence_func(int tok) {
    // 函数体
}
```

### 3. **可能的问题**

如果你没有注意到宏和函数名称的冲突，并且尝试在某处调用 `precedence(…)` 函数，宏将覆盖函数的调用。这样可能会导致一些意料之外的结果，例如：
- 编译器生成的代码中，原本调用函数的地方变成了宏的展开式。
- 如果传递给 `precedence(…)` 的参数不符合宏的期望，可能会导致错误的行为，甚至编译错误。

#### 示例：

如果你在某处调用：
```c
int result = precedence(42);
```

在这个上下文中，本应调用函数 `precedence(42)`，但宏定义会将这段代码替换为：
```c
int result = ((unsigned)42 < 256 ? prec[42] : 0);
```

此时函数就不会被调用，而是执行了宏的逻辑。

### 4. **总结**

- 在当前代码中，确实存在宏和函数命名冲突的问题。
- 宏会在预处理阶段展开，优先于函数，因此会覆盖掉同名的函数调用，导致函数无法被正确调用。
- 为避免这种冲突，建议采用**重命名宏或函数**、**临时取消宏定义**或**使用命名空间前缀**等方式。

合理管理宏和函数的命名是良好编码实践的一部分，特别是在大型项目中。

