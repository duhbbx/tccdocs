# &"" 这是什么用法


```c
fprintf(fp, &" %s"[s], t == TOK_PLCHLDR ? "<>" : get_tok_str(t, &cval));
```


这段代码是 `TinyCC` 中使用了一个稍微不常见的**字符串切片技巧**，并结合了三元运算符和 `fprintf` 函数进行格式化输出。它的核心目的是根据条件格式化字符串并写入到文件指针 `fp` 中。

我们来逐步分析这个语句：

```c
fprintf(fp, &" %s"[s], t == TOK_PLCHLDR ? "<>" : get_tok_str(t, &cval));
```

### 1. **`fprintf` 函数**

`fprintf` 是标准 C 库中的一个函数，用于将格式化字符串输出到指定的文件流中。在这里，它将结果写入到文件指针 `fp` 所指向的文件流中。`fprintf` 的第一个参数是文件流指针，第二个参数是格式化字符串，后面的参数则是要填充到格式化字符串中的值。

### 2. **`&" %s"[s]`：字符串偏移**

这部分代码是这个语句中较为不常见的技巧。让我们逐步分析：
- **`" %s"`**：这是一个 C 风格的字符串，表示格式化输出中的一个字符串占位符 `%s`，用于插入字符串。
- **`" %s"[s]`**：这是一个字符串偏移技巧，通过将字符串 `" %s"` 视为字符数组，取索引为 `s` 处的字符。例如，如果 `s == 0`，则 `" %s"[s]` 是 `' '`，如果 `s == 1`，则 `" %s"[s]` 是 `'%'`，依此类推。
- **`&" %s"[s]`**：通过取地址符号 `&`，实际上是从字符串 `" %s"` 的第 `s` 个字符开始截取一个子字符串。例如：
  - 如果 `s == 0`，则 `&" %s"[0]` 等价于 `" %s"`（完整字符串）。
  - 如果 `s == 1`，则 `&" %s"[1]` 等价于 `"%s"`（去掉了第一个空格）。
  - 如果 `s == 2`，则 `&" %s"[2]` 等价于 `"s"`（仅剩最后一个字符 `s`）。
  
这种用法是为了根据 `s` 的值来动态控制输出的格式化字符串。

### 3. **三元运算符**

```c
t == TOK_PLCHLDR ? "<>" : get_tok_str(t, &cval)
```

这个部分是一个**三元运算符**，它根据条件返回不同的值。具体解释如下：

- **`t == TOK_PLCHLDR`**：检查 `t` 是否等于 `TOK_PLCHLDR`，这是一个标记（token）的常量值。
- 如果条件为真，即 `t` 是 `TOK_PLCHLDR`，则返回字符串 `"<>"`。
- 如果条件为假，则调用 `get_tok_str(t, &cval)` 函数，该函数通常用于将 `t`（token 标记）转换为对应的字符串表示，`&cval` 可能是相关的附加值。

### 4. **整体分析**

结合上述部分，完整的语句做了以下几件事情：

1. **格式化字符串选择**：通过 `&" %s"[s]` 来决定是否要输出一个带空格的格式化字符串 `%s`，或者是去掉空格后的字符串 `"%s"` 或 `"s"`，这取决于 `s` 的值。
   
   - 如果 `s == 0`，将会输出 `" %s"`，即在输出的字符串前面加一个空格。
   - 如果 `s == 1`，则只输出 `"%s"`，即不带空格。
   - 如果 `s == 2`，将输出 `"s"`，只输出单个 `s` 字符。

2. **输出内容选择**：通过三元运算符 `t == TOK_PLCHLDR ? "<>" : get_tok_str(t, &cval)` 决定应该输出什么字符串：
   - 如果 `t` 是 `TOK_PLCHLDR`，输出 `"<>"`。
   - 如果 `t` 是其他标记，则调用 `get_tok_str` 函数获取对应标记的字符串表示。

3. **最终效果**：`fprintf(fp, &" %s"[s], ...)` 这个语句将根据 `s` 的值决定格式化字符串的样式（带空格还是不带空格），并将合适的字符串写入到文件指针 `fp` 指向的流中。

### 5. **示例分析**

假设：
- `s == 0`：则 `&" %s"[s]` 变成 `" %s"`，即输出时会有一个空格，格式化字符串为 `" %s"`。
- `t == TOK_PLCHLDR`：则输出字符串 `"<>"`。
- 最终，`fprintf(fp, " %s", "<>")`，这会在文件中写入 `" <>"`。

假设：
- `s == 1`：则 `&" %s"[s]` 变成 `"%s"`，格式化字符串为 `"%s"`，即不带空格。
- `t` 是其他标记，则 `get_tok_str(t, &cval)` 返回字符串 `"identifier"`。
- 最终，`fprintf(fp, "%s", "identifier")`，这会在文件中写入 `"identifier"`。

### 6. **总结**

这段代码结合了字符串偏移和三元运算符来灵活地控制输出的格式和内容：
- 通过 `&" %s"[s]` 来控制格式化字符串是否带空格。
- 通过 `t == TOK_PLCHLDR` 来决定输出特殊占位符 `"<>"` 还是标记的字符串表示。

这种用法在编译器实现中很常见，用来简洁地处理复杂的格式化输出。

