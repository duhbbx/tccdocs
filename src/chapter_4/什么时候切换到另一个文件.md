# 什么时候切换到另一个文件

```c
/* add end of include file debug info */
tcc_debug_eincl(tcc_state);
/* pop include stack */
tcc_close();
s1->include_stack_ptr--;
p = file->buf_ptr;
goto maybe_newline;
```


#  tcc_close()

```c
ST_FUNC void tcc_close(void)
{
    TCCState *s1 = tcc_state;
    BufferedFile *bf = file;
    if (bf->fd > 0) {
        close(bf->fd);
        total_lines += bf->line_num - 1;
    }
    if (bf->true_filename != bf->filename)
        tcc_free(bf->true_filename);

    char * old_filename = bf->filename;
    file = bf->prev;
    const char * new_filename = file ? file->filename : "上一个为空";
    printf("上一个解析的文件名: %s, 下一个文件名: %s\n", old_filename, new_filename);
    tok_flags = bf->prev_tok_flags;
    if (!strcmp("a.c", new_filename)) {
        printf("解析到我写的文件了............%s\n", new_filename);
    }
    tcc_free(bf);
}
```

# 分析

这个 `tcc_close` 方法主要是用来关闭当前文件的处理，并进行一些清理操作。在 `tinycc`（一个小型 C 语言编译器）中，文件的处理通常涉及多个编译阶段，该函数在关闭当前处理的文件时执行一些收尾工作。

下面是对 `tcc_close` 函数的详细分析：

### 1. 获取当前的编译状态和文件信息
```c
TCCState *s1 = tcc_state;
BufferedFile *bf = file;
```
- `TCCState *s1 = tcc_state;`：`tcc_state` 保存了编译的全局状态，`s1` 用来引用当前的编译状态。
- `BufferedFile *bf = file;`：`file` 是当前正在处理的文件，`bf` 保存了指向当前文件的缓冲区信息。

### 2. 关闭文件描述符
```c
if (bf->fd > 0) {
    close(bf->fd);
    total_lines += bf->line_num - 1;
}
```
- `bf->fd > 0`：这里判断文件描述符是否有效（大于 0 表示文件已打开）。
- `close(bf->fd);`：关闭当前文件的文件描述符。
- `total_lines += bf->line_num - 1;`：更新行数统计信息，将该文件的行数累加到总行数中。

### 3. 释放真实的文件名
```c
if (bf->true_filename != bf->filename)
    tcc_free(bf->true_filename);
```
- `bf->true_filename != bf->filename`：这里检查 `true_filename` 和 `filename` 是否不同。通常，这可能是在处理符号链接或虚拟文件系统时使用的，`true_filename` 可能指向实际的文件路径。
- `tcc_free(bf->true_filename);`：释放 `true_filename` 所占用的内存。

### 4. 切换到之前的文件
```c
char * old_filename = bf->filename;
file = bf->prev;
const char * new_filename = file ? file->filename : "上一个为空";
```
- `char * old_filename = bf->filename;`：保存当前文件的文件名，以便后续打印信息。
- `file = bf->prev;`：将当前文件指针切换到上一个文件。这可能是因为当前文件被嵌套处理（例如头文件嵌套 `#include`），所以需要回到之前的文件。
- `const char * new_filename = file ? file->filename : "上一个为空";`：检查新的文件是否存在，若不存在则输出“上一个为空”。

### 5. 打印文件切换信息
```c
printf("上一个解析的文件名: %s, 下一个文件名: %s\n", old_filename, new_filename);
```
- 打印当前关闭的文件名以及下一个即将处理的文件名（如果有的话）。

### 6. 恢复上一个文件的标记
```c
tok_flags = bf->prev_tok_flags;
```
- `tok_flags` 是词法分析器的标记状态，处理不同文件时可能需要不同的标记。这里将标记状态恢复到前一个文件的状态。

### 7. 特定文件检查
```c
if (!strcmp("a.c", new_filename)) {
    printf("解析到我写的文件了............%s\n", new_filename);
}
```
- 这是一个特殊的调试语句，检查当前文件是否是 `a.c`，如果是的话输出调试信息。这通常是用于开发调试期间，确认处理的文件是否是某个特定文件。

### 8. 释放文件缓冲区
```c
tcc_free(bf);
```
- 释放当前文件缓冲区对象 `bf` 所占用的内存。

### 总结
`tcc_close` 的主要作用是关闭当前正在处理的文件，执行文件描述符的关闭，更新行数统计信息，释放内存资源，并切换到前一个文件继续处理。这对于编译器在处理多个嵌套文件时非常重要，能够确保在完成一个文件的处理后，正确地回到上一个文件。

`eol` 一般指**行尾（End of Line）**，在这个函数中没有明确提及，但它可能是在文件行号计数中隐含地用到了。